==================================================================
COMPONENT: UTILITIES
==================================================================
Common utility functions and data structures used throughout
the codebase.

Key concepts:
- Byte operations
- Random number generation
- Vector operations
- List structures
- Debug utilities
- Machine-dependent data

Files included:
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/ut0byte.h
Utilities for byte operations

Created 1/20/1994 Heikki Tuuri
***********************************************************************/

#ifndef ut0byte_h
#define ut0byte_h


#include "univ.i"

/** Pair of ulint integers. */
typedef	struct dulint_struct	dulint;
/** Type definition for a 64-bit unsigned integer, which works also
in 32-bit machines. NOTE! Access the fields only with the accessor
functions. This definition appears here only for the compiler to
know the size of a dulint. */
struct dulint_struct{
	ulint	high;	/*!< most significant 32 bits */
	ulint	low;	/*!< least significant 32 bits */
};

/** Zero value for a dulint */
extern const dulint	ut_dulint_zero;

/** Maximum value for a dulint */
extern const dulint	ut_dulint_max;

/*******************************************************//**
Creates a 64-bit dulint out of two ulints.
@return	created dulint */
UNIV_INLINE
dulint
ut_dulint_create(
/*=============*/
	ulint	high,	/*!< in: high-order 32 bits */
	ulint	low);	/*!< in: low-order 32 bits */
/*******************************************************//**
Gets the high-order 32 bits of a dulint.
@return	32 bits in ulint */
UNIV_INLINE
ulint
ut_dulint_get_high(
/*===============*/
	dulint	d);	/*!< in: dulint */
/*******************************************************//**
Gets the low-order 32 bits of a dulint.
@return	32 bits in ulint */
UNIV_INLINE
ulint
ut_dulint_get_low(
/*==============*/
	dulint	d);	/*!< in: dulint */
/*******************************************************//**
Converts a dulint (a struct of 2 ulints) to ib_int64_t, which is a 64-bit
integer type.
@return	value in ib_int64_t type */
UNIV_INLINE
ib_int64_t
ut_conv_dulint_to_longlong(
/*=======================*/
	dulint	d);	/*!< in: dulint */
/*******************************************************//**
Tests if a dulint is zero.
@return	TRUE if zero */
UNIV_INLINE
ibool
ut_dulint_is_zero(
/*==============*/
	dulint	a);	/*!< in: dulint */
/*******************************************************//**
Compares two dulints.
@return	-1 if a < b, 0 if a == b, 1 if a > b */
UNIV_INLINE
int
ut_dulint_cmp(
/*==========*/
	dulint	a,	/*!< in: dulint */
	dulint	b);	/*!< in: dulint */
/*******************************************************//**
Adds a ulint to a dulint.
@return	sum a + b */
UNIV_INLINE
dulint
ut_dulint_add(
/*==========*/
	dulint	a,	/*!< in: dulint */
	ulint	b);	/*!< in: ulint */
/*******************************************************//**
Subtracts a ulint from a dulint.
@return	a - b */
UNIV_INLINE
dulint
ut_dulint_subtract(
/*===============*/
	dulint	a,	/*!< in: dulint */
	ulint	b);	/*!< in: ulint, b <= a */
/********************************************************//**
Rounds a dulint downward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
dulint
ut_dulint_align_down(
/*=================*/
	dulint	 n,		/*!< in: number to be rounded */
	ulint	 align_no);	/*!< in: align by this number which must be a
				power of 2 */
/********************************************************//**
Rounds a dulint upward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
dulint
ut_dulint_align_up(
/*===============*/
	dulint	 n,		/*!< in: number to be rounded */
	ulint	 align_no);	/*!< in: align by this number which must be a
				power of 2 */
/********************************************************//**
Rounds a dulint downward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
ib_uint64_t
ut_uint64_align_down(
/*=================*/
	ib_uint64_t	 n,		/*!< in: number to be rounded */
	ulint		 align_no);	/*!< in: align by this number
					which must be a power of 2 */
/********************************************************//**
Rounds ib_uint64_t upward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
ib_uint64_t
ut_uint64_align_up(
/*===============*/
	ib_uint64_t	 n,		/*!< in: number to be rounded */
	ulint		 align_no);	/*!< in: align by this number
					which must be a power of 2 */
/*******************************************************//**
Increments a dulint variable by 1. */
#define UT_DULINT_INC(D)\
{\
	if ((D).low == 0xFFFFFFFFUL) {\
		(D).high = (D).high + 1;\
		(D).low = 0;\
	} else {\
		(D).low = (D).low + 1;\
	}\
}
/*******************************************************//**
Tests if two dulints are equal. */
#define UT_DULINT_EQ(D1, D2)	(((D1).low == (D2).low)\
						&& ((D1).high == (D2).high))
#ifdef notdefined
/************************************************************//**
Sort function for dulint arrays. */
UNIV_INTERN
void
ut_dulint_sort(
/*===========*/
	dulint*	arr,	/*!< in/out: array to be sorted */
	dulint*	aux_arr,/*!< in/out: auxiliary array (same size as arr) */
	ulint	low,	/*!< in: low bound of sort interval, inclusive */
	ulint	high);	/*!< in: high bound of sort interval, noninclusive */
#endif /* notdefined */

/*********************************************************//**
The following function rounds up a pointer to the nearest aligned address.
@return	aligned pointer */
UNIV_INLINE
void*
ut_align(
/*=====*/
	const void*	ptr,		/*!< in: pointer */
	ulint		align_no);	/*!< in: align by this number */
/*********************************************************//**
The following function rounds down a pointer to the nearest
aligned address.
@return	aligned pointer */
UNIV_INLINE
void*
ut_align_down(
/*==========*/
	const void*	ptr,		/*!< in: pointer */
	ulint		align_no)	/*!< in: align by this number */
		__attribute__((const));
/*********************************************************//**
The following function computes the offset of a pointer from the nearest
aligned address.
@return	distance from aligned pointer */
UNIV_INLINE
ulint
ut_align_offset(
/*============*/
	const void*	ptr,		/*!< in: pointer */
	ulint		align_no)	/*!< in: align by this number */
			__attribute__((const));
/*****************************************************************//**
Gets the nth bit of a ulint.
@return	TRUE if nth bit is 1; 0th bit is defined to be the least significant */
UNIV_INLINE
ibool
ut_bit_get_nth(
/*===========*/
	ulint	a,	/*!< in: ulint */
	ulint	n);	/*!< in: nth bit requested */
/*****************************************************************//**
Sets the nth bit of a ulint.
@return	the ulint with the bit set as requested */
UNIV_INLINE
ulint
ut_bit_set_nth(
/*===========*/
	ulint	a,	/*!< in: ulint */
	ulint	n,	/*!< in: nth bit requested */
	ibool	val);	/*!< in: value for the bit to set */

#ifndef UNIV_NONINL
#include "ut0byte.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*****************************************************************//**
@file include/ut0dbg.h
Debug utilities for Innobase

Created 1/30/1994 Heikki Tuuri
**********************************************************************/

#ifndef ut0dbg_h
#define ut0dbg_h

#include "univ.i"
#include <stdlib.h>
#include "os0thread.h"

#if defined(__GNUC__) && (__GNUC__ > 2)
/** Test if an assertion fails.
@param EXPR	assertion expression
@return		nonzero if EXPR holds, zero if not */
# define UT_DBG_FAIL(EXPR) UNIV_UNLIKELY(!((ulint)(EXPR)))
#else
/** This is used to eliminate compiler warnings */
extern ulint	ut_dbg_zero;
/** Test if an assertion fails.
@param EXPR	assertion expression
@return		nonzero if EXPR holds, zero if not */
# define UT_DBG_FAIL(EXPR) !((ulint)(EXPR) + ut_dbg_zero)
#endif

#if __STDC_VERSION__ < 199901L
# if __GNUC__ >= 2
#  define __func__ __FUNCTION__
# else
#  define __func__ "<unknown>"
# endif
#endif

#define UT_DBG_PRINT_FUNC	printf("%s\n", __func__)

/* you must #define UT_DBG_ENTER_FUNC_ENABLED to something before
using this macro */
#define UT_DBG_ENTER_FUNC				\
	do {						\
		if (UT_DBG_ENTER_FUNC_ENABLED) {	\
			UT_DBG_PRINT_FUNC;		\
		}					\
	} while (0)

/*************************************************************//**
Report a failed assertion. */
UNIV_INTERN
void
ut_dbg_assertion_failed(
/*====================*/
	const char* expr,	/*!< in: the failed assertion */
	const char* file,	/*!< in: source file containing the assertion */
	ulint line);		/*!< in: line number of the assertion */

#ifdef __NETWARE__
/** Flag for ignoring further assertion failures.  This is set to TRUE
when on NetWare there happens an InnoDB assertion failure or other
fatal error condition that requires an immediate shutdown. */
extern ibool	panic_shutdown;
/* Abort the execution. */
void ut_dbg_panic(void);
# define UT_DBG_PANIC ut_dbg_panic()
/* Stop threads in ut_a(). */
# define UT_DBG_STOP	do {} while (0)	/* We do not do this on NetWare */
#else /* __NETWARE__ */
# if defined(__WIN__) || defined(__INTEL_COMPILER)
#  undef UT_DBG_USE_ABORT
# elif defined(__GNUC__) && (__GNUC__ > 2)
#  define UT_DBG_USE_ABORT
# endif

# ifndef UT_DBG_USE_ABORT
/** A null pointer that will be dereferenced to trigger a memory trap */
extern ulint*	ut_dbg_null_ptr;
# endif

# if defined(UNIV_SYNC_DEBUG) || !defined(UT_DBG_USE_ABORT)
/** If this is set to TRUE by ut_dbg_assertion_failed(), all threads
will stop at the next ut_a() or ut_ad(). */
extern ibool	ut_dbg_stop_threads;

/*************************************************************//**
Stop a thread after assertion failure. */
UNIV_INTERN
void
ut_dbg_stop_thread(
/*===============*/
	const char*	file,
	ulint		line);
# endif

# ifdef UT_DBG_USE_ABORT
/** Abort the execution. */
#  define UT_DBG_PANIC abort()
/** Stop threads (null operation) */
#  define UT_DBG_STOP do {} while (0)
# else /* UT_DBG_USE_ABORT */
/** Abort the execution. */
#  define UT_DBG_PANIC					\
	if (*(ut_dbg_null_ptr)) ut_dbg_null_ptr = NULL
/** Stop threads in ut_a(). */
#  define UT_DBG_STOP do						\
	if (UNIV_UNLIKELY(ut_dbg_stop_threads)) {		\
		ut_dbg_stop_thread(__FILE__, (ulint) __LINE__);	\
	} while (0)
# endif /* UT_DBG_USE_ABORT */
#endif /* __NETWARE__ */

/** Abort execution if EXPR does not evaluate to nonzero.
@param EXPR	assertion expression that should hold */
#define ut_a(EXPR) do {						\
	if (UT_DBG_FAIL(EXPR)) {				\
		ut_dbg_assertion_failed(#EXPR,			\
				__FILE__, (ulint) __LINE__);	\
		UT_DBG_PANIC;					\
	}							\
	UT_DBG_STOP;						\
} while (0)

/** Abort execution. */
#define ut_error do {						\
	ut_dbg_assertion_failed(0, __FILE__, (ulint) __LINE__);	\
	UT_DBG_PANIC;						\
} while (0)

#ifdef UNIV_DEBUG
/** Debug assertion. Does nothing unless UNIV_DEBUG is defined. */
#define ut_ad(EXPR)	ut_a(EXPR)
/** Debug statement. Does nothing unless UNIV_DEBUG is defined. */
#define ut_d(EXPR)	do {EXPR;} while (0)
#else
/** Debug assertion. Does nothing unless UNIV_DEBUG is defined. */
#define ut_ad(EXPR)
/** Debug statement. Does nothing unless UNIV_DEBUG is defined. */
#define ut_d(EXPR)
#endif

/** Silence warnings about an unused variable by doing a null assignment.
@param A	the unused variable */
#define UT_NOT_USED(A)	A = A

#ifdef UNIV_COMPILE_TEST_FUNCS

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>

/** structure used for recording usage statistics */
typedef struct speedo_struct {
	struct rusage	ru;	/*!< getrusage() result */
	struct timeval	tv;	/*!< gettimeofday() result */
} speedo_t;

/*******************************************************************//**
Resets a speedo (records the current time in it). */
UNIV_INTERN
void
speedo_reset(
/*=========*/
	speedo_t*	speedo);	/*!< out: speedo */

/*******************************************************************//**
Shows the time elapsed and usage statistics since the last reset of a
speedo. */
UNIV_INTERN
void
speedo_show(
/*========*/
	const speedo_t*	speedo);	/*!< in: speedo */

#endif /* UNIV_COMPILE_TEST_FUNCS */

#endif
/*****************************************************************************

Copyright (c) 2006, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file include/ut0list.h
A double-linked list

Created 4/26/2006 Osku Salerma
************************************************************************/

/*******************************************************************//**
A double-linked list. This differs from the one in ut0lst.h in that in this
one, each list node contains a pointer to the data, whereas the one in
ut0lst.h uses a strategy where the list pointers are embedded in the data
items themselves.

Use this one when you need to store arbitrary data in the list where you
can't embed the list pointers in the data, if a data item needs to be
stored in multiple lists, etc.

Note about the memory management: ib_list_t is a fixed-size struct whose
allocation/deallocation is done through ib_list_create/ib_list_free, but the
memory for the list nodes is allocated through a user-given memory heap,
which can either be the same for all nodes or vary per node. Most users will
probably want to create a memory heap to store the item-specific data, and
pass in this same heap to the list node creation functions, thus
automatically freeing the list node when the item's heap is freed.

************************************************************************/

#ifndef IB_LIST_H
#define IB_LIST_H

#include "mem0mem.h"

typedef struct ib_list_struct ib_list_t;
typedef struct ib_list_node_struct ib_list_node_t;
typedef struct ib_list_helper_struct ib_list_helper_t;

/****************************************************************//**
Create a new list using mem_alloc. Lists created with this function must be
freed with ib_list_free.
@return	list */
UNIV_INTERN
ib_list_t*
ib_list_create(void);
/*=================*/


/****************************************************************//**
Free a list. */
UNIV_INTERN
void
ib_list_free(
/*=========*/
	ib_list_t*	list);	/*!< in: list */

/****************************************************************//**
Add the data to the end of the list.
@return	new list node */
UNIV_INTERN
ib_list_node_t*
ib_list_add_last(
/*=============*/
	ib_list_t*	list,	/*!< in: list */
	void*		data,	/*!< in: data */
	mem_heap_t*	heap);	/*!< in: memory heap to use */

/****************************************************************//**
Add the data after the indicated node.
@return	new list node */
UNIV_INTERN
ib_list_node_t*
ib_list_add_after(
/*==============*/
	ib_list_t*	list,		/*!< in: list */
	ib_list_node_t*	prev_node,	/*!< in: node preceding new node (can
					be NULL) */
	void*		data,		/*!< in: data */
	mem_heap_t*	heap);		/*!< in: memory heap to use */

/****************************************************************//**
Remove the node from the list. */
UNIV_INTERN
void
ib_list_remove(
/*===========*/
	ib_list_t*	list,	/*!< in: list */
	ib_list_node_t*	node);	/*!< in: node to remove */

/****************************************************************//**
Get the first node in the list.
@return	first node, or NULL */
UNIV_INLINE
ib_list_node_t*
ib_list_get_first(
/*==============*/
	ib_list_t*	list);	/*!< in: list */

/****************************************************************//**
Get the last node in the list.
@return	last node, or NULL */
UNIV_INLINE
ib_list_node_t*
ib_list_get_last(
/*=============*/
	ib_list_t*	list);	/*!< in: list */

/* List. */
struct ib_list_struct {
	ib_list_node_t*		first;		/*!< first node */
	ib_list_node_t*		last;		/*!< last node */
	ibool			is_heap_list;	/*!< TRUE if this list was
						allocated through a heap */
};

/* A list node. */
struct ib_list_node_struct {
	ib_list_node_t*		prev;		/*!< previous node */
	ib_list_node_t*		next;		/*!< next node */
	void*			data;		/*!< user data */
};

/* Quite often, the only additional piece of data you need is the per-item
memory heap, so we have this generic struct available to use in those
cases. */
struct ib_list_helper_struct {
	mem_heap_t*	heap;		/*!< memory heap */
	void*		data;		/*!< user data */
};

#ifndef UNIV_NONINL
#include "ut0list.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/ut0lst.h
List utilities

Created 9/10/1995 Heikki Tuuri
***********************************************************************/

#ifndef ut0lst_h
#define ut0lst_h

#include "univ.i"

/* This module implements the two-way linear list which should be used
if a list is used in the database. Note that a single struct may belong
to two or more lists, provided that the list are given different names.
An example of the usage of the lists can be found in fil0fil.c. */

/*******************************************************************//**
This macro expands to the unnamed type definition of a struct which acts
as the two-way list base node. The base node contains pointers
to both ends of the list and a count of nodes in the list (excluding
the base node from the count).
@param TYPE	the name of the list node data type */
#define UT_LIST_BASE_NODE_T(TYPE)\
struct {\
	ulint	count;	/*!< count of nodes in list */\
	TYPE *	start;	/*!< pointer to list start, NULL if empty */\
	TYPE *	end;	/*!< pointer to list end, NULL if empty */\
}\

/*******************************************************************//**
This macro expands to the unnamed type definition of a struct which
should be embedded in the nodes of the list, the node type must be a struct.
This struct contains the pointers to next and previous nodes in the list.
The name of the field in the node struct should be the name given
to the list.
@param TYPE	the list node type name */
/* Example:
typedef struct LRU_node_struct	LRU_node_t;
struct LRU_node_struct {
	UT_LIST_NODE_T(LRU_node_t)	LRU_list;
	...
}
The example implements an LRU list of name LRU_list. Its nodes are of type
LRU_node_t. */

#define UT_LIST_NODE_T(TYPE)\
struct {\
	TYPE *	prev;	/*!< pointer to the previous node,\
			NULL if start of list */\
	TYPE *	next;	/*!< pointer to next node, NULL if end of list */\
}\

/*******************************************************************//**
Initializes the base node of a two-way list.
@param BASE	the list base node
*/
#define UT_LIST_INIT(BASE)\
{\
	(BASE).count = 0;\
	(BASE).start = NULL;\
	(BASE).end   = NULL;\
}\

/*******************************************************************//**
Adds the node as the first element in a two-way linked list.
@param NAME	list name
@param BASE	the base node (not a pointer to it)
@param N	pointer to the node to be added to the list.
*/
#define UT_LIST_ADD_FIRST(NAME, BASE, N)\
{\
	ut_ad(N);\
	((BASE).count)++;\
	((N)->NAME).next = (BASE).start;\
	((N)->NAME).prev = NULL;\
	if (UNIV_LIKELY((BASE).start != NULL)) {\
		ut_ad((BASE).start != (N));\
		(((BASE).start)->NAME).prev = (N);\
	}\
	(BASE).start = (N);\
	if (UNIV_UNLIKELY((BASE).end == NULL)) {\
		(BASE).end = (N);\
	}\
}\

/*******************************************************************//**
Adds the node as the last element in a two-way linked list.
@param NAME	list name
@param BASE	the base node (not a pointer to it)
@param N	pointer to the node to be added to the list
*/
#define UT_LIST_ADD_LAST(NAME, BASE, N)\
{\
	ut_ad(N);\
	((BASE).count)++;\
	((N)->NAME).prev = (BASE).end;\
	((N)->NAME).next = NULL;\
	if ((BASE).end != NULL) {\
		ut_ad((BASE).end != (N));\
		(((BASE).end)->NAME).next = (N);\
	}\
	(BASE).end = (N);\
	if ((BASE).start == NULL) {\
		(BASE).start = (N);\
	}\
}\

/*******************************************************************//**
Inserts a NODE2 after NODE1 in a list.
@param NAME	list name
@param BASE	the base node (not a pointer to it)
@param NODE1	pointer to node after which NODE2 is inserted
@param NODE2	pointer to node being inserted after NODE1
*/
#define UT_LIST_INSERT_AFTER(NAME, BASE, NODE1, NODE2)\
{\
	ut_ad(NODE1);\
	ut_ad(NODE2);\
	ut_ad((NODE1) != (NODE2));\
	((BASE).count)++;\
	((NODE2)->NAME).prev = (NODE1);\
	((NODE2)->NAME).next = ((NODE1)->NAME).next;\
	if (((NODE1)->NAME).next != NULL) {\
		((((NODE1)->NAME).next)->NAME).prev = (NODE2);\
	}\
	((NODE1)->NAME).next = (NODE2);\
	if ((BASE).end == (NODE1)) {\
		(BASE).end = (NODE2);\
	}\
}\

#ifdef UNIV_LIST_DEBUG
/** Invalidate the pointers in a list node.
@param NAME	list name
@param N	pointer to the node that was removed */
# define UT_LIST_REMOVE_CLEAR(NAME, N)		\
((N)->NAME.prev = (N)->NAME.next = (void*) -1)
#else
/** Invalidate the pointers in a list node.
@param NAME	list name
@param N	pointer to the node that was removed */
# define UT_LIST_REMOVE_CLEAR(NAME, N) while (0)
#endif

/*******************************************************************//**
Removes a node from a two-way linked list.
@param NAME	list name
@param BASE	the base node (not a pointer to it)
@param N	pointer to the node to be removed from the list
*/
#define UT_LIST_REMOVE(NAME, BASE, N)					\
do {									\
	ut_ad(N);							\
	ut_a((BASE).count > 0);						\
	((BASE).count)--;						\
	if (((N)->NAME).next != NULL) {					\
		((((N)->NAME).next)->NAME).prev = ((N)->NAME).prev;	\
	} else {							\
		(BASE).end = ((N)->NAME).prev;				\
	}								\
	if (((N)->NAME).prev != NULL) {					\
		((((N)->NAME).prev)->NAME).next = ((N)->NAME).next;	\
	} else {							\
		(BASE).start = ((N)->NAME).next;			\
	}								\
	UT_LIST_REMOVE_CLEAR(NAME, N);					\
} while (0)

/********************************************************************//**
Gets the next node in a two-way list.
@param NAME	list name
@param N	pointer to a node
@return		the successor of N in NAME, or NULL */
#define UT_LIST_GET_NEXT(NAME, N)\
	(((N)->NAME).next)

/********************************************************************//**
Gets the previous node in a two-way list.
@param NAME	list name
@param N	pointer to a node
@return		the predecessor of N in NAME, or NULL */
#define UT_LIST_GET_PREV(NAME, N)\
	(((N)->NAME).prev)

/********************************************************************//**
Alternative macro to get the number of nodes in a two-way list, i.e.,
its length.
@param BASE	the base node (not a pointer to it).
@return		the number of nodes in the list */
#define UT_LIST_GET_LEN(BASE)\
	(BASE).count

/********************************************************************//**
Gets the first node in a two-way list.
@param BASE	the base node (not a pointer to it)
@return		first node, or NULL if the list is empty */
#define UT_LIST_GET_FIRST(BASE)\
	(BASE).start

/********************************************************************//**
Gets the last node in a two-way list.
@param BASE	the base node (not a pointer to it)
@return		last node, or NULL if the list is empty */
#define UT_LIST_GET_LAST(BASE)\
	(BASE).end

/********************************************************************//**
Checks the consistency of a two-way list.
@param NAME		the name of the list
@param TYPE		node type
@param BASE		base node (not a pointer to it)
@param ASSERTION	a condition on ut_list_node_313 */
#define UT_LIST_VALIDATE(NAME, TYPE, BASE, ASSERTION)			\
do {									\
	ulint	ut_list_i_313;						\
	TYPE*	ut_list_node_313;					\
									\
	ut_list_node_313 = (BASE).start;				\
									\
	for (ut_list_i_313 = (BASE).count; ut_list_i_313--; ) {		\
		ut_a(ut_list_node_313);					\
		ASSERTION;						\
		ut_ad((ut_list_node_313->NAME).next || !ut_list_i_313);	\
		ut_list_node_313 = (ut_list_node_313->NAME).next;	\
	}								\
									\
	ut_a(ut_list_node_313 == NULL);					\
									\
	ut_list_node_313 = (BASE).end;					\
									\
	for (ut_list_i_313 = (BASE).count; ut_list_i_313--; ) {		\
		ut_a(ut_list_node_313);					\
		ASSERTION;						\
		ut_ad((ut_list_node_313->NAME).prev || !ut_list_i_313);	\
		ut_list_node_313 = (ut_list_node_313->NAME).prev;	\
	}								\
									\
	ut_a(ut_list_node_313 == NULL);					\
} while (0)

#endif

/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file include/ut0mem.h
Memory primitives

Created 5/30/1994 Heikki Tuuri
************************************************************************/

#ifndef ut0mem_h
#define ut0mem_h

#include "univ.i"
#include <string.h>
#ifndef UNIV_HOTBACKUP
# include "os0sync.h"

/** The total amount of memory currently allocated from the operating
system with os_mem_alloc_large() or malloc().  Does not count malloc()
if srv_use_sys_malloc is set.  Protected by ut_list_mutex. */
extern ulint		ut_total_allocated_memory;

/** Mutex protecting ut_total_allocated_memory and ut_mem_block_list */
extern os_fast_mutex_t	ut_list_mutex;
#endif /* !UNIV_HOTBACKUP */

/** Wrapper for memcpy(3).  Copy memory area when the source and
target are not overlapping.
* @param dest	in: copy to
* @param sour	in: copy from
* @param n	in: number of bytes to copy
* @return	dest */
UNIV_INLINE
void*
ut_memcpy(void* dest, const void* sour, ulint n);

/** Wrapper for memmove(3).  Copy memory area when the source and
target are overlapping.
* @param dest	in: copy to
* @param sour	in: copy from
* @param n	in: number of bytes to copy
* @return	dest */
UNIV_INLINE
void*
ut_memmove(void* dest, const void* sour, ulint n);

/** Wrapper for memcmp(3).  Compare memory areas.
* @param str1	in: first memory block to compare
* @param str2	in: second memory block to compare
* @param n	in: number of bytes to compare
* @return	negative, 0, or positive if str1 is smaller, equal,
		or greater than str2, respectively. */
UNIV_INLINE
int
ut_memcmp(const void* str1, const void* str2, ulint n);

/**********************************************************************//**
Initializes the mem block list at database startup. */
UNIV_INTERN
void
ut_mem_init(void);
/*=============*/

/**********************************************************************//**
Allocates memory. Sets it also to zero if UNIV_SET_MEM_TO_ZERO is
defined and set_to_zero is TRUE.
@return	own: allocated memory */
UNIV_INTERN
void*
ut_malloc_low(
/*==========*/
	ulint	n,			/*!< in: number of bytes to allocate */
	ibool	set_to_zero,		/*!< in: TRUE if allocated memory
					should be set to zero if
					UNIV_SET_MEM_TO_ZERO is defined */
	ibool	assert_on_error);	/*!< in: if TRUE, we crash the
					engine if the memory cannot be
					allocated */
/**********************************************************************//**
Allocates memory. Sets it also to zero if UNIV_SET_MEM_TO_ZERO is
defined.
@return	own: allocated memory */
UNIV_INTERN
void*
ut_malloc(
/*======*/
	ulint	n);	/*!< in: number of bytes to allocate */
#ifndef UNIV_HOTBACKUP
/**********************************************************************//**
Tests if malloc of n bytes would succeed. ut_malloc() asserts if memory runs
out. It cannot be used if we want to return an error message. Prints to
stderr a message if fails.
@return	TRUE if succeeded */
UNIV_INTERN
ibool
ut_test_malloc(
/*===========*/
	ulint	n);	/*!< in: try to allocate this many bytes */
#endif /* !UNIV_HOTBACKUP */
/**********************************************************************//**
Frees a memory block allocated with ut_malloc. */
UNIV_INTERN
void
ut_free(
/*====*/
	void* ptr);  /*!< in, own: memory block */
#ifndef UNIV_HOTBACKUP
/**********************************************************************//**
Implements realloc. This is needed by /pars/lexyy.c. Otherwise, you should not
use this function because the allocation functions in mem0mem.h are the
recommended ones in InnoDB.

man realloc in Linux, 2004:

       realloc()  changes the size of the memory block pointed to
       by ptr to size bytes.  The contents will be  unchanged  to
       the minimum of the old and new sizes; newly allocated mem­
       ory will be uninitialized.  If ptr is NULL,  the	 call  is
       equivalent  to malloc(size); if size is equal to zero, the
       call is equivalent to free(ptr).	 Unless ptr is	NULL,  it
       must  have  been	 returned by an earlier call to malloc(),
       calloc() or realloc().

RETURN VALUE
       realloc() returns a pointer to the newly allocated memory,
       which is suitably aligned for any kind of variable and may
       be different from ptr, or NULL if the  request  fails.  If
       size  was equal to 0, either NULL or a pointer suitable to
       be passed to free() is returned.	 If realloc()  fails  the
       original	 block	is  left  untouched  - it is not freed or
       moved.
@return	own: pointer to new mem block or NULL */
UNIV_INTERN
void*
ut_realloc(
/*=======*/
	void*	ptr,	/*!< in: pointer to old block or NULL */
	ulint	size);	/*!< in: desired size */
/**********************************************************************//**
Frees in shutdown all allocated memory not freed yet. */
UNIV_INTERN
void
ut_free_all_mem(void);
/*=================*/
#endif /* !UNIV_HOTBACKUP */

/** Wrapper for strcpy(3).  Copy a NUL-terminated string.
* @param dest	in: copy to
* @param sour	in: copy from
* @return	dest */
UNIV_INLINE
char*
ut_strcpy(char* dest, const char* sour);

/** Wrapper for strlen(3).  Determine the length of a NUL-terminated string.
* @param str	in: string
* @return	length of the string in bytes, excluding the terminating NUL */
UNIV_INLINE
ulint
ut_strlen(const char* str);

/** Wrapper for strcmp(3).  Compare NUL-terminated strings.
* @param str1	in: first string to compare
* @param str2	in: second string to compare
* @return	negative, 0, or positive if str1 is smaller, equal,
		or greater than str2, respectively. */
UNIV_INLINE
int
ut_strcmp(const char* str1, const char* str2);

/**********************************************************************//**
Copies up to size - 1 characters from the NUL-terminated string src to
dst, NUL-terminating the result. Returns strlen(src), so truncation
occurred if the return value >= size.
@return	strlen(src) */
UNIV_INTERN
ulint
ut_strlcpy(
/*=======*/
	char*		dst,	/*!< in: destination buffer */
	const char*	src,	/*!< in: source buffer */
	ulint		size);	/*!< in: size of destination buffer */

/**********************************************************************//**
Like ut_strlcpy, but if src doesn't fit in dst completely, copies the last
(size - 1) bytes of src, not the first.
@return	strlen(src) */
UNIV_INTERN
ulint
ut_strlcpy_rev(
/*===========*/
	char*		dst,	/*!< in: destination buffer */
	const char*	src,	/*!< in: source buffer */
	ulint		size);	/*!< in: size of destination buffer */

/**********************************************************************//**
Compute strlen(ut_strcpyq(str, q)).
@return	length of the string when quoted */
UNIV_INLINE
ulint
ut_strlenq(
/*=======*/
	const char*	str,	/*!< in: null-terminated string */
	char		q);	/*!< in: the quote character */

/**********************************************************************//**
Make a quoted copy of a NUL-terminated string.	Leading and trailing
quotes will not be included; only embedded quotes will be escaped.
See also ut_strlenq() and ut_memcpyq().
@return	pointer to end of dest */
UNIV_INTERN
char*
ut_strcpyq(
/*=======*/
	char*		dest,	/*!< in: output buffer */
	char		q,	/*!< in: the quote character */
	const char*	src);	/*!< in: null-terminated string */

/**********************************************************************//**
Make a quoted copy of a fixed-length string.  Leading and trailing
quotes will not be included; only embedded quotes will be escaped.
See also ut_strlenq() and ut_strcpyq().
@return	pointer to end of dest */
UNIV_INTERN
char*
ut_memcpyq(
/*=======*/
	char*		dest,	/*!< in: output buffer */
	char		q,	/*!< in: the quote character */
	const char*	src,	/*!< in: string to be quoted */
	ulint		len);	/*!< in: length of src */

/**********************************************************************//**
Return the number of times s2 occurs in s1. Overlapping instances of s2
are only counted once.
@return	the number of times s2 occurs in s1 */
UNIV_INTERN
ulint
ut_strcount(
/*========*/
	const char*	s1,	/*!< in: string to search in */
	const char*	s2);	/*!< in: string to search for */

/**********************************************************************//**
Replace every occurrence of s1 in str with s2. Overlapping instances of s1
are only replaced once.
@return	own: modified string, must be freed with mem_free() */
UNIV_INTERN
char*
ut_strreplace(
/*==========*/
	const char*	str,	/*!< in: string to operate on */
	const char*	s1,	/*!< in: string to replace */
	const char*	s2);	/*!< in: string to replace s1 with */

/**********************************************************************//**
Converts a raw binary data to a NUL-terminated hex string. The output is
truncated if there is not enough space in "hex", make sure "hex_size" is at
least (2 * raw_size + 1) if you do not want this to happen. Returns the
actual number of characters written to "hex" (including the NUL).
@return	number of chars written */
UNIV_INLINE
ulint
ut_raw_to_hex(
/*==========*/
	const void*	raw,		/*!< in: raw data */
	ulint		raw_size,	/*!< in: "raw" length in bytes */
	char*		hex,		/*!< out: hex string */
	ulint		hex_size);	/*!< in: "hex" size in bytes */

/*******************************************************************//**
Adds single quotes to the start and end of string and escapes any quotes
by doubling them. Returns the number of bytes that were written to "buf"
(including the terminating NUL). If buf_size is too small then the
trailing bytes from "str" are discarded.
@return	number of bytes that were written */
UNIV_INLINE
ulint
ut_str_sql_format(
/*==============*/
	const char*	str,		/*!< in: string */
	ulint		str_len,	/*!< in: string length in bytes */
	char*		buf,		/*!< out: output buffer */
	ulint		buf_size);	/*!< in: output buffer size
					in bytes */
/**************************************************************************
Reset the variables. */
UNIV_INTERN
void
ut_mem_var_init(void);
/*=================*/

#ifndef UNIV_NONINL
#include "ut0mem.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/ut0rnd.h
Random numbers and hashing

Created 1/20/1994 Heikki Tuuri
***********************************************************************/

#ifndef ut0rnd_h
#define ut0rnd_h

#include "univ.i"

#include "ut0byte.h"

/** The 'character code' for end of field or string (used
in folding records */
#define UT_END_OF_FIELD		257

/********************************************************//**
This is used to set the random number seed. */
UNIV_INLINE
void
ut_rnd_set_seed(
/*============*/
	ulint	 seed);		 /*!< in: seed */
/********************************************************//**
The following function generates a series of 'random' ulint integers.
@return	the next 'random' number */
UNIV_INLINE
ulint
ut_rnd_gen_next_ulint(
/*==================*/
	ulint	rnd);	/*!< in: the previous random number value */
/*********************************************************//**
The following function generates 'random' ulint integers which
enumerate the value space (let there be N of them) of ulint integers
in a pseudo-random fashion. Note that the same integer is repeated
always after N calls to the generator.
@return	the 'random' number */
UNIV_INLINE
ulint
ut_rnd_gen_ulint(void);
/*==================*/
/********************************************************//**
Generates a random integer from a given interval.
@return	the 'random' number */
UNIV_INLINE
ulint
ut_rnd_interval(
/*============*/
	ulint	low,	/*!< in: low limit; can generate also this value */
	ulint	high);	/*!< in: high limit; can generate also this value */
/*********************************************************//**
Generates a random iboolean value.
@return	the random value */
UNIV_INLINE
ibool
ut_rnd_gen_ibool(void);
/*=================*/
/*******************************************************//**
The following function generates a hash value for a ulint integer
to a hash table of size table_size, which should be a prime or some
random number to work reliably.
@return	hash value */
UNIV_INLINE
ulint
ut_hash_ulint(
/*==========*/
	ulint	 key,		/*!< in: value to be hashed */
	ulint	 table_size);	/*!< in: hash table size */
/*************************************************************//**
Folds a pair of ulints.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_ulint_pair(
/*===============*/
	ulint	n1,	/*!< in: ulint */
	ulint	n2)	/*!< in: ulint */
	__attribute__((const));
/*************************************************************//**
Folds a dulint.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_dulint(
/*===========*/
	dulint	d)	/*!< in: dulint */
	__attribute__((const));
/*************************************************************//**
Folds a character string ending in the null character.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_string(
/*===========*/
	const char*	str)	/*!< in: null-terminated string */
	__attribute__((pure));
/*************************************************************//**
Folds a binary string.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_binary(
/*===========*/
	const byte*	str,	/*!< in: string of bytes */
	ulint		len)	/*!< in: length */
	__attribute__((pure));
/***********************************************************//**
Looks for a prime number slightly greater than the given argument.
The prime is chosen so that it is not near any power of 2.
@return	prime */
UNIV_INTERN
ulint
ut_find_prime(
/*==========*/
	ulint	n)	/*!< in: positive number > 100 */
	__attribute__((const));


#ifndef UNIV_NONINL
#include "ut0rnd.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/ut0sort.h
Sort utility

Created 11/9/1995 Heikki Tuuri
***********************************************************************/

#ifndef ut0sort_h
#define ut0sort_h

#include "univ.i"

/* This module gives a macro definition of the body of
a standard sort function for an array of elements of any
type. The comparison function is given as a parameter to
the macro. The sort algorithm is mergesort which has logarithmic
worst case.
*/

/*******************************************************************//**
This macro expands to the body of a standard sort function.
The sort function uses mergesort and must be defined separately
for each type of array.
Also the comparison function has to be defined individually
for each array cell type. SORT_FUN is the sort function name.
The function takes the array to be sorted (ARR),
the array of auxiliary space (AUX_ARR) of same size,
and the low (LOW), inclusive, and high (HIGH), noninclusive,
limits for the sort interval as arguments.
CMP_FUN is the comparison function name. It takes as arguments
two elements from the array and returns 1, if the first is bigger,
0 if equal, and -1 if the second bigger. */

#define UT_SORT_FUNCTION_BODY(\
	CMP_CTX, SORT_FUN, ARR, AUX_ARR, LOW, HIGH, CMP_FUN)\
{\
	ulint		ut_sort_mid77;\
	ulint		ut_sort_i77;\
	ulint		ut_sort_low77;\
	ulint		ut_sort_high77;\
\
	ut_ad((LOW) < (HIGH));\
	ut_ad(ARR);\
	ut_ad(AUX_ARR);\
\
	if ((LOW) == (HIGH) - 1) {\
		return;\
	} else if ((LOW) == (HIGH) - 2) {\
		if (CMP_FUN((CMP_CTX),(ARR)[LOW], (ARR)[(HIGH) - 1]) > 0) {\
			(AUX_ARR)[LOW] = (ARR)[LOW];\
			(ARR)[LOW] = (ARR)[(HIGH) - 1];\
			(ARR)[(HIGH) - 1] = (AUX_ARR)[LOW];\
		}\
		return;\
	}\
\
	ut_sort_mid77 = ((LOW) + (HIGH)) / 2;\
\
	SORT_FUN((CMP_CTX), (ARR), (AUX_ARR), (LOW), ut_sort_mid77);\
	SORT_FUN((CMP_CTX), (ARR), (AUX_ARR), ut_sort_mid77, (HIGH));\
\
	ut_sort_low77 = (LOW);\
	ut_sort_high77 = ut_sort_mid77;\
\
	for (ut_sort_i77 = (LOW); ut_sort_i77 < (HIGH); ut_sort_i77++) {\
\
		if (ut_sort_low77 >= ut_sort_mid77) {\
			(AUX_ARR)[ut_sort_i77] = (ARR)[ut_sort_high77];\
			ut_sort_high77++;\
		} else if (ut_sort_high77 >= (HIGH)) {\
			(AUX_ARR)[ut_sort_i77] = (ARR)[ut_sort_low77];\
			ut_sort_low77++;\
		} else if (CMP_FUN((CMP_CTX),(ARR)[ut_sort_low77],\
				   (ARR)[ut_sort_high77]) > 0) {\
			(AUX_ARR)[ut_sort_i77] = (ARR)[ut_sort_high77];\
			ut_sort_high77++;\
		} else {\
			(AUX_ARR)[ut_sort_i77] = (ARR)[ut_sort_low77];\
			ut_sort_low77++;\
		}\
	}\
\
	memcpy((void*) ((ARR) + (LOW)), (AUX_ARR) + (LOW),\
	       ((HIGH) - (LOW)) * sizeof *(ARR));\
}\


#endif

/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.
Copyright (c) 2009, Sun Microsystems, Inc.

Portions of this file contain modifications contributed and copyrighted by
Sun Microsystems, Inc. Those modifications are gratefully acknowledged and
are described briefly in the InnoDB documentation. The contributions by
Sun Microsystems are incorporated with their permission, and subject to the
conditions contained in the file COPYING.Sun_Microsystems.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/ut0ut.h
Various utilities

Created 1/20/1994 Heikki Tuuri
***********************************************************************/

#ifndef ut0ut_h
#define ut0ut_h

#include "univ.i"

#ifndef UNIV_HOTBACKUP
# include "os0sync.h" /* for HAVE_ATOMIC_BUILTINS */
#endif /* UNIV_HOTBACKUP */

#include <time.h>
#include <ctype.h>

/** Index name prefix in fast index creation */
#define	TEMP_INDEX_PREFIX	'\377'
/** Index name prefix in fast index creation, as a string constant */
#define TEMP_INDEX_PREFIX_STR	"\377"

/** Time stamp */
typedef time_t	ib_time_t;

/* The first argument to the InnoDB error logging function. */
typedef void* ib_stream_t;

/************************************************************************//**
All log messages are written to this function. It should have the same
behavior as fprintf(). */
typedef int (*ib_logger_t)(ib_stream_t, const char*, ...);

#ifndef UNIV_HOTBACKUP
#if defined(HAVE_IB_PAUSE_INSTRUCTION)
#  ifdef WIN32
     /* In the Win32 API, the x86 PAUSE instruction is executed by calling
     the YieldProcessor macro defined in WinNT.h. It is a CPU architecture-
     independent way by using YieldProcessor.*/
#    define UT_RELAX_CPU() YieldProcessor()
#  else
     /* According to the gcc info page, asm volatile means that the
     instruction has important side-effects and must not be removed.
     Also asm volatile may trigger a memory barrier (spilling all registers
     to memory). */
#    define UT_RELAX_CPU() __asm__ __volatile__ ("pause")
#  endif
#elif defined(HAVE_SOLARIS_ATOMICS)
#  define UT_RELAX_CPU() do { \
     volatile lint	volatile_var; \
     os_compare_and_swap_lint(&volatile_var, 0, 1); \
   } while (0)
#else
#  define UT_RELAX_CPU() ((void)0) /* avoid warning for an empty statement */
#endif

/*********************************************************************//**
Delays execution for at most max_wait_us microseconds or returns earlier
if cond becomes true.
@param cond		in: condition to wait for; evaluated every 2 ms
@param max_wait_us	in: maximum delay to wait, in microseconds */
#define UT_WAIT_FOR(cond, max_wait_us)				\
do {								\
	ib_uint64_t	start_us;				\
	start_us = ut_time_us(NULL);				\
	while (!(cond) 						\
	       && ut_time_us(NULL) - start_us < (max_wait_us)) {\
								\
		os_thread_sleep(2000 /* 2 ms */);		\
	}							\
} while (0)
#endif /* !UNIV_HOTBACKUP */

/********************************************************//**
Gets the high 32 bits in a ulint. That is makes a shift >> 32,
but since there seem to be compiler bugs in both gcc and Visual C++,
we do this by a special conversion.
@return	a >> 32 */
UNIV_INTERN
ulint
ut_get_high32(
/*==========*/
	ulint	a);	/*!< in: ulint */
/******************************************************//**
Calculates the minimum of two ulints.
@return	minimum */
UNIV_INLINE
ulint
ut_min(
/*===*/
	ulint	 n1,	/*!< in: first number */
	ulint	 n2);	/*!< in: second number */
/******************************************************//**
Calculates the maximum of two ulints.
@return	maximum */
UNIV_INLINE
ulint
ut_max(
/*===*/
	ulint	 n1,	/*!< in: first number */
	ulint	 n2);	/*!< in: second number */
/****************************************************************//**
Calculates minimum of two ulint-pairs. */
UNIV_INLINE
void
ut_pair_min(
/*========*/
	ulint*	a,	/*!< out: more significant part of minimum */
	ulint*	b,	/*!< out: less significant part of minimum */
	ulint	a1,	/*!< in: more significant part of first pair */
	ulint	b1,	/*!< in: less significant part of first pair */
	ulint	a2,	/*!< in: more significant part of second pair */
	ulint	b2);	/*!< in: less significant part of second pair */
/******************************************************//**
Compares two ulints.
@return	1 if a > b, 0 if a == b, -1 if a < b */
UNIV_INLINE
int
ut_ulint_cmp(
/*=========*/
	ulint	a,	/*!< in: ulint */
	ulint	b);	/*!< in: ulint */
/*******************************************************//**
Compares two pairs of ulints.
@return	-1 if a < b, 0 if a == b, 1 if a > b */
UNIV_INLINE
int
ut_pair_cmp(
/*========*/
	ulint	a1,	/*!< in: more significant part of first pair */
	ulint	a2,	/*!< in: less significant part of first pair */
	ulint	b1,	/*!< in: more significant part of second pair */
	ulint	b2);	/*!< in: less significant part of second pair */
/*************************************************************//**
Determines if a number is zero or a power of two.
@param n	in: number
@return		nonzero if n is zero or a power of two; zero otherwise */
#define ut_is_2pow(n) UNIV_LIKELY(!((n) & ((n) - 1)))
/*************************************************************//**
Calculates fast the remainder of n/m when m is a power of two.
@param n	in: numerator
@param m	in: denominator, must be a power of two
@return		the remainder of n/m */
#define ut_2pow_remainder(n, m) ((n) & ((m) - 1))
/*************************************************************//**
Calculates the biggest multiple of m that is not bigger than n
when m is a power of two.  In other words, rounds n down to m * k.
@param n	in: number to round down
@param m	in: alignment, must be a power of two
@return		n rounded down to the biggest possible integer multiple of m */
#define ut_2pow_round(n, m) ((n) & ~((m) - 1))
/** Align a number down to a multiple of a power of two.
@param n	in: number to round down
@param m	in: alignment, must be a power of two
@return		n rounded down to the biggest possible integer multiple of m */
#define ut_calc_align_down(n, m) ut_2pow_round(n, m)
/********************************************************//**
Calculates the smallest multiple of m that is not smaller than n
when m is a power of two.  In other words, rounds n up to m * k.
@param n	in: number to round up
@param m	in: alignment, must be a power of two
@return		n rounded up to the smallest possible integer multiple of m */
#define ut_calc_align(n, m) (((n) + ((m) - 1)) & ~((m) - 1))
/*************************************************************//**
Calculates fast the 2-logarithm of a number, rounded upward to an
integer.
@return	logarithm in the base 2, rounded upward */
UNIV_INLINE
ulint
ut_2_log(
/*=====*/
	ulint	n);	/*!< in: number */
/*************************************************************//**
Calculates 2 to power n.
@return	2 to power n */
UNIV_INLINE
ulint
ut_2_exp(
/*=====*/
	ulint	n);	/*!< in: number */
/*************************************************************//**
Calculates fast the number rounded up to the nearest power of 2.
@return	first power of 2 which is >= n */
UNIV_INTERN
ulint
ut_2_power_up(
/*==========*/
	ulint	n)	/*!< in: number != 0 */
	__attribute__((const));

/** Determine how many bytes (groups of 8 bits) are needed to
store the given number of bits.
@param b	in: bits
@return		number of bytes (octets) needed to represent b */
#define UT_BITS_IN_BYTES(b) (((b) + 7) / 8)

/**********************************************************//**
Returns system time. We do not specify the format of the time returned:
the only way to manipulate it is to use the function ut_difftime.
@return	system time */
UNIV_INTERN
ib_time_t
ut_time(void);
/*=========*/
#ifndef UNIV_HOTBACKUP
/**********************************************************//**
Returns system time.
Upon successful completion, the value 0 is returned; otherwise the
value -1 is returned and the global variable errno is set to indicate the
error.
@return	0 on success, -1 otherwise */
UNIV_INTERN
int
ut_usectime(
/*========*/
	ulint*	sec,	/*!< out: seconds since the Epoch */
	ulint*	ms);	/*!< out: microseconds since the Epoch+*sec */

/**********************************************************//**
Returns the number of microseconds since epoch. Similar to
time(3), the return value is also stored in *tloc, provided
that tloc is non-NULL.
@return	us since epoch */
UNIV_INTERN
ib_uint64_t
ut_time_us(
/*=======*/
	ib_uint64_t*	tloc);	/*!< out: us since epoch, if non-NULL */
/**********************************************************//**
Returns the number of milliseconds since some epoch.  The
value may wrap around.  It should only be used for heuristic
purposes.
@return	ms since epoch */
UNIV_INTERN
ulint
ut_time_ms(void);
/*============*/
#endif /* !UNIV_HOTBACKUP */

/**********************************************************//**
Returns the difference of two times in seconds.
@return	time2 - time1 expressed in seconds */
UNIV_INTERN
double
ut_difftime(
/*========*/
	ib_time_t	time2,	/*!< in: time */
	ib_time_t	time1);	/*!< in: time */
/**********************************************************//**
Prints a timestamp to a file. */
UNIV_INTERN
void
ut_print_timestamp(
/*===============*/
	ib_stream_t	ib_stream); /*!< in: file where to print */
/**********************************************************//**
Sprintfs a timestamp to a buffer, 13..14 chars plus terminating NUL. */
UNIV_INTERN
void
ut_sprintf_timestamp(
/*=================*/
	char*	buf); /*!< in: buffer where to sprintf */
#ifdef UNIV_HOTBACKUP
/**********************************************************//**
Sprintfs a timestamp to a buffer with no spaces and with ':' characters
replaced by '_'. */
UNIV_INTERN
void
ut_sprintf_timestamp_without_extra_chars(
/*=====================================*/
	char*	buf); /*!< in: buffer where to sprintf */
/**********************************************************//**
Returns current year, month, day. */
UNIV_INTERN
void
ut_get_year_month_day(
/*==================*/
	ulint*	year,	/*!< out: current year */
	ulint*	month,	/*!< out: month */
	ulint*	day);	/*!< out: day */
#else /* UNIV_HOTBACKUP */
/*************************************************************//**
Runs an idle loop on CPU. The argument gives the desired delay
in microseconds on 100 MHz Pentium + Visual C++.
@return	dummy value */
UNIV_INTERN
ulint
ut_delay(
/*=====*/
	ulint	delay);	/*!< in: delay in microseconds on 100 MHz Pentium */
#endif /* UNIV_HOTBACKUP */
/*************************************************************//**
Prints the contents of a memory buffer in hex and ascii. */
UNIV_INTERN
void
ut_print_buf(
/*=========*/
	ib_stream_t	ib_stream,	/*!< in: file where to print */
	const void*	buf,		/*!< in: memory buffer */
	ulint		len);		/*!< in: length of the buffer */

/**********************************************************************//**
Outputs a NUL-terminated file name, quoted with apostrophes. */
UNIV_INTERN
void
ut_print_filename(
/*==============*/
	ib_stream_t	ib_stream,	/*!< in: output stream */
	const char*	name);		/*!< in: name to print */

#ifndef UNIV_HOTBACKUP
/* Forward declaration of transaction handle */
struct trx_struct;

/**********************************************************************//**
Outputs a fixed-length string, quoted as an SQL identifier.
If the string contains a slash '/', the string will be
output as two identifiers separated by a period (.),
as in SQL database_name.identifier. */
UNIV_INTERN
void
ut_print_name(
/*==========*/
	ib_stream_t	ib_stream,	/*!< in: output stream */
	struct trx_struct*trx,		/*!< in: transaction */
	ibool		table_id,	/*!< in: TRUE=print a table name,
					FALSE=print other identifier */
	const char*	name);		/*!< in: name to print */

/**********************************************************************//**
Outputs a fixed-length string, quoted as an SQL identifier.
If the string contains a slash '/', the string will be
output as two identifiers separated by a period (.),
as in SQL database_name.identifier. */
UNIV_INTERN
void
ut_print_namel(
/*===========*/
	ib_stream_t	ib_stream,	/*!< in: output stream */
	const char*	name,		/*!< in: name to print */
	ulint		namelen);	/*!< in: length of name */

#endif /* !UNIV_HOTBACKUP */

#ifdef __WIN__
/**********************************************************************//**
A substitute for snprintf(3), formatted output conversion into
a limited buffer.
@return number of characters that would have been printed if the size
were unlimited, not including the terminating '\0'. */
UNIV_INTERN
int
ut_snprintf(
/*========*/
	char*		str,	/*!< out: string */
	size_t		size,	/*!< in: str size */
	const char*	fmt,	/*!< in: format */
	...);			/*!< in: format values */
#else
/**********************************************************************//**
A wrapper for snprintf(3), formatted output conversion into
a limited buffer. */
# define ut_snprintf	snprintf
#endif /* __WIN__ */

extern ib_logger_t ib_logger;
extern ib_stream_t ib_stream;

#ifndef UNIV_NONINL
#include "ut0ut.ic"
#endif

#endif

/*****************************************************************************

Copyright (c) 2006, 2010, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file include/ut0vec.h
A vector of pointers to data items

Created 4/6/2006 Osku Salerma
************************************************************************/

#ifndef IB_VECTOR_H
#define IB_VECTOR_H

#include "univ.i"
#include "mem0mem.h"

/** An automatically resizing vector data type. */
typedef struct ib_vector_struct ib_vector_t;

/* An automatically resizing vector datatype with the following properties:

 -Contains void* items.

 -The items are owned by the caller.

 -All memory allocation is done through a heap owned by the caller, who is
 responsible for freeing it when done with the vector.

 -When the vector is resized, the old memory area is left allocated since it
 uses the same heap as the new memory area, so this is best used for
 relatively small or short-lived uses.
*/

/****************************************************************//**
Create a new vector with the given initial size.
@return	vector */
UNIV_INTERN
ib_vector_t*
ib_vector_create(
/*=============*/
	mem_heap_t*	heap,	/*!< in: heap */
	ulint		size);	/*!< in: initial size */

/****************************************************************//**
Push a new element to the vector, increasing its size if necessary. */
UNIV_INTERN
void
ib_vector_push(
/*===========*/
	ib_vector_t*	vec,	/*!< in: vector */
	void*		elem);	/*!< in: data element */

/****************************************************************//**
Get the number of elements in the vector.
@return	number of elements in vector */
UNIV_INLINE
ulint
ib_vector_size(
/*===========*/
	const ib_vector_t*	vec);	/*!< in: vector */

/****************************************************************//**
Test whether a vector is empty or not.
@return	TRUE if empty */
UNIV_INLINE
ibool
ib_vector_is_empty(
/*===============*/
	const ib_vector_t*	vec);	/*!< in: vector */

/****************************************************************//**
Get the n'th element.
@return	n'th element */
UNIV_INLINE
void*
ib_vector_get(
/*==========*/
	ib_vector_t*	vec,	/*!< in: vector */
	ulint		n);	/*!< in: element index to get */

/****************************************************************//**
Get n'th element as a const pointer.
@return	n'th element */
UNIV_INLINE
const void*
ib_vector_get_const(
/*================*/
	const ib_vector_t*	vec,	/*!< in: vector */
	ulint		n);	/*!< in: element index to get */

/****************************************************************//**
Set the n'th element and return the previous value.
@return	n'th element */
UNIV_INLINE
void*
ib_vector_set(
/*==========*/
	ib_vector_t*	vec,	/*!< in: vector */
	ulint		n,	/*!< in: element index to set */
	void*		p);	/*!< in: new value to set */

/********************************************************************
Remove the last element from the vector. */
UNIV_INLINE
void*
ib_vector_pop(
/*==========*/
	ib_vector_t*	vec);	/*!< in: vector */

/****************************************************************//**
Free the underlying heap of the vector. Note that vec is invalid
after this call. */
UNIV_INLINE
void
ib_vector_free(
/*===========*/
	ib_vector_t*	vec);	/*!< in,own: vector */

/** An automatically resizing vector data type. */
struct ib_vector_struct {
	mem_heap_t*	heap;	/*!< heap */
	void**		data;	/*!< data elements */
	ulint		used;	/*!< number of elements currently used */
	ulint		total;	/*!< number of elements allocated */
};

#ifndef UNIV_NONINL
#include "ut0vec.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************************//**
@file include/ut0byte.ic
Utilities for byte operations

Created 5/30/1994 Heikki Tuuri
*******************************************************************/

/*******************************************************//**
Creates a 64-bit dulint out of two ulints.
@return	created dulint */
UNIV_INLINE
dulint
ut_dulint_create(
/*=============*/
	ulint	high,	/*!< in: high-order 32 bits */
	ulint	low)	/*!< in: low-order 32 bits */
{
	dulint	res;

	ut_ad(high <= 0xFFFFFFFF);
	ut_ad(low <= 0xFFFFFFFF);

	res.high = high;
	res.low	 = low;

	return(res);
}

/*******************************************************//**
Gets the high-order 32 bits of a dulint.
@return	32 bits in ulint */
UNIV_INLINE
ulint
ut_dulint_get_high(
/*===============*/
	dulint	d)	/*!< in: dulint */
{
	return(d.high);
}

/*******************************************************//**
Gets the low-order 32 bits of a dulint.
@return	32 bits in ulint */
UNIV_INLINE
ulint
ut_dulint_get_low(
/*==============*/
	dulint	d)	/*!< in: dulint */
{
	return(d.low);
}

/*******************************************************//**
Converts a dulint (a struct of 2 ulints) to ib_int64_t, which is a 64-bit
integer type.
@return	value in ib_int64_t type */
UNIV_INLINE
ib_int64_t
ut_conv_dulint_to_longlong(
/*=======================*/
	dulint	d)	/*!< in: dulint */
{
	return((ib_int64_t)d.low
	       + (((ib_int64_t)d.high) << 32));
}

/*******************************************************//**
Tests if a dulint is zero.
@return	TRUE if zero */
UNIV_INLINE
ibool
ut_dulint_is_zero(
/*==============*/
	dulint	a)	/*!< in: dulint */
{
	if ((a.low == 0) && (a.high == 0)) {

		return(TRUE);
	}

	return(FALSE);
}

/*******************************************************//**
Compares two dulints.
@return	-1 if a < b, 0 if a == b, 1 if a > b */
UNIV_INLINE
int
ut_dulint_cmp(
/*==========*/
	dulint	a,	/*!< in: dulint */
	dulint	b)	/*!< in: dulint */
{
	if (a.high > b.high) {
		return(1);
	} else if (a.high < b.high) {
		return(-1);
	} else if (a.low > b.low) {
		return(1);
	} else if (a.low < b.low) {
		return(-1);
	} else {
		return(0);
	}
}

/*******************************************************//**
Adds a ulint to a dulint.
@return	sum a + b */
UNIV_INLINE
dulint
ut_dulint_add(
/*==========*/
	dulint	a,	/*!< in: dulint */
	ulint	b)	/*!< in: ulint */
{
	if (0xFFFFFFFFUL - b >= a.low) {
		a.low += b;

		return(a);
	}

	a.low = a.low - (0xFFFFFFFFUL - b) - 1;

	a.high++;

	return(a);
}

/*******************************************************//**
Subtracts a ulint from a dulint.
@return	a - b */
UNIV_INLINE
dulint
ut_dulint_subtract(
/*===============*/
	dulint	a,	/*!< in: dulint */
	ulint	b)	/*!< in: ulint, b <= a */
{
	if (a.low >= b) {
		a.low -= b;

		return(a);
	}

	b -= a.low + 1;

	a.low = 0xFFFFFFFFUL - b;

	ut_ad(a.high > 0);

	a.high--;

	return(a);
}

/********************************************************//**
Rounds a dulint downward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
dulint
ut_dulint_align_down(
/*=================*/
	dulint	 n,		/*!< in: number to be rounded */
	ulint	 align_no)	/*!< in: align by this number which must be a
				power of 2 */
{
	ulint	low, high;

	ut_ad(align_no > 0);
	ut_ad(((align_no - 1) & align_no) == 0);

	low = ut_dulint_get_low(n);
	high = ut_dulint_get_high(n);

	low = low & ~(align_no - 1);

	return(ut_dulint_create(high, low));
}

/********************************************************//**
Rounds a dulint upward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
dulint
ut_dulint_align_up(
/*===============*/
	dulint	 n,		/*!< in: number to be rounded */
	ulint	 align_no)	/*!< in: align by this number which must be a
				power of 2 */
{
	return(ut_dulint_align_down(ut_dulint_add(n, align_no - 1), align_no));
}

/********************************************************//**
Rounds ib_uint64_t downward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
ib_uint64_t
ut_uint64_align_down(
/*=================*/
	ib_uint64_t	 n,		/*!< in: number to be rounded */
	ulint		 align_no)	/*!< in: align by this number
					which must be a power of 2 */
{
	ut_ad(align_no > 0);
	ut_ad(ut_is_2pow(align_no));

	return(n & ~((ib_uint64_t) align_no - 1));
}

/********************************************************//**
Rounds ib_uint64_t upward to a multiple of a power of 2.
@return	rounded value */
UNIV_INLINE
ib_uint64_t
ut_uint64_align_up(
/*===============*/
	ib_uint64_t	 n,		/*!< in: number to be rounded */
	ulint		 align_no)	/*!< in: align by this number
					which must be a power of 2 */
{
	ib_uint64_t	align_1 = (ib_uint64_t) align_no - 1;

	ut_ad(align_no > 0);
	ut_ad(ut_is_2pow(align_no));

	return((n + align_1) & ~align_1);
}

/*********************************************************//**
The following function rounds up a pointer to the nearest aligned address.
@return	aligned pointer */
UNIV_INLINE
void*
ut_align(
/*=====*/
	const void*	ptr,		/*!< in: pointer */
	ulint		align_no)	/*!< in: align by this number */
{
	ut_ad(align_no > 0);
	ut_ad(((align_no - 1) & align_no) == 0);
	ut_ad(ptr);

	ut_ad(sizeof(void*) == sizeof(ulint));

	return((void*)((((ulint)ptr) + align_no - 1) & ~(align_no - 1)));
}

/*********************************************************//**
The following function rounds down a pointer to the nearest
aligned address.
@return	aligned pointer */
UNIV_INLINE
void*
ut_align_down(
/*==========*/
	const void*	ptr,		/*!< in: pointer */
	ulint		align_no)	/*!< in: align by this number */
{
	ut_ad(align_no > 0);
	ut_ad(((align_no - 1) & align_no) == 0);
	ut_ad(ptr);

	ut_ad(sizeof(void*) == sizeof(ulint));

	return((void*)((((ulint)ptr)) & ~(align_no - 1)));
}

/*********************************************************//**
The following function computes the offset of a pointer from the nearest
aligned address.
@return	distance from aligned pointer */
UNIV_INLINE
ulint
ut_align_offset(
/*============*/
	const void*	ptr,		/*!< in: pointer */
	ulint		align_no)	/*!< in: align by this number */
{
	ut_ad(align_no > 0);
	ut_ad(((align_no - 1) & align_no) == 0);
	ut_ad(ptr);

	ut_ad(sizeof(void*) == sizeof(ulint));

	return(((ulint)ptr) & (align_no - 1));
}

/*****************************************************************//**
Gets the nth bit of a ulint.
@return	TRUE if nth bit is 1; 0th bit is defined to be the least significant */
UNIV_INLINE
ibool
ut_bit_get_nth(
/*===========*/
	ulint	a,	/*!< in: ulint */
	ulint	n)	/*!< in: nth bit requested */
{
	ut_ad(n < 8 * sizeof(ulint));
#if TRUE != 1
# error "TRUE != 1"
#endif
	return(1 & (a >> n));
}

/*****************************************************************//**
Sets the nth bit of a ulint.
@return	the ulint with the bit set as requested */
UNIV_INLINE
ulint
ut_bit_set_nth(
/*===========*/
	ulint	a,	/*!< in: ulint */
	ulint	n,	/*!< in: nth bit requested */
	ibool	val)	/*!< in: value for the bit to set */
{
	ut_ad(n < 8 * sizeof(ulint));
#if TRUE != 1
# error "TRUE != 1"
#endif
	if (val) {
		return(((ulint) 1 << n) | a);
	} else {
		return(~((ulint) 1 << n) & a);
	}
}
/*****************************************************************************

Copyright (c) 2006, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file include/ut0list.ic
A double-linked list

Created 4/26/2006 Osku Salerma
************************************************************************/

/****************************************************************//**
Get the first node in the list.
@return	first node, or NULL */
UNIV_INLINE
ib_list_node_t*
ib_list_get_first(
/*==============*/
	ib_list_t*	list)	/*!< in: list */
{
	return(list->first);
}

/****************************************************************//**
Get the last node in the list.
@return	last node, or NULL */
UNIV_INLINE
ib_list_node_t*
ib_list_get_last(
/*=============*/
	ib_list_t*	list)	/*!< in: list */
{
	return(list->last);
}
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file include/ut0mem.ic
Memory primitives

Created 5/30/1994 Heikki Tuuri
************************************************************************/

#include "ut0byte.h"
#include "mach0data.h"

/** Wrapper for memcpy(3).  Copy memory area when the source and
target are not overlapping.
* @param dest	in: copy to
* @param sour	in: copy from
* @param n	in: number of bytes to copy
* @return	dest */
UNIV_INLINE
void*
ut_memcpy(void* dest, const void* sour, ulint n)
{
	return(memcpy(dest, sour, n));
}

/** Wrapper for memmove(3).  Copy memory area when the source and
target are overlapping.
* @param dest	in: copy to
* @param sour	in: copy from
* @param n	in: number of bytes to copy
* @return	dest */
UNIV_INLINE
void*
ut_memmove(void* dest, const void* sour, ulint n)
{
	return(memmove(dest, sour, n));
}

/** Wrapper for memcmp(3).  Compare memory areas.
* @param str1	in: first memory block to compare
* @param str2	in: second memory block to compare
* @param n	in: number of bytes to compare
* @return	negative, 0, or positive if str1 is smaller, equal,
		or greater than str2, respectively. */
UNIV_INLINE
int
ut_memcmp(const void* str1, const void* str2, ulint n)
{
	return(memcmp(str1, str2, n));
}

/** Wrapper for strcpy(3).  Copy a NUL-terminated string.
* @param dest	in: copy to
* @param sour	in: copy from
* @return	dest */
UNIV_INLINE
char*
ut_strcpy(char* dest, const char* sour)
{
	return(strcpy(dest, sour));
}

/** Wrapper for strlen(3).  Determine the length of a NUL-terminated string.
* @param str	in: string
* @return	length of the string in bytes, excluding the terminating NUL */
UNIV_INLINE
ulint
ut_strlen(const char* str)
{
	return(strlen(str));
}

/** Wrapper for strcmp(3).  Compare NUL-terminated strings.
* @param str1	in: first string to compare
* @param str2	in: second string to compare
* @return	negative, 0, or positive if str1 is smaller, equal,
		or greater than str2, respectively. */
UNIV_INLINE
int
ut_strcmp(const char* str1, const char* str2)
{
	return(strcmp(str1, str2));
}

/**********************************************************************//**
Compute strlen(ut_strcpyq(str, q)).
@return	length of the string when quoted */
UNIV_INLINE
ulint
ut_strlenq(
/*=======*/
	const char*	str,	/*!< in: null-terminated string */
	char		q)	/*!< in: the quote character */
{
	ulint len;

	for (len = 0; *str; len++, str++) {
		if (*str == q) {
			len++;
		}
	}

	return(len);
}

/**********************************************************************//**
Converts a raw binary data to a NUL-terminated hex string. The output is
truncated if there is not enough space in "hex", make sure "hex_size" is at
least (2 * raw_size + 1) if you do not want this to happen. Returns the
actual number of characters written to "hex" (including the NUL).
@return	number of chars written */
UNIV_INLINE
ulint
ut_raw_to_hex(
/*==========*/
	const void*	raw,		/*!< in: raw data */
	ulint		raw_size,	/*!< in: "raw" length in bytes */
	char*		hex,		/*!< out: hex string */
	ulint		hex_size)	/*!< in: "hex" size in bytes */
{

#ifdef WORDS_BIGENDIAN

#define MK_UINT16(a, b) (((ib_uint16_t) (a)) << 8 | (ib_uint16_t) (b))

#define UINT16_GET_A(u)	((unsigned char) ((u) >> 8))
#define UINT16_GET_B(u)	((unsigned char) ((u) & 0xFF))

#else /* WORDS_BIGENDIAN */

#define MK_UINT16(a, b) (((ib_uint16_t) (b)) << 8 | (ib_uint16_t) (a))

#define UINT16_GET_A(u)	((unsigned char) ((u) & 0xFF))
#define UINT16_GET_B(u)	((unsigned char) ((u) >> 8))

#endif /* WORDS_BIGENDIAN */

#define MK_ALL_UINT16_WITH_A(a)	\
	MK_UINT16(a, '0'),	\
	MK_UINT16(a, '1'),	\
	MK_UINT16(a, '2'),	\
	MK_UINT16(a, '3'),	\
	MK_UINT16(a, '4'),	\
	MK_UINT16(a, '5'),	\
	MK_UINT16(a, '6'),	\
	MK_UINT16(a, '7'),	\
	MK_UINT16(a, '8'),	\
	MK_UINT16(a, '9'),	\
	MK_UINT16(a, 'A'),	\
	MK_UINT16(a, 'B'),	\
	MK_UINT16(a, 'C'),	\
	MK_UINT16(a, 'D'),	\
	MK_UINT16(a, 'E'),	\
	MK_UINT16(a, 'F')

	static const ib_uint16_t	hex_map[256] = {
		MK_ALL_UINT16_WITH_A('0'),
		MK_ALL_UINT16_WITH_A('1'),
		MK_ALL_UINT16_WITH_A('2'),
		MK_ALL_UINT16_WITH_A('3'),
		MK_ALL_UINT16_WITH_A('4'),
		MK_ALL_UINT16_WITH_A('5'),
		MK_ALL_UINT16_WITH_A('6'),
		MK_ALL_UINT16_WITH_A('7'),
		MK_ALL_UINT16_WITH_A('8'),
		MK_ALL_UINT16_WITH_A('9'),
		MK_ALL_UINT16_WITH_A('A'),
		MK_ALL_UINT16_WITH_A('B'),
		MK_ALL_UINT16_WITH_A('C'),
		MK_ALL_UINT16_WITH_A('D'),
		MK_ALL_UINT16_WITH_A('E'),
		MK_ALL_UINT16_WITH_A('F')
	};
	const unsigned char*	rawc;
	ulint			read_bytes;
	ulint			write_bytes;
	ulint			i;

	rawc = (const unsigned char*) raw;

	if (hex_size == 0) {

		return(0);
	}

	if (hex_size <= 2 * raw_size) {

		read_bytes = hex_size / 2;
		write_bytes = hex_size;
	} else {

		read_bytes = raw_size;
		write_bytes = 2 * raw_size + 1;
	}

#define LOOP_READ_BYTES(ASSIGN)			\
	for (i = 0; i < read_bytes; i++) {	\
		ASSIGN;				\
		hex += 2;			\
		rawc++;				\
	}

	if (ut_align_offset(hex, 2) == 0) {

		LOOP_READ_BYTES(
			*(ib_uint16_t*) hex = hex_map[*rawc]
		);
	} else {

		LOOP_READ_BYTES(
			*hex       = UINT16_GET_A(hex_map[*rawc]);
			*(hex + 1) = UINT16_GET_B(hex_map[*rawc])
		);
	}

	if (hex_size <= 2 * raw_size && hex_size % 2 == 0) {

		hex--;
	}

	*hex = '\0';

	return(write_bytes);
}

/*******************************************************************//**
Adds single quotes to the start and end of string and escapes any quotes
by doubling them. Returns the number of bytes that were written to "buf"
(including the terminating NUL). If buf_size is too small then the
trailing bytes from "str" are discarded.
@return	number of bytes that were written */
UNIV_INLINE
ulint
ut_str_sql_format(
/*==============*/
	const char*	str,		/*!< in: string */
	ulint		str_len,	/*!< in: string length in bytes */
	char*		buf,		/*!< out: output buffer */
	ulint		buf_size)	/*!< in: output buffer size
					in bytes */
{
	ulint	str_i;
	ulint	buf_i;

	buf_i = 0;

	switch (buf_size) {
	case 3:

		if (str_len == 0) {

			buf[buf_i] = '\'';
			buf_i++;
			buf[buf_i] = '\'';
			buf_i++;
		}
		/* FALLTHROUGH */
	case 2:
	case 1:

		buf[buf_i] = '\0';
		buf_i++;
		/* FALLTHROUGH */
	case 0:

		return(buf_i);
	}

	/* buf_size >= 4 */

	buf[0] = '\'';
	buf_i = 1;

	for (str_i = 0; str_i < str_len; str_i++) {

		char	ch;

		if (buf_size - buf_i == 2) {

			break;
		}

		ch = str[str_i];

		switch (ch) {
		case '\0':

			if (UNIV_UNLIKELY(buf_size - buf_i < 4)) {

				goto func_exit;
			}
			buf[buf_i] = '\\';
			buf_i++;
			buf[buf_i] = '0';
			buf_i++;
			break;
		case '\'':
		case '\\':

			if (UNIV_UNLIKELY(buf_size - buf_i < 4)) {

				goto func_exit;
			}
			buf[buf_i] = ch;
			buf_i++;
			/* FALLTHROUGH */
		default:

			buf[buf_i] = ch;
			buf_i++;
		}
	}

func_exit:

	buf[buf_i] = '\'';
	buf_i++;
	buf[buf_i] = '\0';
	buf_i++;

	return(buf_i);
}
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************************//**
@file include/ut0rnd.ic
Random numbers and hashing

Created 5/30/1994 Heikki Tuuri
*******************************************************************/

#define UT_HASH_RANDOM_MASK	1463735687
#define UT_HASH_RANDOM_MASK2	1653893711
#define UT_RND1			151117737
#define UT_RND2			119785373
#define UT_RND3			 85689495
#define UT_RND4			 76595339
#define UT_SUM_RND2		 98781234
#define UT_SUM_RND3		126792457
#define UT_SUM_RND4		 63498502
#define UT_XOR_RND1		187678878
#define UT_XOR_RND2		143537923

/** Seed value of ut_rnd_gen_ulint() */
extern	ulint	 ut_rnd_ulint_counter;

/********************************************************//**
This is used to set the random number seed. */
UNIV_INLINE
void
ut_rnd_set_seed(
/*============*/
	ulint	 seed)		 /*!< in: seed */
{
	ut_rnd_ulint_counter = seed;
}

/********************************************************//**
The following function generates a series of 'random' ulint integers.
@return	the next 'random' number */
UNIV_INLINE
ulint
ut_rnd_gen_next_ulint(
/*==================*/
	ulint	rnd)	/*!< in: the previous random number value */
{
	ulint	n_bits;

	n_bits = 8 * sizeof(ulint);

	rnd = UT_RND2 * rnd + UT_SUM_RND3;
	rnd = UT_XOR_RND1 ^ rnd;
	rnd = (rnd << 20) + (rnd >> (n_bits - 20));
	rnd = UT_RND3 * rnd + UT_SUM_RND4;
	rnd = UT_XOR_RND2 ^ rnd;
	rnd = (rnd << 20) + (rnd >> (n_bits - 20));
	rnd = UT_RND1 * rnd + UT_SUM_RND2;

	return(rnd);
}

/********************************************************//**
The following function generates 'random' ulint integers which
enumerate the value space of ulint integers in a pseudo random
fashion. Note that the same integer is repeated always after
2 to power 32 calls to the generator (if ulint is 32-bit).
@return	the 'random' number */
UNIV_INLINE
ulint
ut_rnd_gen_ulint(void)
/*==================*/
{
	ulint	rnd;
	ulint	n_bits;

	n_bits = 8 * sizeof(ulint);

	ut_rnd_ulint_counter = UT_RND1 * ut_rnd_ulint_counter + UT_RND2;

	rnd = ut_rnd_gen_next_ulint(ut_rnd_ulint_counter);

	return(rnd);
}

/********************************************************//**
Generates a random integer from a given interval.
@return	the 'random' number */
UNIV_INLINE
ulint
ut_rnd_interval(
/*============*/
	ulint	low,	/*!< in: low limit; can generate also this value */
	ulint	high)	/*!< in: high limit; can generate also this value */
{
	ulint	rnd;

	ut_ad(high >= low);

	if (low == high) {

		return(low);
	}

	rnd = ut_rnd_gen_ulint();

	return(low + (rnd % (high - low + 1)));
}

/*********************************************************//**
Generates a random iboolean value.
@return	the random value */
UNIV_INLINE
ibool
ut_rnd_gen_ibool(void)
/*=================*/
{
	ulint	 x;

	x = ut_rnd_gen_ulint();

	if (((x >> 20) + (x >> 15)) & 1) {

		return(TRUE);
	}

	return(FALSE);
}

/*******************************************************//**
The following function generates a hash value for a ulint integer
to a hash table of size table_size, which should be a prime
or some random number for the hash table to work reliably.
@return	hash value */
UNIV_INLINE
ulint
ut_hash_ulint(
/*==========*/
	ulint	 key,		/*!< in: value to be hashed */
	ulint	 table_size)	/*!< in: hash table size */
{
	key = key ^ UT_HASH_RANDOM_MASK2;

	return(key % table_size);
}

/*************************************************************//**
Folds a pair of ulints.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_ulint_pair(
/*===============*/
	ulint	n1,	/*!< in: ulint */
	ulint	n2)	/*!< in: ulint */
{
	return(((((n1 ^ n2 ^ UT_HASH_RANDOM_MASK2) << 8) + n1)
		^ UT_HASH_RANDOM_MASK) + n2);
}

/*************************************************************//**
Folds a dulint.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_dulint(
/*===========*/
	dulint	d)	/*!< in: dulint */
{
	return(ut_fold_ulint_pair(ut_dulint_get_low(d),
				  ut_dulint_get_high(d)));
}

/*************************************************************//**
Folds a character string ending in the null character.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_string(
/*===========*/
	const char*	str)	/*!< in: null-terminated string */
{
	ulint	fold = 0;

	ut_ad(str);

	while (*str != '\0') {
		fold = ut_fold_ulint_pair(fold, (ulint)(*str));
		str++;
	}

	return(fold);
}

/*************************************************************//**
Folds a binary string.
@return	folded value */
UNIV_INLINE
ulint
ut_fold_binary(
/*===========*/
	const byte*	str,	/*!< in: string of bytes */
	ulint		len)	/*!< in: length */
{
	const byte*	str_end	= str + len;
	ulint		fold = 0;

	ut_ad(str || !len);

	while (str < str_end) {
		fold = ut_fold_ulint_pair(fold, (ulint)(*str));

		str++;
	}

	return(fold);
}
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************************//**
@file include/ut0ut.ic
Various utilities

Created 5/30/1994 Heikki Tuuri
*******************************************************************/

/******************************************************//**
Calculates the minimum of two ulints.
@return	minimum */
UNIV_INLINE
ulint
ut_min(
/*===*/
	ulint	 n1,	/*!< in: first number */
	ulint	 n2)	/*!< in: second number */
{
	return((n1 <= n2) ? n1 : n2);
}

/******************************************************//**
Calculates the maximum of two ulints.
@return	maximum */
UNIV_INLINE
ulint
ut_max(
/*===*/
	ulint	 n1,	/*!< in: first number */
	ulint	 n2)	/*!< in: second number */
{
	return((n1 <= n2) ? n2 : n1);
}

/****************************************************************//**
Calculates minimum of two ulint-pairs. */
UNIV_INLINE
void
ut_pair_min(
/*========*/
	ulint*	a,	/*!< out: more significant part of minimum */
	ulint*	b,	/*!< out: less significant part of minimum */
	ulint	a1,	/*!< in: more significant part of first pair */
	ulint	b1,	/*!< in: less significant part of first pair */
	ulint	a2,	/*!< in: more significant part of second pair */
	ulint	b2)	/*!< in: less significant part of second pair */
{
	if (a1 == a2) {
		*a = a1;
		*b = ut_min(b1, b2);
	} else if (a1 < a2) {
		*a = a1;
		*b = b1;
	} else {
		*a = a2;
		*b = b2;
	}
}

/******************************************************//**
Compares two ulints.
@return	1 if a > b, 0 if a == b, -1 if a < b */
UNIV_INLINE
int
ut_ulint_cmp(
/*=========*/
	ulint	a,	/*!< in: ulint */
	ulint	b)	/*!< in: ulint */
{
	if (a < b) {
		return(-1);
	} else if (a == b) {
		return(0);
	} else {
		return(1);
	}
}

/*******************************************************//**
Compares two pairs of ulints.
@return	-1 if a < b, 0 if a == b, 1 if a > b */
UNIV_INLINE
int
ut_pair_cmp(
/*========*/
	ulint	a1,	/*!< in: more significant part of first pair */
	ulint	a2,	/*!< in: less significant part of first pair */
	ulint	b1,	/*!< in: more significant part of second pair */
	ulint	b2)	/*!< in: less significant part of second pair */
{
	if (a1 > b1) {
		return(1);
	} else if (a1 < b1) {
		return(-1);
	} else if (a2 > b2) {
		return(1);
	} else if (a2 < b2) {
		return(-1);
	} else {
		return(0);
	}
}

/*************************************************************//**
Calculates fast the 2-logarithm of a number, rounded upward to an
integer.
@return	logarithm in the base 2, rounded upward */
UNIV_INLINE
ulint
ut_2_log(
/*=====*/
	ulint	n)	/*!< in: number != 0 */
{
	ulint	res;

	res = 0;

	ut_ad(n > 0);

	n = n - 1;

	for (;;) {
		n = n / 2;

		if (n == 0) {
			break;
		}

		res++;
	}

	return(res + 1);
}

/*************************************************************//**
Calculates 2 to power n.
@return	2 to power n */
UNIV_INLINE
ulint
ut_2_exp(
/*=====*/
	ulint	n)	/*!< in: number */
{
	return((ulint) 1 << n);
}
/*****************************************************************************

Copyright (c) 2006, 2010, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file include/ut0vec.ic
A vector of pointers to data items

Created 4/6/2006 Osku Salerma
************************************************************************/

/****************************************************************//**
Get number of elements in vector.
@return	number of elements in vector */
UNIV_INLINE
ulint
ib_vector_size(
/*===========*/
	const ib_vector_t*	vec)	/*!< in: vector */
{
	return(vec->used);
}

/****************************************************************//**
Get n'th element.
@return	n'th element */
UNIV_INLINE
void*
ib_vector_get(
/*==========*/
	ib_vector_t*	vec,	/*!< in: vector */
	ulint		n)	/*!< in: element index to get */
{
	ut_a(n < ib_vector_size(vec));

	return(vec->data[n]);
}

/****************************************************************//**
Get n'th element as a const pointer.
@return	n'th element */
UNIV_INLINE
const void*
ib_vector_get_const(
/*================*/
	const ib_vector_t*	vec,	/*!< in: vector */
	ulint		n)	/*!< in: element index to get */
{
	ut_a(n < ib_vector_size(vec));

	return(vec->data[n]);
}

/****************************************************************//**
Set n'th element and return the previous value.
@return	n'th element */
UNIV_INLINE
void*
ib_vector_set(
/*==========*/
	ib_vector_t*	vec,	/*!< in: vector */
	ulint		n,	/*!< in: element index to set */
	void*		p)	/*!< in: new value to set */
{
	void*		prev;

	ut_a(n < ib_vector_size(vec));

	prev = vec->data[n];
	vec->data[n] = p;

	return(prev);
}

/********************************************************************
Remove the last element from the vector.
@return	last vector element */
UNIV_INLINE
void*
ib_vector_pop(
/*==========*/
	ib_vector_t*    vec)    /*!< in/out: vector */
{
	void*           elem;

	ut_a(vec->used > 0);
	--vec->used;
	elem = vec->data[vec->used];

	ut_d(vec->data[vec->used] = NULL);
	UNIV_MEM_INVALID(&vec->data[vec->used], sizeof(*vec->data));

	return(elem);
}

/****************************************************************//**
Free the underlying heap of the vector. Note that vec is invalid
after this call. */
UNIV_INLINE
void
ib_vector_free(
/*===========*/
	ib_vector_t*    vec)    /*!< in, own: vector */
{
	mem_heap_free(vec->heap);
}

/****************************************************************//**
Test whether a vector is empty or not.
@return	TRUE if empty */
UNIV_INLINE
ibool
ib_vector_is_empty(
/*===============*/
	const ib_vector_t*	vec)	/*!< in: vector */
{
	return(ib_vector_size(vec) == 0);
}
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/mach0data.h
Utilities for converting data from the database file
to the machine format.

Created 11/28/1995 Heikki Tuuri
***********************************************************************/

#ifndef mach0data_h
#define mach0data_h

#include "univ.i"
#include "ut0byte.h"

/* The data and all fields are always stored in a database file
in the same format: ascii, big-endian, ... .
All data in the files MUST be accessed using the functions in this
module. */

/*******************************************************//**
The following function is used to store data in one byte. */
UNIV_INLINE
void
mach_write_to_1(
/*============*/
	byte*	b,	/*!< in: pointer to byte where to store */
	ulint	n);	 /*!< in: ulint integer to be stored, >= 0, < 256 */
/********************************************************//**
The following function is used to fetch data from one byte.
@return	ulint integer, >= 0, < 256 */
UNIV_INLINE
ulint
mach_read_from_1(
/*=============*/
	const byte*	b)	/*!< in: pointer to byte */
	__attribute__((nonnull, pure));
/*******************************************************//**
The following function is used to store data in two consecutive
bytes. We store the most significant byte to the lower address. */
UNIV_INLINE
void
mach_write_to_2(
/*============*/
	byte*	b,	/*!< in: pointer to two bytes where to store */
	ulint	n);	 /*!< in: ulint integer to be stored, >= 0, < 64k */
/********************************************************//**
The following function is used to fetch data from two consecutive
bytes. The most significant byte is at the lowest address.
@return	ulint integer, >= 0, < 64k */
UNIV_INLINE
ulint
mach_read_from_2(
/*=============*/
	const byte*	b)	/*!< in: pointer to two bytes */
	__attribute__((nonnull, pure));

/********************************************************//**
The following function is used to convert a 16-bit data item
to the canonical format, for fast bytewise equality test
against memory.
@return	16-bit integer in canonical format */
UNIV_INLINE
ib_uint16_t
mach_encode_2(
/*==========*/
	ulint	n)	/*!< in: integer in machine-dependent format */
	__attribute__((const));
/********************************************************//**
The following function is used to convert a 16-bit data item
from the canonical format, for fast bytewise equality test
against memory.
@return	integer in machine-dependent format */
UNIV_INLINE
ulint
mach_decode_2(
/*==========*/
	ib_uint16_t	n)	/*!< in: 16-bit integer in canonical format */
	__attribute__((const));
/*******************************************************//**
The following function is used to store data in 3 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_3(
/*============*/
	byte*	b,	/*!< in: pointer to 3 bytes where to store */
	ulint	n);	 /*!< in: ulint integer to be stored */
/********************************************************//**
The following function is used to fetch data from 3 consecutive
bytes. The most significant byte is at the lowest address.
@return	ulint integer */
UNIV_INLINE
ulint
mach_read_from_3(
/*=============*/
	const byte*	b)	/*!< in: pointer to 3 bytes */
	__attribute__((nonnull, pure));
/*******************************************************//**
The following function is used to store data in four consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_4(
/*============*/
	byte*	b,	/*!< in: pointer to four bytes where to store */
	ulint	n);	 /*!< in: ulint integer to be stored */
/********************************************************//**
The following function is used to fetch data from 4 consecutive
bytes. The most significant byte is at the lowest address.
@return	ulint integer */
UNIV_INLINE
ulint
mach_read_from_4(
/*=============*/
	const byte*	b)	/*!< in: pointer to four bytes */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a ulint in a compressed form (1..5 bytes).
@return	stored size in bytes */
UNIV_INLINE
ulint
mach_write_compressed(
/*==================*/
	byte*	b,	/*!< in: pointer to memory where to store */
	ulint	n);	/*!< in: ulint integer to be stored */
/*********************************************************//**
Returns the size of an ulint when written in the compressed form.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_get_compressed_size(
/*=====================*/
	ulint	n)	/*!< in: ulint integer to be stored */
	__attribute__((const));
/*********************************************************//**
Reads a ulint in a compressed form.
@return	read integer */
UNIV_INLINE
ulint
mach_read_compressed(
/*=================*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
	__attribute__((nonnull, pure));
/*******************************************************//**
The following function is used to store data in 6 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_6(
/*============*/
	byte*	b,	/*!< in: pointer to 6 bytes where to store */
	dulint	n);	 /*!< in: dulint integer to be stored */
/********************************************************//**
The following function is used to fetch data from 6 consecutive
bytes. The most significant byte is at the lowest address.
@return	dulint integer */
UNIV_INLINE
dulint
mach_read_from_6(
/*=============*/
	const byte*	b)	/*!< in: pointer to 6 bytes */
	__attribute__((nonnull, pure));
/*******************************************************//**
The following function is used to store data in 7 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_7(
/*============*/
	byte*	b,	/*!< in: pointer to 7 bytes where to store */
	dulint	n);	 /*!< in: dulint integer to be stored */
/********************************************************//**
The following function is used to fetch data from 7 consecutive
bytes. The most significant byte is at the lowest address.
@return	dulint integer */
UNIV_INLINE
dulint
mach_read_from_7(
/*=============*/
	const byte*	b)	/*!< in: pointer to 7 bytes */
	__attribute__((nonnull, pure));
/*******************************************************//**
The following function is used to store data in 8 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_8(
/*============*/
	byte*	b,	/*!< in: pointer to 8 bytes where to store */
	dulint	n);	/*!< in: dulint integer to be stored */
/*******************************************************//**
The following function is used to store data in 8 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_ull(
/*===========*/
	byte*		b,	/*!< in: pointer to 8 bytes where to store */
	ib_uint64_t	n);	/*!< in: 64-bit integer to be stored */
/********************************************************//**
The following function is used to fetch data from 8 consecutive
bytes. The most significant byte is at the lowest address.
@return	dulint integer */
UNIV_INLINE
dulint
mach_read_from_8(
/*=============*/
	const byte*	b)	/*!< in: pointer to 8 bytes */
	__attribute__((nonnull, pure));
/********************************************************//**
The following function is used to fetch data from 8 consecutive
bytes. The most significant byte is at the lowest address.
@return	64-bit integer */
UNIV_INLINE
ib_uint64_t
mach_read_ull(
/*==========*/
	const byte*	b)	/*!< in: pointer to 8 bytes */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a dulint in a compressed form (5..9 bytes).
@return	size in bytes */
UNIV_INLINE
ulint
mach_dulint_write_compressed(
/*=========================*/
	byte*	b,	/*!< in: pointer to memory where to store */
	dulint	n);	/*!< in: dulint integer to be stored */
/*********************************************************//**
Returns the size of a dulint when written in the compressed form.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_dulint_get_compressed_size(
/*============================*/
	dulint	 n);	/*!< in: dulint integer to be stored */
/*********************************************************//**
Reads a dulint in a compressed form.
@return	read dulint */
UNIV_INLINE
dulint
mach_dulint_read_compressed(
/*========================*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a dulint in a compressed form (1..11 bytes).
@return	size in bytes */
UNIV_INLINE
ulint
mach_dulint_write_much_compressed(
/*==============================*/
	byte*	b,	/*!< in: pointer to memory where to store */
	dulint	n);	/*!< in: dulint integer to be stored */
/*********************************************************//**
Returns the size of a dulint when written in the compressed form.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_dulint_get_much_compressed_size(
/*=================================*/
	dulint	 n)	 /*!< in: dulint integer to be stored */
	__attribute__((const));
/*********************************************************//**
Reads a dulint in a compressed form.
@return	read dulint */
UNIV_INLINE
dulint
mach_dulint_read_much_compressed(
/*=============================*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
	__attribute__((nonnull, pure));
/*********************************************************//**
Reads a ulint in a compressed form if the log record fully contains it.
@return	pointer to end of the stored field, NULL if not complete */
UNIV_INTERN
byte*
mach_parse_compressed(
/*==================*/
	byte*	ptr,	/*!< in: pointer to buffer from where to read */
	byte*	end_ptr,/*!< in: pointer to end of the buffer */
	ulint*	val);	/*!< out: read value */
/*********************************************************//**
Reads a dulint in a compressed form if the log record fully contains it.
@return	pointer to end of the stored field, NULL if not complete */
UNIV_INTERN
byte*
mach_dulint_parse_compressed(
/*=========================*/
	byte*	ptr,	/*!< in: pointer to buffer from where to read */
	byte*	end_ptr,/*!< in: pointer to end of the buffer */
	dulint*	val);	/*!< out: read value */
#ifndef UNIV_HOTBACKUP
/*********************************************************//**
Reads a double. It is stored in a little-endian format.
@return	double read */
UNIV_INLINE
double
mach_double_read(
/*=============*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a pointer to a double. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_double_ptr_write(
/*==================*/
	byte*		b,	/*!< in: pointer to memory where to write */
	const byte*	ptr);	/*!< in: pointer to a double */

/***********************************************************//**
Writes a double. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_double_write(
/*==============*/
	byte*	b,	/*!< in: pointer to memory where to write */
	double	d);	/*!< in: double */
/*********************************************************//**
Reads a float. It is stored in a little-endian format.
@return	float read */
UNIV_INLINE
float
mach_float_read(
/*============*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a pointer to float. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_float_ptr_write(
/*=================*/
	byte*		b,	/*!< in: pointer to memory where to write */
	const byte*	p);	/*!< in: pointer to float */
/***********************************************************//**
Writes a float. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_float_write(
/*=============*/
	byte*	b,	/*!< in: pointer to memory where to write */
	float	d);	/*!< in: float */
/*********************************************************//**
Reads a ulint stored in the little-endian format.
@return	unsigned long int */
UNIV_INLINE
ulint
mach_read_from_n_little_endian(
/*===========================*/
	const byte*	buf,		/*!< in: from where to read */
	ulint		buf_size)	/*!< in: from how many bytes to read */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a ulint in the little-endian format. */
UNIV_INLINE
void
mach_write_to_n_little_endian(
/*==========================*/
	byte*	dest,		/*!< in: where to write */
	ulint	dest_size,	/*!< in: into how many bytes to write */
	ulint	n);		/*!< in: unsigned long int to write */
/*********************************************************//**
Reads a ulint stored in the little-endian format.
@return	unsigned long int */
UNIV_INLINE
ulint
mach_read_from_2_little_endian(
/*===========================*/
	const byte*	buf)		/*!< in: from where to read */
	__attribute__((nonnull, pure));
/*********************************************************//**
Writes a ulint in the little-endian format. */
UNIV_INLINE
void
mach_write_to_2_little_endian(
/*==========================*/
	byte*	dest,		/*!< in: where to write */
	ulint	n);		/*!< in: unsigned long int to write */

/*********************************************************//**
Convert integral type from storage byte order (big endian) to
host byte order.
@return	integer value */
UNIV_INLINE
void
mach_read_int_type(
/*===============*/
	void*		dst,		/*!< out: where to write */
	const byte*	src,		/*!< in: where to read from */
	ulint		len,		/*!< in: length of src */
	ibool		unsigned_type);	/*!< in: signed or unsigned flag */
/***********************************************************//**
Convert integral type from host byte order to (big-endian) storage
byte order. */
UNIV_INLINE
void
mach_write_int_type(
/*================*/
	byte*           dest,           /*!< in: where to write*/
	const byte*     src,            /*!< in: where to read from */
	ulint           len,            /*!< in: length of src */
	ibool           unsigned_type); /*!< in: signed or unsigned flag */

/***********************************************************//**
Convert a 64 bit unsigned integral type to big endian from host
byte order. */
UNIV_INLINE
void
mach_write_uint64(
/*==============*/
	byte*		dest,		/*!< out: where to write */
	ib_uint64_t	n);		/*!< in: where to read from */
#endif /* !UNIV_HOTBACKUP */

#ifndef UNIV_NONINL
#include "mach0data.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file include/mach0data.ic
Utilities for converting data from the database file
to the machine format.

Created 11/28/1995 Heikki Tuuri
***********************************************************************/

#include "ut0mem.h"

/*******************************************************//**
The following function is used to store data in one byte. */
UNIV_INLINE
void
mach_write_to_1(
/*============*/
	byte*	b,	/*!< in: pointer to byte where to store */
	ulint	n)	/*!< in: ulint integer to be stored, >= 0, < 256 */
{
	ut_ad(b);
	ut_ad(n <= 0xFFUL);

	b[0] = (byte)n;
}

/********************************************************//**
The following function is used to fetch data from one byte.
@return	ulint integer, >= 0, < 256 */
UNIV_INLINE
ulint
mach_read_from_1(
/*=============*/
	const byte*	b)	/*!< in: pointer to byte */
{
	ut_ad(b);
	return((ulint)(b[0]));
}

/*******************************************************//**
The following function is used to store data in two consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_2(
/*============*/
	byte*	b,	/*!< in: pointer to two bytes where to store */
	ulint	n)	/*!< in: ulint integer to be stored */
{
	ut_ad(b);
	ut_ad(n <= 0xFFFFUL);

	b[0] = (byte)(n >> 8);
	b[1] = (byte)(n);
}

/********************************************************//**
The following function is used to fetch data from 2 consecutive
bytes. The most significant byte is at the lowest address.
@return	ulint integer */
UNIV_INLINE
ulint
mach_read_from_2(
/*=============*/
	const byte*	b)	/*!< in: pointer to 2 bytes */
{
	ut_ad(b);
	return( ((ulint)(b[0]) << 8)
		+ (ulint)(b[1])
		);
}

/********************************************************//**
The following function is used to convert a 16-bit data item
to the canonical format, for fast bytewise equality test
against memory.
@return	16-bit integer in canonical format */
UNIV_INLINE
ib_uint16_t
mach_encode_2(
/*==========*/
	ulint	n)	/*!< in: integer in machine-dependent format */
{
	ib_uint16_t	ret;
	ut_ad(2 == sizeof ret);
	mach_write_to_2((byte*) &ret, n);
	return(ret);
}
/********************************************************//**
The following function is used to convert a 16-bit data item
from the canonical format, for fast bytewise equality test
against memory.
@return	integer in machine-dependent format */
UNIV_INLINE
ulint
mach_decode_2(
/*==========*/
	ib_uint16_t	n)	/*!< in: 16-bit integer in canonical format */
{
	ut_ad(2 == sizeof n);
	return(mach_read_from_2((const byte*) &n));
}

/*******************************************************//**
The following function is used to store data in 3 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_3(
/*============*/
	byte*	b,	/*!< in: pointer to 3 bytes where to store */
	ulint	n)	/*!< in: ulint integer to be stored */
{
	ut_ad(b);
	ut_ad(n <= 0xFFFFFFUL);

	b[0] = (byte)(n >> 16);
	b[1] = (byte)(n >> 8);
	b[2] = (byte)(n);
}

/********************************************************//**
The following function is used to fetch data from 3 consecutive
bytes. The most significant byte is at the lowest address.
@return	ulint integer */
UNIV_INLINE
ulint
mach_read_from_3(
/*=============*/
	const byte*	b)	/*!< in: pointer to 3 bytes */
{
	ut_ad(b);
	return( ((ulint)(b[0]) << 16)
		+ ((ulint)(b[1]) << 8)
		+ (ulint)(b[2])
		);
}

/*******************************************************//**
The following function is used to store data in four consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_4(
/*============*/
	byte*	b,	/*!< in: pointer to four bytes where to store */
	ulint	n)	/*!< in: ulint integer to be stored */
{
	ut_ad(b);

	b[0] = (byte)(n >> 24);
	b[1] = (byte)(n >> 16);
	b[2] = (byte)(n >> 8);
	b[3] = (byte)n;
}

/********************************************************//**
The following function is used to fetch data from 4 consecutive
bytes. The most significant byte is at the lowest address.
@return	ulint integer */
UNIV_INLINE
ulint
mach_read_from_4(
/*=============*/
	const byte*	b)	/*!< in: pointer to four bytes */
{
	ut_ad(b);
	return( ((ulint)(b[0]) << 24)
		+ ((ulint)(b[1]) << 16)
		+ ((ulint)(b[2]) << 8)
		+ (ulint)(b[3])
		);
}

/*********************************************************//**
Writes a ulint in a compressed form where the first byte codes the
length of the stored ulint. We look at the most significant bits of
the byte. If the most significant bit is zero, it means 1-byte storage,
else if the 2nd bit is 0, it means 2-byte storage, else if 3rd is 0,
it means 3-byte storage, else if 4th is 0, it means 4-byte storage,
else the storage is 5-byte.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_write_compressed(
/*==================*/
	byte*	b,	/*!< in: pointer to memory where to store */
	ulint	n)	/*!< in: ulint integer (< 2^32) to be stored */
{
	ut_ad(b);

	if (n < 0x80UL) {
		mach_write_to_1(b, n);
		return(1);
	} else if (n < 0x4000UL) {
		mach_write_to_2(b, n | 0x8000UL);
		return(2);
	} else if (n < 0x200000UL) {
		mach_write_to_3(b, n | 0xC00000UL);
		return(3);
	} else if (n < 0x10000000UL) {
		mach_write_to_4(b, n | 0xE0000000UL);
		return(4);
	} else {
		mach_write_to_1(b, 0xF0UL);
		mach_write_to_4(b + 1, n);
		return(5);
	}
}

/*********************************************************//**
Returns the size of a ulint when written in the compressed form.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_get_compressed_size(
/*=====================*/
	ulint	n)	/*!< in: ulint integer (< 2^32) to be stored */
{
	if (n < 0x80UL) {
		return(1);
	} else if (n < 0x4000UL) {
		return(2);
	} else if (n < 0x200000UL) {
		return(3);
	} else if (n < 0x10000000UL) {
		return(4);
	} else {
		return(5);
	}
}

/*********************************************************//**
Reads a ulint in a compressed form.
@return	read integer (< 2^32) */
UNIV_INLINE
ulint
mach_read_compressed(
/*=================*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
{
	ulint	flag;

	ut_ad(b);

	flag = mach_read_from_1(b);

	if (flag < 0x80UL) {
		return(flag);
	} else if (flag < 0xC0UL) {
		return(mach_read_from_2(b) & 0x7FFFUL);
	} else if (flag < 0xE0UL) {
		return(mach_read_from_3(b) & 0x3FFFFFUL);
	} else if (flag < 0xF0UL) {
		return(mach_read_from_4(b) & 0x1FFFFFFFUL);
	} else {
		ut_ad(flag == 0xF0UL);
		return(mach_read_from_4(b + 1));
	}
}

/*******************************************************//**
The following function is used to store data in 8 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_8(
/*============*/
	byte*	b,	/*!< in: pointer to 8 bytes where to store */
	dulint	n)	/*!< in: dulint integer to be stored */
{
	ut_ad(b);

	mach_write_to_4(b, ut_dulint_get_high(n));
	mach_write_to_4(b + 4, ut_dulint_get_low(n));
}

/*******************************************************//**
The following function is used to store data in 8 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_ull(
/*===========*/
	byte*		b,	/*!< in: pointer to 8 bytes where to store */
	ib_uint64_t	n)	/*!< in: 64-bit integer to be stored */
{
	ut_ad(b);

	mach_write_to_4(b, (ulint) (n >> 32));
	mach_write_to_4(b + 4, (ulint) n);
}

/********************************************************//**
The following function is used to fetch data from 8 consecutive
bytes. The most significant byte is at the lowest address.
@return	dulint integer */
UNIV_INLINE
dulint
mach_read_from_8(
/*=============*/
	const byte*	b)	/*!< in: pointer to 8 bytes */
{
	ulint	high;
	ulint	low;

	ut_ad(b);

	high = mach_read_from_4(b);
	low = mach_read_from_4(b + 4);

	return(ut_dulint_create(high, low));
}

/********************************************************//**
The following function is used to fetch data from 8 consecutive
bytes. The most significant byte is at the lowest address.
@return	64-bit integer */
UNIV_INLINE
ib_uint64_t
mach_read_ull(
/*==========*/
	const byte*	b)	/*!< in: pointer to 8 bytes */
{
	ib_uint64_t	ull;

	ull = ((ib_uint64_t) mach_read_from_4(b)) << 32;
	ull |= (ib_uint64_t) mach_read_from_4(b + 4);

	return(ull);
}

/*******************************************************//**
The following function is used to store data in 7 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_7(
/*============*/
	byte*	b,	/*!< in: pointer to 7 bytes where to store */
	dulint	n)	/*!< in: dulint integer to be stored */
{
	ut_ad(b);

	mach_write_to_3(b, ut_dulint_get_high(n));
	mach_write_to_4(b + 3, ut_dulint_get_low(n));
}

/********************************************************//**
The following function is used to fetch data from 7 consecutive
bytes. The most significant byte is at the lowest address.
@return	dulint integer */
UNIV_INLINE
dulint
mach_read_from_7(
/*=============*/
	const byte*	b)	/*!< in: pointer to 7 bytes */
{
	ulint	high;
	ulint	low;

	ut_ad(b);

	high = mach_read_from_3(b);
	low = mach_read_from_4(b + 3);

	return(ut_dulint_create(high, low));
}

/*******************************************************//**
The following function is used to store data in 6 consecutive
bytes. We store the most significant byte to the lowest address. */
UNIV_INLINE
void
mach_write_to_6(
/*============*/
	byte*	b,	/*!< in: pointer to 6 bytes where to store */
	dulint	n)	/*!< in: dulint integer to be stored */
{
	ut_ad(b);

	mach_write_to_2(b, ut_dulint_get_high(n));
	mach_write_to_4(b + 2, ut_dulint_get_low(n));
}

/********************************************************//**
The following function is used to fetch data from 6 consecutive
bytes. The most significant byte is at the lowest address.
@return	dulint integer */
UNIV_INLINE
dulint
mach_read_from_6(
/*=============*/
	const byte*	b)	/*!< in: pointer to 6 bytes */
{
	ulint	high;
	ulint	low;

	ut_ad(b);

	high = mach_read_from_2(b);
	low = mach_read_from_4(b + 2);

	return(ut_dulint_create(high, low));
}

/*********************************************************//**
Writes a dulint in a compressed form (5..9 bytes).
@return	size in bytes */
UNIV_INLINE
ulint
mach_dulint_write_compressed(
/*=========================*/
	byte*	b,	/*!< in: pointer to memory where to store */
	dulint	n)	/*!< in: dulint integer to be stored */
{
	ulint	size;

	ut_ad(b);

	size = mach_write_compressed(b, ut_dulint_get_high(n));
	mach_write_to_4(b + size, ut_dulint_get_low(n));

	return(size + 4);
}

/*********************************************************//**
Returns the size of a dulint when written in the compressed form.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_dulint_get_compressed_size(
/*============================*/
	dulint	 n)	/*!< in: dulint integer to be stored */
{
	return(4 + mach_get_compressed_size(ut_dulint_get_high(n)));
}

/*********************************************************//**
Reads a dulint in a compressed form.
@return	read dulint */
UNIV_INLINE
dulint
mach_dulint_read_compressed(
/*========================*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
{
	ulint	high;
	ulint	low;
	ulint	size;

	ut_ad(b);

	high = mach_read_compressed(b);

	size = mach_get_compressed_size(high);

	low = mach_read_from_4(b + size);

	return(ut_dulint_create(high, low));
}

/*********************************************************//**
Writes a dulint in a compressed form (1..11 bytes).
@return	size in bytes */
UNIV_INLINE
ulint
mach_dulint_write_much_compressed(
/*==============================*/
	byte*	b,	/*!< in: pointer to memory where to store */
	dulint	n)	/*!< in: dulint integer to be stored */
{
	ulint	size;

	ut_ad(b);

	if (ut_dulint_get_high(n) == 0) {
		return(mach_write_compressed(b, ut_dulint_get_low(n)));
	}

	*b = (byte)0xFF;
	size = 1 + mach_write_compressed(b + 1, ut_dulint_get_high(n));

	size += mach_write_compressed(b + size, ut_dulint_get_low(n));

	return(size);
}

/*********************************************************//**
Returns the size of a dulint when written in the compressed form.
@return	compressed size in bytes */
UNIV_INLINE
ulint
mach_dulint_get_much_compressed_size(
/*=================================*/
	dulint	 n)	/*!< in: dulint integer to be stored */
{
	if (0 == ut_dulint_get_high(n)) {
		return(mach_get_compressed_size(ut_dulint_get_low(n)));
	}

	return(1 + mach_get_compressed_size(ut_dulint_get_high(n))
	       + mach_get_compressed_size(ut_dulint_get_low(n)));
}

/*********************************************************//**
Reads a dulint in a compressed form.
@return	read dulint */
UNIV_INLINE
dulint
mach_dulint_read_much_compressed(
/*=============================*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
{
	ulint	high;
	ulint	low;
	ulint	size;

	ut_ad(b);

	if (*b != (byte)0xFF) {
		high = 0;
		size = 0;
	} else {
		high = mach_read_compressed(b + 1);

		size = 1 + mach_get_compressed_size(high);
	}

	low = mach_read_compressed(b + size);

	return(ut_dulint_create(high, low));
}
#ifndef UNIV_HOTBACKUP
/*********************************************************//**
Reads a double. It is stored in a little-endian format.
@return	double read */
UNIV_INLINE
double
mach_double_read(
/*=============*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
{
	double	d;
	ulint	i;
	byte*	ptr;

	ptr = (byte*)&d;

	for (i = 0; i < sizeof(double); i++) {
#ifdef WORDS_BIGENDIAN
		ptr[sizeof(double) - i - 1] = b[i];
#else
		ptr[i] = b[i];
#endif
	}

	return(d);
}

/*********************************************************//**
Writes a pointer to a double. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_double_ptr_write(
/*==================*/
	byte*		b,	/*!< in: pointer to memory where to write */
	const byte*	ptr)	/*!< in: pointer to a double */
{
	ulint	i;

	for (i = 0; i < sizeof(double); i++) {
#ifdef WORDS_BIGENDIAN
		b[i] = ptr[sizeof(double) - i - 1];
#else
		b[i] = ptr[i];
#endif
	}
}

/*********************************************************//**
Writes a double. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_double_write(
/*==============*/
	byte*	b,	/*!< in: pointer to memory where to write */
	double	d)	/*!< in: double */
{
	mach_double_ptr_write(b, (byte*) &d);
}

/*************************************************************
Reads a float. It is stored in a little-endian format.
@return	float read */
UNIV_INLINE
float
mach_float_read(
/*============*/
	const byte*	b)	/*!< in: pointer to memory from where to read */
{
	float	d;
	ulint	i;
	byte*	ptr;

	ptr = (byte*)&d;

	for (i = 0; i < sizeof(float); i++) {
#ifdef WORDS_BIGENDIAN
		ptr[sizeof(float) - i - 1] = b[i];
#else
		ptr[i] = b[i];
#endif
	}

	return(d);
}

/*********************************************************//**
Writes a pointer to float. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_float_ptr_write(
/*=================*/
	byte*		b,	/*!< in: pointer to memory where to write */
	const byte*	ptr)	/*!< in: pointer to float */
{
	ulint	i;

	for (i = 0; i < sizeof(float); i++) {
#ifdef WORDS_BIGENDIAN
		b[i] = ptr[sizeof(float) - i - 1];
#else
		b[i] = ptr[i];
#endif
	}
}

/*********************************************************//**
Writes a float. It is stored in a little-endian format. */
UNIV_INLINE
void
mach_float_write(
/*=============*/
	byte*	b,	/*!< in: pointer to memory where to write */
	float	d)	/*!< in: float */
{
	mach_float_ptr_write(b, (byte*)&d);
}

/*************************************************************
Reads a ulint stored in the little-endian format.
@return	unsigned long int */
UNIV_INLINE
ulint
mach_read_from_n_little_endian(
/*===========================*/
	const byte*	buf,		/*!< in: from where to read */
	ulint		buf_size)	/*!< in: from how many bytes to read */
{
	ulint	n	= 0;
	const byte*	ptr;

	ut_ad(buf_size <= sizeof(ulint));
	ut_ad(buf_size > 0);

	ptr = buf + buf_size;

	for (;;) {
		ptr--;

		n = n << 8;

		n += (ulint)(*ptr);

		if (ptr == buf) {
			break;
		}
	}

	return(n);
}

/*********************************************************//**
Writes a ulint in the little-endian format. */
UNIV_INLINE
void
mach_write_to_n_little_endian(
/*==========================*/
	byte*	dest,		/*!< in: where to write */
	ulint	dest_size,	/*!< in: into how many bytes to write */
	ulint	n)		/*!< in: unsigned long int to write */
{
	byte*	end;

	ut_ad(dest_size <= sizeof(ulint));
	ut_ad(dest_size > 0);

	end = dest + dest_size;

	for (;;) {
		*dest = (byte)(n & 0xFF);

		n = n >> 8;

		dest++;

		if (dest == end) {
			break;
		}
	}

	ut_ad(n == 0);
}

/*********************************************************//**
Reads a ulint stored in the little-endian format.
@return	unsigned long int */
UNIV_INLINE
ulint
mach_read_from_2_little_endian(
/*===========================*/
	const byte*	buf)		/*!< in: from where to read */
{
	return((ulint)(*buf) + ((ulint)(*(buf + 1))) * 256);
}

/*********************************************************//**
Writes a ulint in the little-endian format. */
UNIV_INLINE
void
mach_write_to_2_little_endian(
/*==========================*/
	byte*	dest,		/*!< in: where to write */
	ulint	n)		/*!< in: unsigned long int to write */
{
	ut_ad(n < 256 * 256);

	*dest = (byte)(n & 0xFFUL);

	n = n >> 8;
	dest++;

	*dest = (byte)(n & 0xFFUL);
}

/*********************************************************//**
Swap byte ordering. */
UNIV_INLINE
void
mach_swap_byte_order(
/*=================*/
	byte*		dest,		/*!< out: where to write */
	const byte*	from,		/*!< in: where to read from */
	ulint		len)		/*!< in: length of src */
{
	ut_ad(len > 0);
	ut_ad(len <= 8);

	dest += len;

	switch (len & 0x7) {
	case 0: *--dest = *from++;
	case 7: *--dest = *from++;
	case 6: *--dest = *from++;
	case 5: *--dest = *from++;
	case 4: *--dest = *from++;
	case 3: *--dest = *from++;
	case 2: *--dest = *from++;
	case 1: *--dest = *from;
	}
}

/*************************************************************
Convert integral type from storage byte order (big-endian) to
host byte order.
@return	value in host byte order */
UNIV_INLINE
void
mach_read_int_type(
/*===============*/
	void*		dst,		/*!< out: where to write */
	const byte*	src,		/*!< in: where to read from */
	ulint		len,		/*!< in: length of src */
	ibool		usign)		/*!< in: signed or unsigned flag */
{
#ifdef WORDS_BIGENDIAN
	memcpy(dst, src, len);
#else
	mach_swap_byte_order(dst, src, len);

	if (usign) {

		*(((byte*) dst) + len - 1) ^= 0x80;
	}
#endif
}

/*************************************************************
Convert integral type from host byte order (big-endian) storage
byte order. */
UNIV_INLINE
void
mach_write_int_type(
/*================*/
	byte*		dest,		/*!< in: where to write*/
	const byte*	src,		/*!< in: where to read from */
	ulint		len,		/*!< in: length of src */
	ibool		usign)		/*!< in: signed or unsigned flag */
{
#ifdef WORDS_BIGENDIAN
	memcpy(dest, src, len);
#else
	mach_swap_byte_order(dest, src, len);

	if (usign) {

		*dest ^=  0x80;
	}
#endif
}

/*************************************************************
Convert a 64 bit big endian unsigned integral type to the host
byte order.
@return	value in host byte order */
UNIV_INLINE
ib_uint64_t
mach_read_uint64(
/*=============*/
	const byte* 	src)		/*!< in: where to read from */
{
	ib_uint64_t	dst;

	mach_read_int_type(&dst, src, sizeof(dst), TRUE);

	return(dst);
}

/*************************************************************
Convert a 64 bit big endian signed integral type to the host
byte order.
@return	value in host byte order */
UNIV_INLINE
ib_int64_t
mach_read_int64(
/*============*/
	const byte*	src)		/*!< in: where to read from */
{
	ib_uint64_t	dst;

	mach_read_int_type(&dst, src, sizeof(dst), FALSE);

	return(dst);
}

/*************************************************************
Convert a 32 bit big endian unsigned integral type to the host
byte order.
@return	value in host byte order */
UNIV_INLINE
ib_uint32_t
mach_read_uint32(
/*=============*/
	const byte* 	src)		/*!< in: where to read from */
{
	ib_uint32_t	dst;
       
	mach_read_int_type(&dst, src, sizeof(dst), TRUE);

	return(dst);
}

/*************************************************************
Convert a 32 bit big endian signed integral type to the host
byte order.
@return	value in host byte order */
UNIV_INLINE
ib_int32_t
mach_read_int32(
/*============*/
	const byte*	src)		/*!< in: where to read from */
{
	ib_int32_t	dst;

	mach_read_int_type(&dst, src, sizeof(dst), FALSE);

	return(dst);
}

/*************************************************************
Convert a 64 bit unsigned integral type to big endian from host
byte order. */
UNIV_INLINE
void
mach_write_uint64(
/*==============*/
	byte*		dest,		/*!< out: where to write */
	ib_uint64_t	n)		/*!< in: where to read from */
{
	ut_ad(dest != NULL);

	mach_write_int_type(dest, (const byte*) &n, sizeof(n), TRUE);
}

/*************************************************************
Convert a 64 bit signed integral type to big endian from host
byte order. */
UNIV_INLINE
void
mach_write_int64(
/*=============*/
	byte*		dest,		/*!< out: where to write */
	ib_int64_t	n)		/*!< in: where to read from */
{
	mach_write_int_type(dest, (const byte*) &n, sizeof(n), FALSE);
}

/*************************************************************
Convert a 32 bit unsigned integral type to big endian from host
byte order. */
UNIV_INLINE
void
mach_write_uint32(
/*==============*/
	byte*		dest,		/*!< out: where to write */
	ib_uint32_t	n)		/*!< in: where to read from */
{
	mach_write_int_type(dest, (const byte*) &n, sizeof(n), TRUE);
}

/*************************************************************
Convert a 32 bit signed integral type to big endian from host
byte order. */
UNIV_INLINE
void
mach_write_int32(
/*=============*/
	byte*		dest,		/*!< out: where to write */
	ib_int32_t	n)		/*!< in: where to read from */
{
	mach_write_int_type(dest, (const byte*) &n, sizeof(n), FALSE);
}

#endif /* !UNIV_HOTBACKUP */
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/dyn0dyn.h
The dynamically allocated array

Created 2/5/1996 Heikki Tuuri
*******************************************************/

#ifndef dyn0dyn_h
#define dyn0dyn_h

#include "univ.i"
#include "ut0lst.h"
#include "mem0mem.h"

/** A block in a dynamically allocated array */
typedef struct dyn_block_struct		dyn_block_t;
/** Dynamically allocated array */
typedef dyn_block_t			dyn_array_t;


/** This is the initial 'payload' size of a dynamic array;
this must be > MLOG_BUF_MARGIN + 30! */
#define	DYN_ARRAY_DATA_SIZE	512

/*********************************************************************//**
Initializes a dynamic array.
@return	initialized dyn array */
UNIV_INLINE
dyn_array_t*
dyn_array_create(
/*=============*/
	dyn_array_t*	arr);	/*!< in: pointer to a memory buffer of
				size sizeof(dyn_array_t) */
/************************************************************//**
Frees a dynamic array. */
UNIV_INLINE
void
dyn_array_free(
/*===========*/
	dyn_array_t*	arr);	/*!< in: dyn array */
/*********************************************************************//**
Makes room on top of a dyn array and returns a pointer to a buffer in it.
After copying the elements, the caller must close the buffer using
dyn_array_close.
@return	pointer to the buffer */
UNIV_INLINE
byte*
dyn_array_open(
/*===========*/
	dyn_array_t*	arr,	/*!< in: dynamic array */
	ulint		size);	/*!< in: size in bytes of the buffer; MUST be
				smaller than DYN_ARRAY_DATA_SIZE! */
/*********************************************************************//**
Closes the buffer returned by dyn_array_open. */
UNIV_INLINE
void
dyn_array_close(
/*============*/
	dyn_array_t*	arr,	/*!< in: dynamic array */
	byte*		ptr);	/*!< in: buffer space from ptr up was not used */
/*********************************************************************//**
Makes room on top of a dyn array and returns a pointer to
the added element. The caller must copy the element to
the pointer returned.
@return	pointer to the element */
UNIV_INLINE
void*
dyn_array_push(
/*===========*/
	dyn_array_t*	arr,	/*!< in: dynamic array */
	ulint		size);	/*!< in: size in bytes of the element */
/************************************************************//**
Returns pointer to an element in dyn array.
@return	pointer to element */
UNIV_INLINE
void*
dyn_array_get_element(
/*==================*/
	dyn_array_t*	arr,	/*!< in: dyn array */
	ulint		pos);	/*!< in: position of element as bytes
				from array start */
/************************************************************//**
Returns the size of stored data in a dyn array.
@return	data size in bytes */
UNIV_INLINE
ulint
dyn_array_get_data_size(
/*====================*/
	dyn_array_t*	arr);	/*!< in: dyn array */
/************************************************************//**
Gets the first block in a dyn array. */
UNIV_INLINE
dyn_block_t*
dyn_array_get_first_block(
/*======================*/
	dyn_array_t*	arr);	/*!< in: dyn array */
/************************************************************//**
Gets the last block in a dyn array. */
UNIV_INLINE
dyn_block_t*
dyn_array_get_last_block(
/*=====================*/
	dyn_array_t*	arr);	/*!< in: dyn array */
/********************************************************************//**
Gets the next block in a dyn array.
@return	pointer to next, NULL if end of list */
UNIV_INLINE
dyn_block_t*
dyn_array_get_next_block(
/*=====================*/
	dyn_array_t*	arr,	/*!< in: dyn array */
	dyn_block_t*	block);	/*!< in: dyn array block */
/********************************************************************//**
Gets the number of used bytes in a dyn array block.
@return	number of bytes used */
UNIV_INLINE
ulint
dyn_block_get_used(
/*===============*/
	dyn_block_t*	block);	/*!< in: dyn array block */
/********************************************************************//**
Gets pointer to the start of data in a dyn array block.
@return	pointer to data */
UNIV_INLINE
byte*
dyn_block_get_data(
/*===============*/
	dyn_block_t*	block);	/*!< in: dyn array block */
/********************************************************//**
Pushes n bytes to a dyn array. */
UNIV_INLINE
void
dyn_push_string(
/*============*/
	dyn_array_t*	arr,	/*!< in: dyn array */
	const byte*	str,	/*!< in: string to write */
	ulint		len);	/*!< in: string length */

/*#################################################################*/

/** @brief A block in a dynamically allocated array.
NOTE! Do not access the fields of the struct directly: the definition
appears here only for the compiler to know its size! */
struct dyn_block_struct{
	mem_heap_t*	heap;	/*!< in the first block this is != NULL
				if dynamic allocation has been needed */
	ulint		used;	/*!< number of data bytes used in this block;
				DYN_BLOCK_FULL_FLAG is set when the block
				becomes full */
	byte		data[DYN_ARRAY_DATA_SIZE];
				/*!< storage for array elements */
	UT_LIST_BASE_NODE_T(dyn_block_t) base;
				/*!< linear list of dyn blocks: this node is
				used only in the first block */
	UT_LIST_NODE_T(dyn_block_t) list;
				/*!< linear list node: used in all blocks */
#ifdef UNIV_DEBUG
	ulint		buf_end;/*!< only in the debug version: if dyn
				array is opened, this is the buffer
				end offset, else this is 0 */
	ulint		magic_n;/*!< magic number (DYN_BLOCK_MAGIC_N) */
#endif
};


#ifndef UNIV_NONINL
#include "dyn0dyn.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/dyn0dyn.ic
The dynamically allocated array

Created 2/5/1996 Heikki Tuuri
*******************************************************/

/** Value of dyn_block_struct::magic_n */
#define DYN_BLOCK_MAGIC_N	375767
/** Flag for dyn_block_struct::used that indicates a full block */
#define DYN_BLOCK_FULL_FLAG	0x1000000UL

/************************************************************//**
Adds a new block to a dyn array.
@return	created block */
UNIV_INTERN
dyn_block_t*
dyn_array_add_block(
/*================*/
	dyn_array_t*	arr);	/*!< in: dyn array */


/************************************************************//**
Gets the first block in a dyn array. */
UNIV_INLINE
dyn_block_t*
dyn_array_get_first_block(
/*======================*/
	dyn_array_t*	arr)	/*!< in: dyn array */
{
	return(arr);
}

/************************************************************//**
Gets the last block in a dyn array. */
UNIV_INLINE
dyn_block_t*
dyn_array_get_last_block(
/*=====================*/
	dyn_array_t*	arr)	/*!< in: dyn array */
{
	if (arr->heap == NULL) {

		return(arr);
	}

	return(UT_LIST_GET_LAST(arr->base));
}

/********************************************************************//**
Gets the next block in a dyn array.
@return	pointer to next, NULL if end of list */
UNIV_INLINE
dyn_block_t*
dyn_array_get_next_block(
/*=====================*/
	dyn_array_t*	arr,	/*!< in: dyn array */
	dyn_block_t*	block)	/*!< in: dyn array block */
{
	ut_ad(arr && block);

	if (arr->heap == NULL) {
		ut_ad(arr == block);

		return(NULL);
	}

	return(UT_LIST_GET_NEXT(list, block));
}

/********************************************************************//**
Gets the number of used bytes in a dyn array block.
@return	number of bytes used */
UNIV_INLINE
ulint
dyn_block_get_used(
/*===============*/
	dyn_block_t*	block)	/*!< in: dyn array block */
{
	ut_ad(block);

	return((block->used) & ~DYN_BLOCK_FULL_FLAG);
}

/********************************************************************//**
Gets pointer to the start of data in a dyn array block.
@return	pointer to data */
UNIV_INLINE
byte*
dyn_block_get_data(
/*===============*/
	dyn_block_t*	block)	/*!< in: dyn array block */
{
	ut_ad(block);

	return(block->data);
}

/*********************************************************************//**
Initializes a dynamic array.
@return	initialized dyn array */
UNIV_INLINE
dyn_array_t*
dyn_array_create(
/*=============*/
	dyn_array_t*	arr)	/*!< in: pointer to a memory buffer of
				size sizeof(dyn_array_t) */
{
	ut_ad(arr);
#if DYN_ARRAY_DATA_SIZE >= DYN_BLOCK_FULL_FLAG
# error "DYN_ARRAY_DATA_SIZE >= DYN_BLOCK_FULL_FLAG"
#endif

	arr->heap = NULL;
	arr->used = 0;

#ifdef UNIV_DEBUG
	arr->buf_end = 0;
	arr->magic_n = DYN_BLOCK_MAGIC_N;
#endif
	return(arr);
}

/************************************************************//**
Frees a dynamic array. */
UNIV_INLINE
void
dyn_array_free(
/*===========*/
	dyn_array_t*	arr)	/*!< in: dyn array */
{
	if (arr->heap != NULL) {
		mem_heap_free(arr->heap);
	}

#ifdef UNIV_DEBUG
	arr->magic_n = 0;
#endif
}

/*********************************************************************//**
Makes room on top of a dyn array and returns a pointer to the added element.
The caller must copy the element to the pointer returned.
@return	pointer to the element */
UNIV_INLINE
void*
dyn_array_push(
/*===========*/
	dyn_array_t*	arr,	/*!< in: dynamic array */
	ulint		size)	/*!< in: size in bytes of the element */
{
	dyn_block_t*	block;
	ulint		used;

	ut_ad(arr);
	ut_ad(arr->magic_n == DYN_BLOCK_MAGIC_N);
	ut_ad(size <= DYN_ARRAY_DATA_SIZE);
	ut_ad(size);

	block = arr;
	used = block->used;

	if (used + size > DYN_ARRAY_DATA_SIZE) {
		/* Get the last array block */

		block = dyn_array_get_last_block(arr);
		used = block->used;

		if (used + size > DYN_ARRAY_DATA_SIZE) {
			block = dyn_array_add_block(arr);
			used = block->used;
		}
	}

	block->used = used + size;
	ut_ad(block->used <= DYN_ARRAY_DATA_SIZE);

	return((block->data) + used);
}

/*********************************************************************//**
Makes room on top of a dyn array and returns a pointer to a buffer in it.
After copying the elements, the caller must close the buffer using
dyn_array_close.
@return	pointer to the buffer */
UNIV_INLINE
byte*
dyn_array_open(
/*===========*/
	dyn_array_t*	arr,	/*!< in: dynamic array */
	ulint		size)	/*!< in: size in bytes of the buffer; MUST be
				smaller than DYN_ARRAY_DATA_SIZE! */
{
	dyn_block_t*	block;
	ulint		used;

	ut_ad(arr);
	ut_ad(arr->magic_n == DYN_BLOCK_MAGIC_N);
	ut_ad(size <= DYN_ARRAY_DATA_SIZE);
	ut_ad(size);

	block = arr;
	used = block->used;

	if (used + size > DYN_ARRAY_DATA_SIZE) {
		/* Get the last array block */

		block = dyn_array_get_last_block(arr);
		used = block->used;

		if (used + size > DYN_ARRAY_DATA_SIZE) {
			block = dyn_array_add_block(arr);
			used = block->used;
			ut_a(size <= DYN_ARRAY_DATA_SIZE);
		}
	}

	ut_ad(block->used <= DYN_ARRAY_DATA_SIZE);
#ifdef UNIV_DEBUG
	ut_ad(arr->buf_end == 0);

	arr->buf_end = used + size;
#endif
	return((block->data) + used);
}

/*********************************************************************//**
Closes the buffer returned by dyn_array_open. */
UNIV_INLINE
void
dyn_array_close(
/*============*/
	dyn_array_t*	arr,	/*!< in: dynamic array */
	byte*		ptr)	/*!< in: buffer space from ptr up was not used */
{
	dyn_block_t*	block;

	ut_ad(arr);
	ut_ad(arr->magic_n == DYN_BLOCK_MAGIC_N);

	block = dyn_array_get_last_block(arr);

	ut_ad(arr->buf_end + block->data >= ptr);

	block->used = ptr - block->data;

	ut_ad(block->used <= DYN_ARRAY_DATA_SIZE);

#ifdef UNIV_DEBUG
	arr->buf_end = 0;
#endif
}

/************************************************************//**
Returns pointer to an element in dyn array.
@return	pointer to element */
UNIV_INLINE
void*
dyn_array_get_element(
/*==================*/
	dyn_array_t*	arr,	/*!< in: dyn array */
	ulint		pos)	/*!< in: position of element as bytes
				from array start */
{
	dyn_block_t*	block;
	ulint		used;

	ut_ad(arr);
	ut_ad(arr->magic_n == DYN_BLOCK_MAGIC_N);

	/* Get the first array block */
	block = dyn_array_get_first_block(arr);

	if (arr->heap != NULL) {
		used = dyn_block_get_used(block);

		while (pos >= used) {
			pos -= used;
			block = UT_LIST_GET_NEXT(list, block);
			ut_ad(block);

			used = dyn_block_get_used(block);
		}
	}

	ut_ad(block);
	ut_ad(dyn_block_get_used(block) >= pos);

	return(block->data + pos);
}

/************************************************************//**
Returns the size of stored data in a dyn array.
@return	data size in bytes */
UNIV_INLINE
ulint
dyn_array_get_data_size(
/*====================*/
	dyn_array_t*	arr)	/*!< in: dyn array */
{
	dyn_block_t*	block;
	ulint		sum	= 0;

	ut_ad(arr);
	ut_ad(arr->magic_n == DYN_BLOCK_MAGIC_N);

	if (arr->heap == NULL) {

		return(arr->used);
	}

	/* Get the first array block */
	block = dyn_array_get_first_block(arr);

	while (block != NULL) {
		sum += dyn_block_get_used(block);
		block = dyn_array_get_next_block(arr, block);
	}

	return(sum);
}

/********************************************************//**
Pushes n bytes to a dyn array. */
UNIV_INLINE
void
dyn_push_string(
/*============*/
	dyn_array_t*	arr,	/*!< in: dyn array */
	const byte*	str,	/*!< in: string to write */
	ulint		len)	/*!< in: string length */
{
	ulint	n_copied;

	while (len > 0) {
		if (len > DYN_ARRAY_DATA_SIZE) {
			n_copied = DYN_ARRAY_DATA_SIZE;
		} else {
			n_copied = len;
		}

		memcpy(dyn_array_push(arr, n_copied), str, n_copied);

		str += n_copied;
		len -= n_copied;
	}
}


=== IMPLEMENTATION ===

/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/***************************************************************//**
@file ut/ut0byte.c
Byte utilities

Created 5/11/1994 Heikki Tuuri
********************************************************************/

#include "ut0byte.h"

#ifdef UNIV_NONINL
#include "ut0byte.ic"
#endif

/** Zero value for a dulint */
UNIV_INTERN const dulint	ut_dulint_zero	= {0, 0};

/** Maximum value for a dulint */
UNIV_INTERN const dulint	ut_dulint_max	= {0xFFFFFFFFUL, 0xFFFFFFFFUL};

#ifdef notdefined /* unused code */
#include "ut0sort.h"

/************************************************************//**
Sort function for dulint arrays. */
UNIV_INTERN
void
ut_dulint_sort(
/*===========*/
	dulint*	arr,	/*!< in/out: array to be sorted */
	dulint*	aux_arr,/*!< in/out: auxiliary array (same size as arr) */
	ulint	low,	/*!< in: low bound of sort interval, inclusive */
	ulint	high)	/*!< in: high bound of sort interval, noninclusive */
{
	UT_SORT_FUNCTION_BODY(ut_dulint_sort, arr, aux_arr, low, high,
			      ut_dulint_cmp);
}
#endif /* notdefined */
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*****************************************************************//**
@file ut/ut0dbg.c
Debug utilities for Innobase.

Created 1/30/1994 Heikki Tuuri
**********************************************************************/

#include "univ.i"
#include "ut0dbg.h"

#if defined(__GNUC__) && (__GNUC__ > 2)
#else
/** This is used to eliminate compiler warnings */
UNIV_INTERN ulint	ut_dbg_zero	= 0;
#endif

#if defined(UNIV_SYNC_DEBUG) || !defined(UT_DBG_USE_ABORT)
/** If this is set to TRUE by ut_dbg_assertion_failed(), all threads
will stop at the next ut_a() or ut_ad(). */
UNIV_INTERN ibool	ut_dbg_stop_threads	= FALSE;
#endif
#ifdef __NETWARE__
/** Flag for ignoring further assertion failures.  This is set to TRUE
when on NetWare there happens an InnoDB assertion failure or other
fatal error condition that requires an immediate shutdown. */
UNIV_INTERN ibool panic_shutdown = FALSE;
#elif !defined(UT_DBG_USE_ABORT)
/** A null pointer that will be dereferenced to trigger a memory trap */
UNIV_INTERN ulint*	ut_dbg_null_ptr		= NULL;
#endif

/*************************************************************//**
Report a failed assertion. */
UNIV_INTERN
void
ut_dbg_assertion_failed(
/*====================*/
	const char* expr,	/*!< in: the failed assertion (optional) */
	const char* file,	/*!< in: source file containing the assertion */
	ulint line)		/*!< in: line number of the assertion */
{
	ut_print_timestamp(ib_stream);
#ifdef UNIV_HOTBACKUP
	ib_logger(ib_stream, "  InnoDB: Assertion failure in file %s line %lu\n",
		file, line);
#else /* UNIV_HOTBACKUP */
	ib_logger(ib_stream,
		"  InnoDB: Assertion failure in thread %lu"
		" in file %s line %lu\n",
		os_thread_pf(os_thread_get_curr_id()), file, line);
#endif /* UNIV_HOTBACKUP */
	if (expr) {
		ib_logger(ib_stream,
			"InnoDB: Failing assertion: %s\n", expr);
	}

	ib_logger(ib_stream,
		"InnoDB: We intentionally generate a memory trap.\n"
		"InnoDB: Submit a detailed bug report, "
		"check the InnoDB website for details\n"
		"InnoDB: If you get repeated assertion failures"
		" or crashes, even\n"
		"InnoDB: immediately after the server startup, there may be\n"
		"InnoDB: corruption in the InnoDB tablespace. Please refer to\n"
		"InnoDB: the InnoDB website for details\n"
		"InnoDB: about forcing recovery.\n");
#if defined(UNIV_SYNC_DEBUG) || !defined(UT_DBG_USE_ABORT)
	ut_dbg_stop_threads = TRUE;
#endif
}

#ifdef __NETWARE__
/*************************************************************//**
Shut down InnoDB after assertion failure. */
UNIV_INTERN
void
ut_dbg_panic(void)
/*==============*/
{
	if (!panic_shutdown) {
		panic_shutdown = TRUE;
		innobase_shutdown(IB_SHUTDOWN_NORMAL);
	}
	exit(1);
}
#else /* __NETWARE__ */
# if defined(UNIV_SYNC_DEBUG) || !defined(UT_DBG_USE_ABORT)
/*************************************************************//**
Stop a thread after assertion failure. */
UNIV_INTERN
void
ut_dbg_stop_thread(
/*===============*/
	const char*	file,
	ulint		line)
{
#ifndef UNIV_HOTBACKUP
	ib_logger(ib_stream, "InnoDB: Thread %lu stopped in file %s line %lu\n",
		os_thread_pf(os_thread_get_curr_id()), file, line);
	os_thread_sleep(1000000000);
#endif /* !UNIV_HOTBACKUP */
}
# endif
#endif /* __NETWARE__ */

#ifdef UNIV_COMPILE_TEST_FUNCS

#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef timersub
#define timersub(a, b, r)						\
	do {								\
		(r)->tv_sec = (a)->tv_sec - (b)->tv_sec;		\
		(r)->tv_usec = (a)->tv_usec - (b)->tv_usec;		\
		if ((r)->tv_usec < 0) {					\
			(r)->tv_sec--;					\
			(r)->tv_usec += 1000000;			\
		}							\
	} while (0)
#endif /* timersub */

/*******************************************************************//**
Resets a speedo (records the current time in it). */
UNIV_INTERN
void
speedo_reset(
/*=========*/
	speedo_t*	speedo)	/*!< out: speedo */
{
	gettimeofday(&speedo->tv, NULL);

	getrusage(RUSAGE_SELF, &speedo->ru);
}

/*******************************************************************//**
Shows the time elapsed and usage statistics since the last reset of a
speedo. */
UNIV_INTERN
void
speedo_show(
/*========*/
	const speedo_t*	speedo)	/*!< in: speedo */
{
	struct rusage	ru_now;
	struct timeval	tv_now;
	struct timeval	tv_diff;

	getrusage(RUSAGE_SELF, &ru_now);

	gettimeofday(&tv_now, NULL);

#define PRINT_TIMEVAL(prefix, tvp)		\
	ib_logger(ib_stream, "%s% 5ld.%06ld sec\n",	\
		prefix, (tvp)->tv_sec, (tvp)->tv_usec)

	timersub(&tv_now, &speedo->tv, &tv_diff);
	PRINT_TIMEVAL("real", &tv_diff);

	timersub(&ru_now.ru_utime, &speedo->ru.ru_utime, &tv_diff);
	PRINT_TIMEVAL("user", &tv_diff);

	timersub(&ru_now.ru_stime, &speedo->ru.ru_stime, &tv_diff);
	PRINT_TIMEVAL("sys ", &tv_diff);
}

#endif /* UNIV_COMPILE_TEST_FUNCS */
/*****************************************************************************

Copyright (c) 2006, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file ut/ut0list.c
A double-linked list

Created 4/26/2006 Osku Salerma
************************************************************************/

#include "ut0list.h"
#ifdef UNIV_NONINL
#include "ut0list.ic"
#endif

/****************************************************************//**
Create a new list.
@return	list */
UNIV_INTERN
ib_list_t*
ib_list_create(void)
/*=================*/
{
	ib_list_t*	list = mem_alloc(sizeof(ib_list_t));

	list->first = NULL;
	list->last = NULL;
	list->is_heap_list = FALSE;

	return(list);
}

/****************************************************************//**
Free a list. */
UNIV_INTERN
void
ib_list_free(
/*=========*/
	ib_list_t*	list)	/*!< in: list */
{
	ut_a(!list->is_heap_list);

	/* We don't check that the list is empty because it's entirely valid
	to e.g. have all the nodes allocated from a single heap that is then
	freed after the list itself is freed. */

	mem_free(list);
}

/****************************************************************//**
Add the data to the end of the list.
@return	new list node */
UNIV_INTERN
ib_list_node_t*
ib_list_add_last(
/*=============*/
	ib_list_t*	list,	/*!< in: list */
	void*		data,	/*!< in: data */
	mem_heap_t*	heap)	/*!< in: memory heap to use */
{
	return(ib_list_add_after(list, ib_list_get_last(list), data, heap));
}

/****************************************************************//**
Add the data after the indicated node.
@return	new list node */
UNIV_INTERN
ib_list_node_t*
ib_list_add_after(
/*==============*/
	ib_list_t*	list,		/*!< in: list */
	ib_list_node_t*	prev_node,	/*!< in: node preceding new node (can
					be NULL) */
	void*		data,		/*!< in: data */
	mem_heap_t*	heap)		/*!< in: memory heap to use */
{
	ib_list_node_t*	node = mem_heap_alloc(heap, sizeof(ib_list_node_t));

	node->data = data;

	if (!list->first) {
		/* Empty list. */

		ut_a(!prev_node);

		node->prev = NULL;
		node->next = NULL;

		list->first = node;
		list->last = node;
	} else if (!prev_node) {
		/* Start of list. */

		node->prev = NULL;
		node->next = list->first;

		list->first->prev = node;

		list->first = node;
	} else {
		/* Middle or end of list. */

		node->prev = prev_node;
		node->next = prev_node->next;

		prev_node->next = node;

		if (node->next) {
			node->next->prev = node;
		} else {
			list->last = node;
		}
	}

	return(node);
}

/****************************************************************//**
Remove the node from the list. */
UNIV_INTERN
void
ib_list_remove(
/*===========*/
	ib_list_t*	list,	/*!< in: list */
	ib_list_node_t*	node)	/*!< in: node to remove */
{
	if (node->prev) {
		node->prev->next = node->next;
	} else {
		/* First item in list. */

		ut_ad(list->first == node);

		list->first = node->next;
	}

	if (node->next) {
		node->next->prev = node->prev;
	} else {
		/* Last item in list. */

		ut_ad(list->last == node);

		list->last = node->prev;
	}
}
/*****************************************************************************

Copyright (c) 1994, 2010, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/********************************************************************//**
@file ut/ut0mem.c
Memory primitives

Created 5/11/1994 Heikki Tuuri
*************************************************************************/

#include <errno.h>

#include "ut0mem.h"

#ifdef UNIV_NONINL
#include "ut0mem.ic"
#endif

#ifndef UNIV_HOTBACKUP
# include "os0thread.h"
# include "srv0srv.h"
# include "srv0start.h"

#include <stdlib.h>

/** This struct is placed first in every allocated memory block */
typedef struct ut_mem_block_struct ut_mem_block_t;

/** The total amount of memory currently allocated from the operating
system with os_mem_alloc_large() or malloc().  Does not count malloc()
if srv_use_sys_malloc is set.  Protected by ut_list_mutex. */
UNIV_INTERN ulint		ut_total_allocated_memory	= 0;

/** Mutex protecting ut_total_allocated_memory and ut_mem_block_list */
UNIV_INTERN os_fast_mutex_t	ut_list_mutex;

/** Dynamically allocated memory block */
struct ut_mem_block_struct{
	UT_LIST_NODE_T(ut_mem_block_t) mem_block_list;
			/*!< mem block list node */
	ulint	size;	/*!< size of allocated memory */
	ulint	magic_n;/*!< magic number (UT_MEM_MAGIC_N) */
};

/** The value of ut_mem_block_struct::magic_n.  Used in detecting
memory corruption. */
#define UT_MEM_MAGIC_N	1601650166

/** List of all memory blocks allocated from the operating system
with malloc.  Protected by ut_list_mutex. */
UNIV_STATIC UT_LIST_BASE_NODE_T(ut_mem_block_t)   ut_mem_block_list;

/** Flag: has ut_mem_block_list been initialized? */
UNIV_STATIC ibool  ut_mem_block_list_inited = FALSE;

/** A dummy pointer for generating a null pointer exception in
ut_malloc_low() */
UNIV_STATIC ulint*	ut_mem_null_ptr	= NULL;

/**********************************************************************//**
Reset the variables. */
UNIV_INTERN
void
ut_mem_var_init(void)
/*=================*/
{
	ut_total_allocated_memory = 0;

	memset(&ut_mem_block_list, 0x0, sizeof(ut_mem_block_list));

	memset(&ut_list_mutex, 0x0, sizeof(ut_list_mutex));

	ut_mem_block_list_inited = FALSE;

	ut_mem_null_ptr	= NULL;
}

/**************************************************************************
Initializes the mem block list at database startup. */
UNIV_INTERN
void
ut_mem_init(void)
/*=============*/
{
	ut_a(!srv_was_started);

	if (!ut_mem_block_list_inited) {
		os_fast_mutex_init(&ut_list_mutex);
		UT_LIST_INIT(ut_mem_block_list);
		ut_mem_block_list_inited = TRUE;
	}
}
#endif /* !UNIV_HOTBACKUP */

/**********************************************************************//**
Allocates memory. Sets it also to zero if UNIV_SET_MEM_TO_ZERO is
defined and set_to_zero is TRUE.
@return	own: allocated memory */
UNIV_INTERN
void*
ut_malloc_low(
/*==========*/
	ulint	n,		/*!< in: number of bytes to allocate */
	ibool	set_to_zero,	/*!< in: TRUE if allocated memory should be
				set to zero if UNIV_SET_MEM_TO_ZERO is
				defined */
	ibool	assert_on_error)/*!< in: if TRUE, we crash the server if the
				memory cannot be allocated */
{
#ifndef UNIV_HOTBACKUP
	ulint	retry_count;
	void*	ret;

	if (UNIV_LIKELY(srv_use_sys_malloc)) {
		ret = malloc(n);
		ut_a(ret || !assert_on_error);

#ifdef UNIV_SET_MEM_TO_ZERO
		if (set_to_zero) {
			memset(ret, '\0', n);
			UNIV_MEM_ALLOC(ret, n);
		}
#endif
		return(ret);
	}

	ut_ad((sizeof(ut_mem_block_t) % 8) == 0); /* check alignment ok */
	ut_a(ut_mem_block_list_inited);

	retry_count = 0;
retry:
	os_fast_mutex_lock(&ut_list_mutex);

	ret = malloc(n + sizeof(ut_mem_block_t));

	if (ret == NULL && retry_count < 60) {
		if (retry_count == 0) {
			ut_print_timestamp(ib_stream);

			ib_logger(ib_stream,
				"  InnoDB: Error: cannot allocate"
				" %lu bytes of\n"
				"InnoDB: memory with malloc!"
				" Total allocated memory\n"
				"InnoDB: by InnoDB %lu bytes."
				" Operating system errno: %lu\n"
				"InnoDB: Check if you should"
				" increase the swap file or\n"
				"InnoDB: ulimits of your operating system.\n"
				"InnoDB: On FreeBSD check you"
				" have compiled the OS with\n"
				"InnoDB: a big enough maximum process size.\n"
				"InnoDB: Note that in most 32-bit"
				" computers the process\n"
				"InnoDB: memory space is limited"
				" to 2 GB or 4 GB.\n"
				"InnoDB: We keep retrying"
				" the allocation for 60 seconds...\n",
				(ulong) n, (ulong) ut_total_allocated_memory,
#ifdef __WIN__
				(ulong) GetLastError()
#else
				(ulong) errno
#endif
				);
		}

		os_fast_mutex_unlock(&ut_list_mutex);

		/* Sleep for a second and retry the allocation; maybe this is
		just a temporary shortage of memory */

		os_thread_sleep(1000000);

		retry_count++;

		goto retry;
	}

	if (ret == NULL) {
		os_fast_mutex_unlock(&ut_list_mutex);

		/* Make an intentional seg fault so that we get a stack
		trace */
		/* Intentional segfault on NetWare causes an abend. Avoid this
		by graceful exit handling in ut_a(). */
#if (!defined __NETWARE__)
		if (assert_on_error) {
			ut_print_timestamp(ib_stream);

			ib_logger(ib_stream,
				"  InnoDB: We now intentionally"
				" generate a seg fault so that\n"
				"InnoDB: on Linux we get a stack trace.\n");

			if (*ut_mem_null_ptr) {
				ut_mem_null_ptr = 0;
			}
		} else {
			return(NULL);
		}
#else
		ut_error;
#endif
	}

	if (set_to_zero) {
#ifdef UNIV_SET_MEM_TO_ZERO
		memset(ret, '\0', n + sizeof(ut_mem_block_t));
#endif
	}

	UNIV_MEM_ALLOC(ret, n + sizeof(ut_mem_block_t));

	((ut_mem_block_t*)ret)->size = n + sizeof(ut_mem_block_t);
	((ut_mem_block_t*)ret)->magic_n = UT_MEM_MAGIC_N;

	ut_total_allocated_memory += n + sizeof(ut_mem_block_t);

	UT_LIST_ADD_FIRST(mem_block_list, ut_mem_block_list,
			  ((ut_mem_block_t*)ret));
	os_fast_mutex_unlock(&ut_list_mutex);

	return((void*)((byte*)ret + sizeof(ut_mem_block_t)));
#else /* !UNIV_HOTBACKUP */
	void*	ret = malloc(n);
	ut_a(ret || !assert_on_error);

# ifdef UNIV_SET_MEM_TO_ZERO
	if (set_to_zero) {
		memset(ret, '\0', n);
	}
# endif
	return(ret);
#endif /* !UNIV_HOTBACKUP */
}

/**********************************************************************//**
Allocates memory. Sets it also to zero if UNIV_SET_MEM_TO_ZERO is
defined.
@return	own: allocated memory */
UNIV_INTERN
void*
ut_malloc(
/*======*/
	ulint	n)	/*!< in: number of bytes to allocate */
{
#ifndef UNIV_HOTBACKUP
	return(ut_malloc_low(n, TRUE, TRUE));
#else /* !UNIV_HOTBACKUP */
	return(malloc(n));
#endif /* !UNIV_HOTBACKUP */
}

#ifndef UNIV_HOTBACKUP
/**********************************************************************//**
Tests if malloc of n bytes would succeed. ut_malloc() asserts if memory runs
out. It cannot be used if we want to return an error message. Prints to
ib_stream a message if fails.
@return	TRUE if succeeded */
UNIV_INTERN
ibool
ut_test_malloc(
/*===========*/
	ulint	n)	/*!< in: try to allocate this many bytes */
{
	void*	ret;

	ret = malloc(n);

	if (ret == NULL) {
		ut_print_timestamp(ib_stream);
		ib_logger(ib_stream,
			"  InnoDB: Error: cannot allocate"
			" %lu bytes of memory for\n"
			"InnoDB: a BLOB with malloc! Total allocated memory\n"
			"InnoDB: by InnoDB %lu bytes."
			" Operating system errno: %d\n"
			"InnoDB: Check if you should increase"
			" the swap file or\n"
			"InnoDB: ulimits of your operating system.\n"
			"InnoDB: On FreeBSD check you have"
			" compiled the OS with\n"
			"InnoDB: a big enough maximum process size.\n",
			(ulong) n,
			(ulong) ut_total_allocated_memory,
			(int) errno);
		return(FALSE);
	}

	free(ret);

	return(TRUE);
}
#endif /* !UNIV_HOTBACKUP */

/**********************************************************************//**
Frees a memory block allocated with ut_malloc. */
UNIV_INTERN
void
ut_free(
/*====*/
	void* ptr)  /*!< in, own: memory block */
{
#ifndef UNIV_HOTBACKUP
	ut_mem_block_t* block;

	if (!ptr) {
		return;
	} else if (UNIV_LIKELY(srv_use_sys_malloc)) {
		free(ptr);
		return;
	}

	block = (ut_mem_block_t*)((byte*)ptr - sizeof(ut_mem_block_t));

	os_fast_mutex_lock(&ut_list_mutex);

	ut_a(block->magic_n == UT_MEM_MAGIC_N);
	ut_a(ut_total_allocated_memory >= block->size);

	ut_total_allocated_memory -= block->size;

	UT_LIST_REMOVE(mem_block_list, ut_mem_block_list, block);
	free(block);

	os_fast_mutex_unlock(&ut_list_mutex);
#else /* !UNIV_HOTBACKUP */
	free(ptr);
#endif /* !UNIV_HOTBACKUP */
}

#ifndef UNIV_HOTBACKUP
/**********************************************************************//**
Implements realloc. This is needed by /pars/lexyy.c. Otherwise, you should not
use this function because the allocation functions in mem0mem.h are the
recommended ones in InnoDB.

man realloc in Linux, 2004:

       realloc()  changes the size of the memory block pointed to
       by ptr to size bytes.  The contents will be  unchanged  to
       the minimum of the old and new sizes; newly allocated mem-
       ory will be uninitialized.  If ptr is NULL,  the	 call  is
       equivalent  to malloc(size); if size is equal to zero, the
       call is equivalent to free(ptr).	 Unless ptr is	NULL,  it
       must  have  been	 returned by an earlier call to malloc(),
       calloc() or realloc().

RETURN VALUE
       realloc() returns a pointer to the newly allocated memory,
       which is suitably aligned for any kind of variable and may
       be different from ptr, or NULL if the  request  fails.  If
       size  was equal to 0, either NULL or a pointer suitable to
       be passed to free() is returned.	 If realloc()  fails  the
       original	 block	is  left  untouched  - it is not freed or
       moved.
@return	own: pointer to new mem block or NULL */
UNIV_INTERN
void*
ut_realloc(
/*=======*/
	void*	ptr,	/*!< in: pointer to old block or NULL */
	ulint	size)	/*!< in: desired size */
{
	ut_mem_block_t* block;
	ulint		old_size;
	ulint		min_size;
	void*		new_ptr;

	if (UNIV_LIKELY(srv_use_sys_malloc)) {
		return(realloc(ptr, size));
	}

	if (ptr == NULL) {

		return(ut_malloc(size));
	}

	if (size == 0) {
		ut_free(ptr);

		return(NULL);
	}

	block = (ut_mem_block_t*)((byte*)ptr - sizeof(ut_mem_block_t));

	ut_a(block->magic_n == UT_MEM_MAGIC_N);

	old_size = block->size - sizeof(ut_mem_block_t);

	if (size < old_size) {
		min_size = size;
	} else {
		min_size = old_size;
	}

	new_ptr = ut_malloc(size);

	if (new_ptr == NULL) {

		return(NULL);
	}

	/* Copy the old data from ptr */
	ut_memcpy(new_ptr, ptr, min_size);

	ut_free(ptr);

	return(new_ptr);
}

/**********************************************************************//**
Frees in shutdown all allocated memory not freed yet. */
UNIV_INTERN
void
ut_free_all_mem(void)
/*=================*/
{
	ut_mem_block_t* block;

	/* If the sub-system hasn't been initialized, then ignore request. */
	if (!ut_mem_block_list_inited) {
		return;
	}

	os_fast_mutex_free(&ut_list_mutex);

	while ((block = UT_LIST_GET_FIRST(ut_mem_block_list))) {

		ut_a(block->magic_n == UT_MEM_MAGIC_N);
		ut_a(ut_total_allocated_memory >= block->size);

		ut_total_allocated_memory -= block->size;

		UT_LIST_REMOVE(mem_block_list, ut_mem_block_list, block);
		free(block);
	}

	if (ut_total_allocated_memory != 0) {
		ib_logger(ib_stream,
			"InnoDB: Warning: after shutdown"
			" total allocated memory is %lu\n",
			(ulong) ut_total_allocated_memory);
	}

	ut_mem_block_list_inited = FALSE;
}
#endif /* !UNIV_HOTBACKUP */

/**********************************************************************//**
Copies up to size - 1 characters from the NUL-terminated string src to
dst, NUL-terminating the result. Returns strlen(src), so truncation
occurred if the return value >= size.
@return	strlen(src) */
UNIV_INTERN
ulint
ut_strlcpy(
/*=======*/
	char*		dst,	/*!< in: destination buffer */
	const char*	src,	/*!< in: source buffer */
	ulint		size)	/*!< in: size of destination buffer */
{
	ulint	src_size = strlen(src);

	if (size != 0) {
		ulint	n = ut_min(src_size, size - 1);

		memcpy(dst, src, n);
		dst[n] = '\0';
	}

	return(src_size);
}

/**********************************************************************//**
Like ut_strlcpy, but if src doesn't fit in dst completely, copies the last
(size - 1) bytes of src, not the first.
@return	strlen(src) */
UNIV_INTERN
ulint
ut_strlcpy_rev(
/*===========*/
	char*		dst,	/*!< in: destination buffer */
	const char*	src,	/*!< in: source buffer */
	ulint		size)	/*!< in: size of destination buffer */
{
	ulint	src_size = strlen(src);

	if (size != 0) {
		ulint	n = ut_min(src_size, size - 1);

		memcpy(dst, src + src_size - n, n + 1);
	}

	return(src_size);
}

/**********************************************************************//**
Make a quoted copy of a NUL-terminated string.	Leading and trailing
quotes will not be included; only embedded quotes will be escaped.
See also ut_strlenq() and ut_memcpyq().
@return	pointer to end of dest */
UNIV_INTERN
char*
ut_strcpyq(
/*=======*/
	char*		dest,	/*!< in: output buffer */
	char		q,	/*!< in: the quote character */
	const char*	src)	/*!< in: null-terminated string */
{
	while (*src) {
		if ((*dest++ = *src++) == q) {
			*dest++ = q;
		}
	}

	return(dest);
}

/**********************************************************************//**
Make a quoted copy of a fixed-length string.  Leading and trailing
quotes will not be included; only embedded quotes will be escaped.
See also ut_strlenq() and ut_strcpyq().
@return	pointer to end of dest */
UNIV_INTERN
char*
ut_memcpyq(
/*=======*/
	char*		dest,	/*!< in: output buffer */
	char		q,	/*!< in: the quote character */
	const char*	src,	/*!< in: string to be quoted */
	ulint		len)	/*!< in: length of src */
{
	const char*	srcend = src + len;

	while (src < srcend) {
		if ((*dest++ = *src++) == q) {
			*dest++ = q;
		}
	}

	return(dest);
}

#ifndef UNIV_HOTBACKUP
/**********************************************************************//**
Return the number of times s2 occurs in s1. Overlapping instances of s2
are only counted once.
@return	the number of times s2 occurs in s1 */
UNIV_INTERN
ulint
ut_strcount(
/*========*/
	const char*	s1,	/*!< in: string to search in */
	const char*	s2)	/*!< in: string to search for */
{
	ulint	count = 0;
	ulint	len = strlen(s2);

	if (len == 0) {

		return(0);
	}

	for (;;) {
		s1 = strstr(s1, s2);

		if (!s1) {

			break;
		}

		count++;
		s1 += len;
	}

	return(count);
}

/**********************************************************************//**
Replace every occurrence of s1 in str with s2. Overlapping instances of s1
are only replaced once.
@return	own: modified string, must be freed with mem_free() */
UNIV_INTERN
char*
ut_strreplace(
/*==========*/
	const char*	str,	/*!< in: string to operate on */
	const char*	s1,	/*!< in: string to replace */
	const char*	s2)	/*!< in: string to replace s1 with */
{
	char*		new_str;
	char*		ptr;
	const char*	str_end;
	ulint		str_len = strlen(str);
	ulint		s1_len = strlen(s1);
	ulint		s2_len = strlen(s2);
	ulint		count = 0;
	int		len_delta = (int)s2_len - (int)s1_len;

	str_end = str + str_len;

	if (len_delta <= 0) {
		len_delta = 0;
	} else {
		count = ut_strcount(str, s1);
	}

	new_str = mem_alloc(str_len + count * len_delta + 1);
	ptr = new_str;

	while (str) {
		const char*	next = strstr(str, s1);

		if (!next) {
			next = str_end;
		}

		memcpy(ptr, str, next - str);
		ptr += next - str;

		if (next == str_end) {

			break;
		}

		memcpy(ptr, s2, s2_len);
		ptr += s2_len;

		str = next + s1_len;
	}

	*ptr = '\0';

	return(new_str);
}

#ifdef UNIV_COMPILE_TEST_FUNCS

void
test_ut_str_sql_format()
{
	char	buf[128];
	ulint	ret;

#define CALL_AND_TEST(str, str_len, buf, buf_size, ret_expected, buf_expected)\
	do {\
		ibool	ok = TRUE;\
		memset(buf, 'x', 10);\
		buf[10] = '\0';\
		ib_logger(ib_stream, "TESTING \"%s\", %lu, %lu\n",\
			str, (ulint) str_len, (ulint) buf_size);\
		ret = ut_str_sql_format(str, str_len, buf, buf_size);\
		if (ret != ret_expected) {\
			ib_logger(ib_stream, "expected ret %lu, got %lu\n",\
				(ulint) ret_expected, ret);\
			ok = FALSE;\
		}\
		if (strcmp((char*) buf, buf_expected) != 0) {\
			ib_logger(ib_stream, "expected buf \"%s\", got \"%s\"\n",\
				buf_expected, buf);\
			ok = FALSE;\
		}\
		if (ok) {\
			ib_logger(ib_stream, "OK: %lu, \"%s\"\n\n",\
				(ulint) ret, buf);\
		} else {\
			return;\
		}\
	} while (0)

	CALL_AND_TEST("abcd", 4, buf, 0, 0, "xxxxxxxxxx");

	CALL_AND_TEST("abcd", 4, buf, 1, 1, "");

	CALL_AND_TEST("abcd", 4, buf, 2, 1, "");

	CALL_AND_TEST("abcd", 0, buf, 3, 3, "''");
	CALL_AND_TEST("abcd", 1, buf, 3, 1, "");
	CALL_AND_TEST("abcd", 2, buf, 3, 1, "");
	CALL_AND_TEST("abcd", 3, buf, 3, 1, "");
	CALL_AND_TEST("abcd", 4, buf, 3, 1, "");

	CALL_AND_TEST("abcd", 0, buf, 4, 3, "''");
	CALL_AND_TEST("abcd", 1, buf, 4, 4, "'a'");
	CALL_AND_TEST("abcd", 2, buf, 4, 4, "'a'");
	CALL_AND_TEST("abcd", 3, buf, 4, 4, "'a'");
	CALL_AND_TEST("abcd", 4, buf, 4, 4, "'a'");
	CALL_AND_TEST("abcde", 5, buf, 4, 4, "'a'");
	CALL_AND_TEST("'", 1, buf, 4, 3, "''");
	CALL_AND_TEST("''", 2, buf, 4, 3, "''");
	CALL_AND_TEST("a'", 2, buf, 4, 4, "'a'");
	CALL_AND_TEST("'a", 2, buf, 4, 3, "''");
	CALL_AND_TEST("ab", 2, buf, 4, 4, "'a'");

	CALL_AND_TEST("abcdef", 0, buf, 5, 3, "''");
	CALL_AND_TEST("abcdef", 1, buf, 5, 4, "'a'");
	CALL_AND_TEST("abcdef", 2, buf, 5, 5, "'ab'");
	CALL_AND_TEST("abcdef", 3, buf, 5, 5, "'ab'");
	CALL_AND_TEST("abcdef", 4, buf, 5, 5, "'ab'");
	CALL_AND_TEST("abcdef", 5, buf, 5, 5, "'ab'");
	CALL_AND_TEST("abcdef", 6, buf, 5, 5, "'ab'");
	CALL_AND_TEST("'", 1, buf, 5, 5, "''''");
	CALL_AND_TEST("''", 2, buf, 5, 5, "''''");
	CALL_AND_TEST("a'", 2, buf, 5, 4, "'a'");
	CALL_AND_TEST("'a", 2, buf, 5, 5, "''''");
	CALL_AND_TEST("ab", 2, buf, 5, 5, "'ab'");
	CALL_AND_TEST("abc", 3, buf, 5, 5, "'ab'");

	CALL_AND_TEST("ab", 2, buf, 6, 5, "'ab'");

	CALL_AND_TEST("a'b'c", 5, buf, 32, 10, "'a''b''c'");
	CALL_AND_TEST("a'b'c'", 6, buf, 32, 12, "'a''b''c'''");
}

#endif /* UNIV_COMPILE_TEST_FUNCS */
#endif /* !UNIV_HOTBACKUP */
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/***************************************************************//**
@file ut/ut0rnd.c
Random numbers and hashing

Created 5/11/1994 Heikki Tuuri
********************************************************************/

#include "ut0rnd.h"

#ifdef UNIV_NONINL
#include "ut0rnd.ic"
#endif

/** These random numbers are used in ut_find_prime */
/*@{*/
#define	UT_RANDOM_1	1.0412321
#define	UT_RANDOM_2	1.1131347
#define UT_RANDOM_3	1.0132677
/*@}*/

/** Seed value of ut_rnd_gen_ulint(). */
UNIV_INTERN ulint	ut_rnd_ulint_counter = 65654363;

/***********************************************************//**
Looks for a prime number slightly greater than the given argument.
The prime is chosen so that it is not near any power of 2.
@return	prime */
UNIV_INTERN
ulint
ut_find_prime(
/*==========*/
	ulint	n)	/*!< in: positive number > 100 */
{
	ulint	pow2;
	ulint	i;

	n += 100;

	pow2 = 1;
	while (pow2 * 2 < n) {
		pow2 = 2 * pow2;
	}

	if ((double)n < 1.05 * (double)pow2) {
		n = (ulint) ((double)n * UT_RANDOM_1);
	}

	pow2 = 2 * pow2;

	if ((double)n > 0.95 * (double)pow2) {
		n = (ulint) ((double)n * UT_RANDOM_2);
	}

	if (n > pow2 - 20) {
		n += 30;
	}

	/* Now we have n far enough from powers of 2. To make
	n more random (especially, if it was not near
	a power of 2), we then multiply it by a random number. */

	n = (ulint) ((double)n * UT_RANDOM_3);

	for (;; n++) {
		i = 2;
		while (i * i <= n) {
			if (n % i == 0) {
				goto next_n;
			}
			i++;
		}

		/* Found a prime */
		break;
next_n:		;
	}

	return(n);
}
/*****************************************************************************

Copyright (c) 1994, 2009, Innobase Oy. All Rights Reserved.
Copyright (c) 2009, Sun Microsystems, Inc.

Portions of this file contain modifications contributed and copyrighted by
Sun Microsystems, Inc. Those modifications are gratefully acknowledged and
are described briefly in the InnoDB documentation. The contributions by
Sun Microsystems are incorporated with their permission, and subject to the
conditions contained in the file COPYING.Sun_Microsystems.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/***************************************************************//**
@file ut/ut0ut.c
Various utilities for Innobase.

Created 5/11/1994 Heikki Tuuri
********************************************************************/

#include <errno.h>

#include "ut0ut.h"

#ifdef UNIV_NONINL
#include "ut0ut.ic"
#endif

#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#ifndef UNIV_HOTBACKUP
#include "trx0trx.h"
#include "api0ucode.h"
#endif /* UNIV_HOTBACKUP */

UNIV_STATIC	ibool	ut_always_false	= FALSE;

#ifdef __WIN__
/*****************************************************************//**
NOTE: The Windows epoch starts from 1601/01/01 whereas the Unix
epoch starts from 1970/1/1. For selection of constant see:
http://support.microsoft.com/kb/167296/ */
#define WIN_TO_UNIX_DELTA_USEC  ((ib_int64_t) 11644473600000000ULL)


/*****************************************************************//**
This is the Windows version of gettimeofday(2).
@return	0 if all OK else -1 */
UNIV_STATIC
int
ut_gettimeofday(
/*============*/
	struct timeval*	tv,	/*!< out: Values are relative to Unix epoch */
	void*		tz)	/*!< in: not used */
{
	FILETIME	ft;
	ib_int64_t	tm;

	if (!tv) {
		errno = EINVAL;
		return(-1);
	}

	GetSystemTimeAsFileTime(&ft);

	tm = (ib_int64_t) ft.dwHighDateTime << 32;
	tm |= ft.dwLowDateTime;

	ut_a(tm >= 0);	/* If tm wraps over to negative, the quotient / 10
			does not work */

	tm /= 10;	/* Convert from 100 nsec periods to usec */

	/* If we don't convert to the Unix epoch the value for
	struct timeval::tv_sec will overflow.*/
	tm -= WIN_TO_UNIX_DELTA_USEC;

	tv->tv_sec  = (long) (tm / 1000000L);
	tv->tv_usec = (long) (tm % 1000000L);

	return(0);
}
#else
#include <sys/time.h>
/** An alias for gettimeofday(2).  On Microsoft Windows, we have to
reimplement this function. */
#define	ut_gettimeofday		gettimeofday
#endif

/********************************************************//**
Gets the high 32 bits in a ulint. That is makes a shift >> 32,
but since there seem to be compiler bugs in both gcc and Visual C++,
we do this by a special conversion.
@return	a >> 32 */
UNIV_INTERN
ulint
ut_get_high32(
/*==========*/
	ulint	a)	/*!< in: ulint */
{
	ib_int64_t	i;

	i = (ib_int64_t)a;

	i = i >> 32;

	return((ulint)i);
}

/**********************************************************//**
Returns system time. We do not specify the format of the time returned:
the only way to manipulate it is to use the function ut_difftime.
@return	system time */
UNIV_INTERN
ib_time_t
ut_time(void)
/*=========*/
{
	return(time(NULL));
}

#ifndef UNIV_HOTBACKUP
/**********************************************************//**
Returns system time.
Upon successful completion, the value 0 is returned; otherwise the
value -1 is returned and the global variable errno is set to indicate the
error.
@return	0 on success, -1 otherwise */
UNIV_INTERN
int
ut_usectime(
/*========*/
	ulint*	sec,	/*!< out: seconds since the Epoch */
	ulint*	ms)	/*!< out: microseconds since the Epoch+*sec */
{
	struct timeval	tv;
	int		ret;
	int		errno_gettimeofday;
	int		i;

	for (i = 0; i < 10; i++) {

		ret = ut_gettimeofday(&tv, NULL);

		if (ret == -1) {
			errno_gettimeofday = errno;
			ut_print_timestamp(ib_stream);
			ib_logger(ib_stream, "  InnoDB: gettimeofday(): %s\n",
				strerror(errno_gettimeofday));
			os_thread_sleep(100000);  /* 0.1 sec */
			errno = errno_gettimeofday;
		} else {
			break;
		}
	}

	if (ret != -1) {
		*sec = (ulint) tv.tv_sec;
		*ms  = (ulint) tv.tv_usec;
	}

	return(ret);
}

/**********************************************************//**
Returns the number of microseconds since epoch. Similar to
time(3), the return value is also stored in *tloc, provided
that tloc is non-NULL.
@return	us since epoch */
UNIV_INTERN
ib_uint64_t
ut_time_us(
/*=======*/
	ib_uint64_t*	tloc)	/*!< out: us since epoch, if non-NULL */
{
	struct timeval	tv;
	ib_uint64_t	us;

	ut_gettimeofday(&tv, NULL);

	us = (ib_uint64_t) tv.tv_sec * 1000000 + tv.tv_usec;

	if (tloc != NULL) {
		*tloc = us;
	}

	return(us);
}

/**********************************************************//**
Returns the number of milliseconds since some epoch.  The
value may wrap around.  It should only be used for heuristic
purposes.
@return	ms since epoch */
UNIV_INTERN
ulint
ut_time_ms(void)
/*============*/
{
	struct timeval	tv;

	ut_gettimeofday(&tv, NULL);

	return((ulint) tv.tv_sec * 1000 + tv.tv_usec / 1000);
}
#endif /* !UNIV_HOTBACKUP */

/**********************************************************//**
Returns the difference of two times in seconds.
@return	time2 - time1 expressed in seconds */
UNIV_INTERN
double
ut_difftime(
/*========*/
	ib_time_t	time2,	/*!< in: time */
	ib_time_t	time1)	/*!< in: time */
{
	return(difftime(time2, time1));
}

/**********************************************************//**
Prints a timestamp to a file. */
UNIV_INTERN
void
ut_print_timestamp(
/*===============*/
	ib_stream_t	ib_stream) /*!< in: file where to print */
{
#ifdef __WIN__
	SYSTEMTIME cal_tm;

	GetLocalTime(&cal_tm);

	ib_logger(ib_stream,"%02d%02d%02d %2d:%02d:%02d",
		(int)cal_tm.wYear % 100,
		(int)cal_tm.wMonth,
		(int)cal_tm.wDay,
		(int)cal_tm.wHour,
		(int)cal_tm.wMinute,
		(int)cal_tm.wSecond);
#else
	struct tm  cal_tm;
	struct tm* cal_tm_ptr;
	time_t	   tm;

	time(&tm);

#ifdef HAVE_LOCALTIME_R
	localtime_r(&tm, &cal_tm);
	cal_tm_ptr = &cal_tm;
#else
	cal_tm_ptr = localtime(&tm);
#endif
	ib_logger(ib_stream,"%02d%02d%02d %2d:%02d:%02d",
		cal_tm_ptr->tm_year % 100,
		cal_tm_ptr->tm_mon + 1,
		cal_tm_ptr->tm_mday,
		cal_tm_ptr->tm_hour,
		cal_tm_ptr->tm_min,
		cal_tm_ptr->tm_sec);
#endif
}

/**********************************************************//**
Sprintfs a timestamp to a buffer, 13..14 chars plus terminating NUL. */
UNIV_INTERN
void
ut_sprintf_timestamp(
/*=================*/
	char*	buf) /*!< in: buffer where to sprintf */
{
#ifdef __WIN__
	SYSTEMTIME cal_tm;

	GetLocalTime(&cal_tm);

	sprintf(buf, "%02d%02d%02d %2d:%02d:%02d",
		(int)cal_tm.wYear % 100,
		(int)cal_tm.wMonth,
		(int)cal_tm.wDay,
		(int)cal_tm.wHour,
		(int)cal_tm.wMinute,
		(int)cal_tm.wSecond);
#else
	struct tm  cal_tm;
	struct tm* cal_tm_ptr;
	time_t	   tm;

	time(&tm);

#ifdef HAVE_LOCALTIME_R
	localtime_r(&tm, &cal_tm);
	cal_tm_ptr = &cal_tm;
#else
	cal_tm_ptr = localtime(&tm);
#endif
	sprintf(buf, "%02d%02d%02d %2d:%02d:%02d",
		cal_tm_ptr->tm_year % 100,
		cal_tm_ptr->tm_mon + 1,
		cal_tm_ptr->tm_mday,
		cal_tm_ptr->tm_hour,
		cal_tm_ptr->tm_min,
		cal_tm_ptr->tm_sec);
#endif
}

#ifdef UNIV_HOTBACKUP
/**********************************************************//**
Sprintfs a timestamp to a buffer with no spaces and with ':' characters
replaced by '_'. */
UNIV_INTERN
void
ut_sprintf_timestamp_without_extra_chars(
/*=====================================*/
	char*	buf) /*!< in: buffer where to sprintf */
{
#ifdef __WIN__
	SYSTEMTIME cal_tm;

	GetLocalTime(&cal_tm);

	sprintf(buf, "%02d%02d%02d_%2d_%02d_%02d",
		(int)cal_tm.wYear % 100,
		(int)cal_tm.wMonth,
		(int)cal_tm.wDay,
		(int)cal_tm.wHour,
		(int)cal_tm.wMinute,
		(int)cal_tm.wSecond);
#else
	struct tm  cal_tm;
	struct tm* cal_tm_ptr;
	time_t	   tm;

	time(&tm);

#ifdef HAVE_LOCALTIME_R
	localtime_r(&tm, &cal_tm);
	cal_tm_ptr = &cal_tm;
#else
	cal_tm_ptr = localtime(&tm);
#endif
	sprintf(buf, "%02d%02d%02d_%2d_%02d_%02d",
		cal_tm_ptr->tm_year % 100,
		cal_tm_ptr->tm_mon + 1,
		cal_tm_ptr->tm_mday,
		cal_tm_ptr->tm_hour,
		cal_tm_ptr->tm_min,
		cal_tm_ptr->tm_sec);
#endif
}

/**********************************************************//**
Returns current year, month, day. */
UNIV_INTERN
void
ut_get_year_month_day(
/*==================*/
	ulint*	year,	/*!< out: current year */
	ulint*	month,	/*!< out: month */
	ulint*	day)	/*!< out: day */
{
#ifdef __WIN__
	SYSTEMTIME cal_tm;

	GetLocalTime(&cal_tm);

	*year = (ulint)cal_tm.wYear;
	*month = (ulint)cal_tm.wMonth;
	*day = (ulint)cal_tm.wDay;
#else
	struct tm  cal_tm;
	struct tm* cal_tm_ptr;
	time_t	   tm;

	time(&tm);

#ifdef HAVE_LOCALTIME_R
	localtime_r(&tm, &cal_tm);
	cal_tm_ptr = &cal_tm;
#else
	cal_tm_ptr = localtime(&tm);
#endif
	*year = (ulint)cal_tm_ptr->tm_year + 1900;
	*month = (ulint)cal_tm_ptr->tm_mon + 1;
	*day = (ulint)cal_tm_ptr->tm_mday;
#endif
}
#endif /* UNIV_HOTBACKUP */

#ifndef UNIV_HOTBACKUP
/*************************************************************//**
Runs an idle loop on CPU. The argument gives the desired delay
in microseconds on 100 MHz Pentium + Visual C++.
@return	dummy value */
UNIV_INTERN
ulint
ut_delay(
/*=====*/
	ulint	delay)	/*!< in: delay in microseconds on 100 MHz Pentium */
{
	ulint	i, j;

	j = 0;

	for (i = 0; i < delay * 50; i++) {
		j += i;
		UT_RELAX_CPU();
	}

	if (ut_always_false) {
		ut_always_false = (ibool) j;
	}

	return(j);
}
#endif /* !UNIV_HOTBACKUP */

/*************************************************************//**
Prints the contents of a memory buffer in hex and ascii. */
UNIV_INTERN
void
ut_print_buf(
/*=========*/
	ib_stream_t	ib_stream,	/*!< in: stream where to print */
	const void*	buf,		/*!< in: memory buffer */
	ulint		len)		/*!< in: length of the buffer */
{
	const byte*	data;
	ulint		i;

	UNIV_MEM_ASSERT_RW(buf, len);

	ib_logger(ib_stream, " len %lu; hex ", len);

	for (data = (const byte*)buf, i = 0; i < len; i++) {
		ib_logger(ib_stream, "%02lx", (ulong)*data++);
	}

	ib_logger(ib_stream, "; asc ");

	data = (const byte*)buf;

	for (i = 0; i < len; i++) {
		int	c = (int) *data++;
		ib_logger(ib_stream, "%c", isprint(c) ? c : ' ');
	}

	ib_logger(ib_stream, ";");
}

/*************************************************************//**
Calculates fast the number rounded up to the nearest power of 2.
@return	first power of 2 which is >= n */
UNIV_INTERN
ulint
ut_2_power_up(
/*==========*/
	ulint	n)	/*!< in: number != 0 */
{
	ulint	res;

	res = 1;

	ut_ad(n > 0);

	while (res < n) {
		res = res * 2;
	}

	return(res);
}

/**********************************************************************//**
Outputs a NUL-terminated file name, quoted with apostrophes. */
UNIV_INTERN
void
ut_print_filename(
/*==============*/
	ib_stream_t	ib_stream,	/*!< in: output stream */
	const char*	name)		/*!< in: name to print */
{
	ib_logger(ib_stream, "'");
	for (;;) {
		int	c = *name++;
		switch (c) {
		case 0:
			goto done;
		case '\'':
			ib_logger(ib_stream, "%c", c);
			/* fall through */
		default:
			ib_logger(ib_stream, "%c", c);
		}
	}
done:
	ib_logger(ib_stream, "'");
}
#ifndef UNIV_HOTBACKUP
/**********************************************************************//**
Outputs a fixed-length string, quoted as an SQL identifier.
If the string contains a slash '/', the string will be
output as two identifiers separated by a period (.),
as in SQL database_name.identifier. */
UNIV_INTERN
void
ut_print_name(
/*==========*/
	ib_stream_t	ib_stream,	/*!< in: output stream */
	trx_t*		trx,		/*!< in: transaction */
	ibool		table_id,	/*!< in: TRUE=print a table name,
					FALSE=print other identifier */
	const char*	name)		/*!< in: name to print */
{
	ut_print_namel(ib_stream, name, strlen(name));
}

/**********************************************************************//**
Outputs a fixed-length string, quoted as an SQL identifier.
If the string contains a slash '/', the string will be
output as two identifiers separated by a period (.),
as in SQL database_name.identifier. */
UNIV_INTERN
void
ut_print_namel(
/*===========*/
	ib_stream_t	ib_stream,	/*!< in: output stream */
	const char*	name,		/*!< in: name to print */
	ulint		namelen)	/*!< in: length of name */
{
	int		len;
	/* 2 * NAME_LEN for database and table name,
	and some slack for the extra prefix and quotes */
	char		buf[3 * NAME_LEN];

	len = ut_snprintf(buf, sizeof(buf), "%.*s", (int) namelen, name);
	ut_a(len >= (int) namelen);

	ib_logger(ib_stream, "%.*s", len, buf);
}
#endif /* !UNIV_HOTBACKUP */

#ifdef __WIN__
# include <stdarg.h>
/**********************************************************************//**
A substitute for snprintf(3), formatted output conversion into
a limited buffer.
@return number of characters that would have been printed if the size
were unlimited, not including the terminating '\0'. */
UNIV_INTERN
int
ut_snprintf(
/*========*/
	char*		str,	/*!< out: string */
	size_t		size,	/*!< in: str size */
	const char*	fmt,	/*!< in: format */
	...)			/*!< in: format values */
{
	int	res;
	va_list	ap1;
	va_list	ap2;

	va_start(ap1, fmt);
	va_start(ap2, fmt);

	res = _vscprintf(fmt, ap1);
	ut_a(res != -1);

	if (size > 0) {
		_vsnprintf(str, size, fmt, ap2);

		if ((size_t) res >= size) {
			str[size - 1] = '\0';
		}
	}

	va_end(ap1);
	va_end(ap2);

	return(res);
}
#endif /* __WIN__ */
/*****************************************************************************

Copyright (c) 2006, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/*******************************************************************//**
@file ut/ut0vec.c
A vector of pointers to data items

Created 4/6/2006 Osku Salerma
************************************************************************/

#include "ut0vec.h"
#ifdef UNIV_NONINL
#include "ut0vec.ic"
#endif
#include <string.h>

/****************************************************************//**
Create a new vector with the given initial size.
@return	vector */
UNIV_INTERN
ib_vector_t*
ib_vector_create(
/*=============*/
	mem_heap_t*	heap,	/*!< in: heap */
	ulint		size)	/*!< in: initial size */
{
	ib_vector_t*	vec;

	ut_a(size > 0);

	vec = mem_heap_alloc(heap, sizeof(*vec));

	vec->heap = heap;
	vec->data = mem_heap_alloc(heap, sizeof(void*) * size);
	vec->used = 0;
	vec->total = size;

	return(vec);
}

/****************************************************************//**
Push a new element to the vector, increasing its size if necessary. */
UNIV_INTERN
void
ib_vector_push(
/*===========*/
	ib_vector_t*	vec,	/*!< in: vector */
	void*		elem)	/*!< in: data element */
{
	if (vec->used >= vec->total) {
		void**	new_data;
		ulint	new_total = vec->total * 2;

		new_data = mem_heap_alloc(vec->heap,
					  sizeof(void*) * new_total);
		memcpy(new_data, vec->data, sizeof(void*) * vec->total);

		vec->data = new_data;
		vec->total = new_total;
	}

	vec->data[vec->used] = elem;
	vec->used++;
}
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/******************************************************************//**
@file mach/mach0data.c
Utilities for converting data from the database file
to the machine format.

Created 11/28/1995 Heikki Tuuri
***********************************************************************/

#include "mach0data.h"

#ifdef UNIV_NONINL
#include "mach0data.ic"
#endif

/*********************************************************//**
Reads a ulint in a compressed form if the log record fully contains it.
@return	pointer to end of the stored field, NULL if not complete */
UNIV_INTERN
byte*
mach_parse_compressed(
/*==================*/
	byte*	ptr,	/*!< in: pointer to buffer from where to read */
	byte*	end_ptr,/*!< in: pointer to end of the buffer */
	ulint*	val)	/*!< out: read value (< 2^32) */
{
	ulint	flag;

	ut_ad(ptr && end_ptr && val);

	if (ptr >= end_ptr) {

		return(NULL);
	}

	flag = mach_read_from_1(ptr);

	if (flag < 0x80UL) {
		*val = flag;
		return(ptr + 1);

	} else if (flag < 0xC0UL) {
		if (end_ptr < ptr + 2) {
			return(NULL);
		}

		*val = mach_read_from_2(ptr) & 0x7FFFUL;

		return(ptr + 2);

	} else if (flag < 0xE0UL) {
		if (end_ptr < ptr + 3) {
			return(NULL);
		}

		*val = mach_read_from_3(ptr) & 0x3FFFFFUL;

		return(ptr + 3);
	} else if (flag < 0xF0UL) {
		if (end_ptr < ptr + 4) {
			return(NULL);
		}

		*val = mach_read_from_4(ptr) & 0x1FFFFFFFUL;

		return(ptr + 4);
	} else {
		ut_ad(flag == 0xF0UL);

		if (end_ptr < ptr + 5) {
			return(NULL);
		}

		*val = mach_read_from_4(ptr + 1);
		return(ptr + 5);
	}
}

/*********************************************************//**
Reads a dulint in a compressed form if the log record fully contains it.
@return	pointer to end of the stored field, NULL if not complete */
UNIV_INTERN
byte*
mach_dulint_parse_compressed(
/*=========================*/
	byte*	ptr,	/*!< in: pointer to buffer from where to read */
	byte*	end_ptr,/*!< in: pointer to end of the buffer */
	dulint*	val)	/*!< out: read value */
{
	ulint	high;
	ulint	low;
	ulint	size;

	ut_ad(ptr && end_ptr && val);

	if (end_ptr < ptr + 5) {

		return(NULL);
	}

	high = mach_read_compressed(ptr);

	size = mach_get_compressed_size(high);

	ptr += size;

	if (end_ptr < ptr + 4) {

		return(NULL);
	}

	low = mach_read_from_4(ptr);

	*val = ut_dulint_create(high, low);

	return(ptr + 4);
}
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file dyn/dyn0dyn.c
The dynamically allocated array

Created 2/5/1996 Heikki Tuuri
*******************************************************/

#include "dyn0dyn.h"
#ifdef UNIV_NONINL
#include "dyn0dyn.ic"
#endif

/************************************************************//**
Adds a new block to a dyn array.
@return	created block */
UNIV_INTERN
dyn_block_t*
dyn_array_add_block(
/*================*/
	dyn_array_t*	arr)	/*!< in: dyn array */
{
	mem_heap_t*	heap;
	dyn_block_t*	block;

	ut_ad(arr);
	ut_ad(arr->magic_n == DYN_BLOCK_MAGIC_N);

	if (arr->heap == NULL) {
		UT_LIST_INIT(arr->base);
		UT_LIST_ADD_FIRST(list, arr->base, arr);

		arr->heap = mem_heap_create(sizeof(dyn_block_t));
	}

	block = dyn_array_get_last_block(arr);
	block->used = block->used | DYN_BLOCK_FULL_FLAG;

	heap = arr->heap;

	block = mem_heap_alloc(heap, sizeof(dyn_block_t));

	block->used = 0;

	UT_LIST_ADD_LAST(list, arr->base, block);

	return(block);
}
