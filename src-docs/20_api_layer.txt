==================================================================
COMPONENT: API LAYER
==================================================================
The public API that applications use to interact with InnoDB.
This is the entry point for all operations.

Key concepts:
- Database operations (create, open, close)
- Transaction management
- Cursor operations
- Tuple manipulation
- Configuration management
- Error handling

Files included:
/***********************************************************************
Copyright (c) 2008, 2009 Innobase Oy. All rights reserved.
Copyright (c) 2008, 2009 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/
#ifndef INNOBASE_API_H
#define INNOBASE_API_H

#include "db0err.h"

/* API_BEGIN_INCLUDE */
#include <stdio.h>

#ifdef _MSC_VER
#define strncasecmp		_strnicmp
#define strcasecmp		_stricmp
#endif

#if defined(__GNUC__) && (__GNUC__ > 2) && ! defined(__INTEL_COMPILER)
#define UNIV_NO_IGNORE		__attribute__ ((warn_unused_result))
#else
#define UNIV_NO_IGNORE
#endif /* __GNUC__ && __GNUC__ > 2 && !__INTEL_COMPILER */

/* See comment about ib_bool_t as to why the two macros are unsigned long. */
/** The boolean value of "true" used internally within InnoDB */
#define IB_TRUE			0x1UL
/** The boolean value of "false" used internally within InnoDB */
#define IB_FALSE		0x0UL

/* Basic types used by the InnoDB API. */
/** All InnoDB error codes are represented by ib_err_t */
typedef enum db_err             ib_err_t;
/** Representation of a byte within InnoDB */
typedef unsigned char           ib_byte_t;
/** Representation of an unsigned long int within InnoDB */
typedef unsigned long int       ib_ulint_t;
/** Representation of a void* within InnoDB */
typedef void*                   ib_opaque_t;
/* Ideally we would like to have this as ib_byte_t, but we need to make it
the same as the InnoDB internal ibool. */
/** Representation of a "boolean" type within InnoDB */
typedef ib_ulint_t              ib_bool_t;
/** A character set pointer */
typedef ib_opaque_t             ib_charset_t;

/* We assume C99 support except when using VisualStudio. */
#if !defined(_MSC_VER)
#include <stdint.h>
#endif /* _MSC_VER */

/* Integer types used by the API. Microsft VS defines its own types
and we use the Microsoft types when building with Visual Studio. */
#if defined(_MSC_VER)
/** A signed 8 bit integral type. */
typedef __int8			ib_i8_t;
#else
/** A signed 8 bit integral type. */
typedef int8_t                  ib_i8_t;
#endif

#if defined(_MSC_VER)
/** An unsigned 8 bit integral type. */
typedef unsigned __int8		ib_u8_t;
#else
/** An unsigned 8 bit integral type. */
typedef uint8_t                 ib_u8_t;
#endif

#if defined(_MSC_VER)
/** A signed 16 bit integral type. */
typedef __int16			ib_i16_t;
#else
/** A signed 16 bit integral type. */
typedef int16_t                 ib_i16_t;
#endif

#if defined(_MSC_VER)
/** An unsigned 16 bit integral type. */
typedef unsigned __int16	ib_u16_t;
#else
/** An unsigned 16 bit integral type. */
typedef uint16_t                ib_u16_t;
#endif

#if defined(_MSC_VER)
/** A signed 32 bit integral type. */
typedef __int32			ib_i32_t;
#else
/** A signed 32 bit integral type. */
typedef int32_t                 ib_i32_t;
#endif

#if defined(_MSC_VER)
/** An unsigned 32 bit integral type. */
typedef unsigned __int32	ib_u32_t;
#else
/** An unsigned 32 bit integral type. */
typedef uint32_t                ib_u32_t;
#endif

#if defined(_MSC_VER)
/** A signed 64 bit integral type. */
typedef __int64			ib_i64_t;
#else
/** A signed 64 bit integral type. */
typedef int64_t                 ib_i64_t;
#endif

#if defined(_MSC_VER)
/** An unsigned 64 bit integral type. */
typedef unsigned __int64	ib_u64_t;
#else
/** An unsigned 64 bit integral type. */
typedef uint64_t                ib_u64_t;
#endif

/** The integral type that represents internal table and index ids. */
typedef ib_u64_t                ib_id_t;

/** @enum ib_cfg_type_t Possible types for a configuration variable. */
typedef enum {
	IB_CFG_IBOOL,			/*!< The configuration parameter is
					of type ibool */

	/* XXX Can we avoid having different types for ulint and ulong?
	- On Win64 "unsigned long" is 32 bits
	- ulong is always defined as "unsigned long"
	- On Win64 ulint is defined as 64 bit integer
	=> On Win64 ulint != ulong.
	If we typecast all ulong and ulint variables to the smaller type
	ulong, then we will cut the range of the ulint variables.
	This is not a problem for most ulint variables because their max
	allowed values do not exceed 2^32-1 (e.g. log_groups is ulint
	but its max allowed value is 10). BUT buffer_pool_size and
	log_file_size allow up to 2^64-1. */

	IB_CFG_ULINT,			/*!< The configuration parameter is
					of type ulint */

	IB_CFG_ULONG,			/*!< The configuration parameter is
					of type ulong */

	IB_CFG_TEXT,			/*!< The configuration parameter is
					of type char* */

	IB_CFG_CB			/*!< The configuration parameter is
					a callback parameter */
} ib_cfg_type_t;

/** @enum ib_col_type_t  column types that are supported. */
typedef enum {
	IB_VARCHAR =	1,		/*!< Character varying length. The
					column is not padded. */

	IB_CHAR =	2,		/*!< Fixed length character string. The
					column is padded to the right. */

	IB_BINARY =	3,		/*!< Fixed length binary, similar to
					IB_CHAR but the column is not padded
					to the right. */

	IB_VARBINARY =	4,		/*!< Variable length binary */

	IB_BLOB	=	5,		/*!< Binary large object, or
					a TEXT type */

	IB_INT =	6,		/*!< Integer: can be any size
					from 1 - 8 bytes. If the size is
					1, 2, 4 and 8 bytes then you can use
					the typed read and write functions. For
					other sizes you will need to use the
					ib_col_get_value() function and do the
					conversion yourself. */

	IB_SYS =	8,		/*!< System column, this column can
					be one of DATA_TRX_ID, DATA_ROLL_PTR
					or DATA_ROW_ID. */

	IB_FLOAT =	9,		/*!< C (float)  floating point value. */

	IB_DOUBLE =	10,		/*!> C (double) floating point value. */

	IB_DECIMAL =	11,		/*!< Decimal stored as an ASCII
					string */

	IB_VARCHAR_ANYCHARSET =	12,	/*!< Any charset, varying length */

	IB_CHAR_ANYCHARSET =	13	/*!< Any charset, fixed length */

} ib_col_type_t;

/** @enum ib_tbl_fmt_t InnoDB table format types */
typedef enum {
	IB_TBL_REDUNDANT,		/*!< Redundant row format, the column
					type and length is stored in the row.*/

	IB_TBL_COMPACT,			/*!< Compact row format, the column
					type is not stored in the row. The
					length is stored in the row but the
					storage format uses a compact format
					to store the length of the column data
					and record data storage format also
					uses less storage. */

	IB_TBL_DYNAMIC,			/*!< Compact row format. BLOB prefixes
					are not stored in the clustered index */

	IB_TBL_COMPRESSED		/*!< Similar to dynamic format but
					with pages compressed */
} ib_tbl_fmt_t;

/** @enum ib_col_attr_t InnoDB column attributes */
typedef enum {
	IB_COL_NONE = 0,		/*!< No special attributes. */

	IB_COL_NOT_NULL = 1,		/*!< Column data can't be NULL. */

	IB_COL_UNSIGNED = 2,		/*!< Column is IB_INT and unsigned. */

	IB_COL_NOT_USED = 4,		/*!< Future use, reserved. */

	IB_COL_CUSTOM1 = 8,		/*!< Custom precision type, this is
					a bit that is ignored by InnoDB and so
					can be set and queried by users. */

	IB_COL_CUSTOM2 = 16,		/*!< Custom precision type, this is
					a bit that is ignored by InnoDB and so
					can be set and queried by users. */

	IB_COL_CUSTOM3 = 32		/*!< Custom precision type, this is
					a bit that is ignored by InnoDB and so
					can be set and queried by users. */
} ib_col_attr_t;

/* Note: must match lock0types.h */
/** @enum ib_lck_mode_t InnoDB lock modes. */
typedef enum {
	IB_LOCK_IS = 0,			/*!< Intention shared, an intention
					lock should be used to lock tables */

	IB_LOCK_IX,			/*!< Intention exclusive, an intention
					lock should be used to lock tables */

	IB_LOCK_S,			/*!< Shared locks should be used to
					lock rows */

	IB_LOCK_X,			/*!< Exclusive locks should be used to
					lock rows*/

	IB_LOCK_NOT_USED,		/*!< Future use, reserved */

	IB_LOCK_NONE,			/*!< This is used internally to note
					consistent read */

	IB_LOCK_NUM = IB_LOCK_NONE	/*!< number of lock modes */
} ib_lck_mode_t;

/** @enum ib_srch_mode_t InnoDB cursor search modes for ib_cursor_moveto().
Note: Values must match those found in page0cur.h */
typedef enum {
	IB_CUR_G = 1,			/*!< If search key is not found then
					position the cursor on the row that
					is greater than the search key */

	IB_CUR_GE = 2,			/*!< If the search key not found then
					position the cursor on the row that
					is greater than or equal to the search
					key */

	IB_CUR_L = 3,			/*!< If search key is not found then
					position the cursor on the row that
					is less than the search key */

	IB_CUR_LE = 4			/*!< If search key is not found then
					position the cursor on the row that
					is less than or equal to the search
					key */
} ib_srch_mode_t;

/** @enum ib_match_mode_t Various match modes used by ib_cursor_moveto() */
typedef enum {
	IB_CLOSEST_MATCH,		/*!< Closest match possible */

	IB_EXACT_MATCH,			/*!< Search using a complete key
					value */

	IB_EXACT_PREFIX			/*!< Search using a key prefix which
					must match to rows: the prefix may
					contain an incomplete field (the
					last field in prefix may be just
					a prefix of a fixed length column) */
} ib_match_mode_t;

/** @struct ib_col_meta_t InnoDB column meta data. */
typedef struct {
	ib_col_type_t	type;		/*!< Type of the column */

	ib_col_attr_t	attr;		/*!< Column attributes */

	ib_u32_t	type_len;	/*!< Length of type */

	ib_u16_t	client_type;	/*!< 16 bits of data relevant only to
					the client. InnoDB doesn't care */

	ib_charset_t*	charset;	/*!< Column charset */
} ib_col_meta_t;

/* Note: Must be in sync with trx0trx.h */
/** @enum ib_trx_state_t The transaction state can be queried using the
ib_trx_state() function. The InnoDB deadlock monitor can roll back a
transaction and users should be prepared for this, especially where there
is high contention. The way to determine the state of the transaction is to
query it's state and check. */
typedef enum {
	IB_TRX_NOT_STARTED,		/*!< Has not started yet, the
					transaction has not ben started yet.*/

	IB_TRX_ACTIVE,			/*!< The transaction is currently
					active and needs to be either
					committed or rolled back. */

	IB_TRX_COMMITTED_IN_MEMORY,	/*!< Not committed to disk yet */

	IB_TRX_PREPARED			/*!< Support for 2PC/XA */
} ib_trx_state_t;

/* Note: Must be in sync with trx0trx.h */
/** @enum ib_trx_level_t Transaction isolation levels */
typedef enum {
	IB_TRX_READ_UNCOMMITTED = 0,	/*!< Dirty read: non-locking SELECTs are
					performed so that we do not look at a
					possible earlier version of a record;
					thus they are not 'consistent' reads
					under this isolation level; otherwise
					like level 2 */

	IB_TRX_READ_COMMITTED = 1,	/*!< Somewhat Oracle-like isolation,
					except that in range UPDATE and DELETE
					we must block phantom rows with
					next-key locks; SELECT ... FOR UPDATE
					and ...  LOCK IN SHARE MODE only lock
					the index records, NOT the gaps before
					them, and thus allow free inserting;
					each consistent read reads its own
					snapshot */

	IB_TRX_REPEATABLE_READ = 2,	/*!< All consistent reads in the same
					trx read the same snapshot; full
					next-key locking used in locking reads
					to block insertions into gaps */

	IB_TRX_SERIALIZABLE = 3		/*!< All plain SELECTs are converted to
					LOCK IN SHARE MODE reads */
} ib_trx_level_t;

/** @enum ib_shutdown_t When ib_shutdown() is called InnoDB may take a long
time to shutdown because of background tasks e.g., purging deleted records.
The following flags allow the user to control the shutdown behavior. */
typedef enum {
	IB_SHUTDOWN_NORMAL,		/*!< Normal shutdown, do insert buffer
					merge and purge before complete
					shutdown. */

	IB_SHUTDOWN_NO_IBUFMERGE_PURGE,	/*!< Do not do a purge and index buffer
					merge at shutdown. */

	IB_SHUTDOWN_NO_BUFPOOL_FLUSH	/*!< Same as NO_IBUFMERGE_PURGE
					and in addition do not even flush the
				       	buffer pool to data files. No committed
				       	transactions are lost */
} ib_shutdown_t;

/** Generical InnoDB callback prototype. */
typedef void (*ib_cb_t)(void);

/** The first argument to the InnoDB message logging function. By default
it's set to stderr. You should treat ib_msg_stream_t as a void*, since
it will probably change in the future. */
typedef FILE* ib_msg_stream_t;

/** All log messages are written to this function.It should have the same
behavior as fprintf(3). */
typedef int (*ib_msg_log_t)(ib_msg_stream_t, const char*, ...);

/* Note: This is to make it easy for API users to have type
checking for arguments to our functions. Making it ib_opaque_t
by itself will result in pointer decay resulting in subverting
of the compiler's type checking. */

/** InnoDB tuple handle. This handle can refer to either a cluster index
tuple or a secondary index tuple. There are two types of tuples for each
type of index, making a total of four types of tuple handles. There
is a tuple for reading the entire row contents and another for searching
on the index key. */
typedef struct ib_tpl_struct* ib_tpl_t;

/** InnoDB transaction handle, all database operations need to be covered
by transactions. This handle represents a transaction. The handle can be
created with ib_trx_begin(), you commit your changes with ib_trx_commit()
and undo your changes using ib_trx_rollback(). If the InnoDB deadlock
monitor rolls back the transaction then you need to free the transaction
using the function ib_trx_release(). You can query the state of an InnoDB
transaction by calling ib_trx_state(). */
typedef struct ib_trx_struct* ib_trx_t;

/** InnoDB cursor handle */
typedef struct ib_crsr_struct* ib_crsr_t;

/** InnoDB table schema handle */
typedef struct ib_tbl_sch_struct* ib_tbl_sch_t;

/** InnoDB index schema handle */
typedef struct ib_idx_sch_struct* ib_idx_sch_t;

/** Currently, this is also the number of callback functions in the struct. */
typedef enum {
	IB_SCHEMA_VISITOR_TABLE = 1,
	IB_SCHEMA_VISITOR_TABLE_COL = 2,
	IB_SCHEMA_VISITOR_TABLE_AND_INDEX = 3,
	IB_SCHEMA_VISITOR_TABLE_AND_INDEX_COL = 4
} ib_schema_visitor_version_t;

/** Visit all tables in the InnoDB schem. */
typedef int (*ib_schema_visitor_table_all_t) (
					/*!< return 0 on success, nonzero
					on failure (abort traversal) */
	void*		arg,		/*!< User callback arg */
	const char*	name,		/*!< Table name */
	int		name_len);	/*!< Length of name in bytes */

/** Table visitor */
typedef int (*ib_schema_visitor_table_t) (
					/*!< return 0 on success, nonzero
					on failure (abort traversal) */
	void*		arg,		/*!< User callback arg */
	const char*	name,		/*!< Table name */
	ib_tbl_fmt_t	tbl_fmt,	/*!< Table type */
	ib_ulint_t	page_size,	/*!< Table page size */
	int		n_cols,		/*!< No. of cols defined */
	int		n_indexes);	/*!< No. of indexes defined */

/** Table column visitor */
typedef int (*ib_schema_visitor_table_col_t) (
					/*!< return 0 on success, nonzero
					on failure (abort traversal) */
	void*		arg,		/*!< User callback arg */
	const char*	name,		/*!< Column name */
	ib_col_type_t	col_type,	/*!< Column type */
	ib_ulint_t	len,		/*!< Column len */
	ib_col_attr_t	attr);		/*!< Column attributes */

/** Index visitor */
typedef int (*ib_schema_visitor_index_t) (
					/*!< return 0 on success, nonzero
					on failure (abort traversal) */
	void*		arg,		/*!< User callback arg */
	const char*	name,		/*!< Index name */
	ib_bool_t	clustered,	/*!< True if clustered */
	ib_bool_t	unique,		/*!< True if unique */
	int		n_cols);	/*!< No. of cols defined */

/** Index column visitor */
typedef int (*ib_schema_visitor_index_col_t) (
					/*!< return 0 on success, nonzero
					on failure (abort traversal) */
	void*		arg,		/*!< User callback arg */
	const char*	name,		/*!< Column name */
	ib_ulint_t	prefix_len);	/*!< Prefix length */

/** Callback functions to traverse the schema of a table. */
typedef struct {
	ib_schema_visitor_version_t	version;
					/*!< Visitor version */
	ib_schema_visitor_table_t	table;
					/*!< For travesing table info */
	ib_schema_visitor_table_col_t	table_col;
					/*!< For travesing table column info */
	ib_schema_visitor_index_t	index;
					/*!< For travesing index info */
	ib_schema_visitor_index_col_t	index_col;
					/*!< For travesing index column info */
} ib_schema_visitor_t;

/*************************************************************//**
This function is used to compare two data fields for which the data type
is such that we must use the client code to compare them. */
typedef int (*ib_client_cmp_t)(
					/*!< out: 1, 0, -1, if a is greater,
					equal, less than b, respectively */
	const ib_col_meta_t*
			col_meta,	/*!< in: column meta data */
	const ib_byte_t*p1,		/*!< in: key */
	ib_ulint_t	p1_len,		/*!< in: key length */
	const ib_byte_t*p2,		/*!< in: key */
	ib_ulint_t	p2_len);	/*!< in: key length */

/* This should be the same as univ.i */
/** Represents SQL_NULL length */
#define	IB_SQL_NULL		0xFFFFFFFF
/** The number of system columns in a row. */
#define IB_N_SYS_COLS		3

/** The maximum length of a text column. */
#define MAX_TEXT_LEN		4096

/* MySQL uses 3 byte UTF-8 encoding. */
/** The maximum length of a column name in a table schema. */
#define IB_MAX_COL_NAME_LEN	(64 * 3)

/** The maximum length of a table name (plus database name). */
#define IB_MAX_TABLE_NAME_LEN	(64 * 3)

/*! @def ib_tbl_sch_add_blob_col(s, n)
Add a BLOB column to a table schema.
@param s is the the schema handle
@param n is the column name  */
#define ib_tbl_sch_add_blob_col(s, n) \
	ib_table_schema_add_col(s, n, IB_BLOB, IB_COL_NONE, 0, 0)

/*! @def ib_tbl_sch_add_text_col(s, n)
Add a BLOB column to a table schema.
@param s is the the schema handle
@param n is the column name
Add a TEXT column to a table schema. */
#define ib_tbl_sch_add_text_col(s, n) \
	ib_table_schema_add_col(s, n, IB_VARCHAR, IB_COL_NONE, 0, MAX_TEXT_LEN)

/*! @def ib_tbl_sch_add_varchar_col(s, n, l)
Add a VARCHAR column to a table schema.
@param s is the schema handle
@param n is the column name
@param l the max length of the VARCHAR column
@return DB_SUCCESS or error code */
#define ib_tbl_sch_add_varchar_col(s, n, l) \
	ib_table_schema_add_col(s, n, IB_VARCHAR, IB_COL_NONE, 0, l)

/*! @def ib_tbl_sch_add_u32_col(s, n)
Add an UNSIGNED INT column to a table schema.
@param s is the schema handle
@param n is the column name
@return DB_SUCCESS or error code */
#define ib_tbl_sch_add_u32_col(s, n) \
	ib_table_schema_add_col(s, n, IB_INT, IB_COL_UNSIGNED, 0, 4)

/*! @def ib_tbl_sch_add_u64_col(s, n)
Add an UNSIGNED BIGINT column to a table schema.
@param s is the schema handle
@param n is the column name
@return DB_SUCCESS or error code */
#define ib_tbl_sch_add_u64_col(s, n) \
	ib_table_schema_add_col(s, n, IB_INT, IB_COL_UNSIGNED, 0, 8)

/*! @def ib_tbl_sch_add_u64_notnull_col(s, n)
Add an UNSIGNED BIGINT NOT NULL column to a table schema.
@param s is the schema handle
@param n is the column name
@return DB_SUCCESS or error code */
#define ib_tbl_sch_add_u64_notnull_col(s, n) \
	ib_table_schema_add_col(s, n, IB_INT, \
			        IB_COL_NOT_NULL | IB_COL_UNSIGNED,0,\
				8)
/*! @def ib_cfg_set_int(name, value)
Set an int configuration variable.
@param name is the config variable name
@param value is the integer value of the variable
@return DB_SUCCESS or error code */
#define ib_cfg_set_int(name, value)	ib_cfg_set(name, value)

/*! @def ib_cfg_set_text(name, value)
Set a text configuration variable.
@param name is the config variable name
@param value is the char* value of the variable
@return DB_SUCCESS or error code */
#define ib_cfg_set_text(name, value)	ib_cfg_set(name, value)

/*! @def ib_cfg_set_bool_on(name)
Set a boolean configuration variable to IB_TRUE.
@param name is the config variable name
@return DB_SUCCESS or error code */
#define ib_cfg_set_bool_on(name)	ib_cfg_set(name, IB_TRUE)

/*! @def ib_cfg_set_bool_off(name)
Set a boolean configuration variable to IB_FALSE.
@param name is the config variable name
@return DB_SUCCESS or error code */
#define ib_cfg_set_bool_off(name)	ib_cfg_set(name, IB_FALSE)

/*! @def ib_cfg_set_callback(name, value)
Set a generic ib_cb_t callback function.
@param name is the config variable name
@param value is a pointer to a callback function
@return DB_SUCCESS or error code */
#define ib_cfg_set_callback(name, value) ib_cfg_set(name, value)

/** Callback function to compare InnoDB key columns in an index. */
extern ib_client_cmp_t	ib_client_compare;

/* Define the Doxygen groups:
   @defgroup init Startup/Shutdown functions
   @defgroup cursor Cursor functions
   @defgroup trx Transaction functions
   @defgroup conf Configuration functions
   @defgroup ddl DDL functions
   @defgroup misc Miscellaneous functions
   @defgroup tuple Tuple functions
   @defgroup sql SQL functions
   @defgroup dml DML functions
*/
/*****************************************************************//**
Return the API version number, the version number format is:
| 16 bits future use | 16 bits current | 16 bits revision | 16 bits age |

- If the library source code has changed at all since the last release,
  then revision will be incremented (`c:r:a' becomes `c:r+1:a').
- If any interfaces have been added, removed, or changed since the last
  update, current will be incremented, and revision will be set to 0.
- If any interfaces have been added (but not changed or removed) since
  the last release, then age will be incremented.
- If any interfaces have been changed or removed since the last release,
  then age will be set to 0.

@ingroup misc
@return	API version number */

ib_u64_t
ib_api_version(void) UNIV_NO_IGNORE;
/*=================*/

/*****************************************************************//**
Initialize the InnoDB engine. This must be called prior to calling
any other InnoDB API function. You can call only the ib_cfg_*() functions
between calls to ib_init() and ib_startup(). No other Embedded InnoDB
functions should be called.

@ingroup init
@return	DB_SUCCESS or error code */

ib_err_t
ib_init(void) UNIV_NO_IGNORE;
/*=========*/

/*****************************************************************//**
Startup the InnoDB engine. If this function is called on a non-existent
database then based on the default or user specified configuration
settings it will create all the necessary files. If the database was
shutdown cleanly but the user deleted the REDO log files then it
will recreate the REDO log files.

@ingroup init
@param format is the max file format name that the engine supports
@return	DB_SUCCESS or error code
@see DB_SUCCESS */

ib_err_t
ib_startup(
/*=======*/
	const char* format) UNIV_NO_IGNORE;

/*****************************************************************//**
Shutdown the InnoDB engine. Call this function when they are no 
active transactions. It will close all files and release all memory
on successful completion. All internal variables will be reset to their
default values.

@ingroup init
@param flag is the shutdown flag
@return	DB_SUCCESS or error code */

ib_err_t
ib_shutdown(
/*========*/
	ib_shutdown_t	flag) UNIV_NO_IGNORE;

/*****************************************************************//**
Start a transaction that's been rolled back. This special function
exists for the case when InnoDB's deadlock detector has rolledack
a transaction. While the transaction has been rolled back the handle
is still valid and can be reused by calling this function. If you
don't want to reuse the transaction handle then you can free the handle
by calling ib_trx_release().

@ingroup trx
@param ib_trx is the transaction to restart
@param ib_trx_level is the transaction isolation level
@return	innobase txn handle */

ib_err_t
ib_trx_start(
/*=========*/
	ib_trx_t	ib_trx,
	ib_trx_level_t	ib_trx_level) UNIV_NO_IGNORE;

/*****************************************************************//**
Begin a transaction. This will allocate a new transaction handle and
put the transaction in the active state.

@ingroup trx
@param ib_trx_level is the transaction isolation level
@return	innobase txn handle */

ib_trx_t
ib_trx_begin(
/*=========*/
	ib_trx_level_t	ib_trx_level) UNIV_NO_IGNORE;

/*****************************************************************//**
Query the transaction's state. This function can be used to check for
the state of the transaction in case it has been rolled back by the
InnoDB deadlock detector. Note that when a transaction is selected as
a victim for rollback, InnoDB will always return an appropriate error
code indicating this. @see DB_DEADLOCK, @see DB_LOCK_TABLE_FULL and
@see DB_LOCK_WAIT_TIMEOUT

@ingroup trx
@param ib_trx is the transaction handle
@return	transaction state */

ib_trx_state_t
ib_trx_state(
/*=========*/
	ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Release the resources of the transaction. If the transaction was
selected as a victim by InnoDB and rolled back then use this function
to free the transaction handle.

@ingroup trx
@param ib_trx is the transaction handle
@return	DB_SUCCESS or err code */

ib_err_t
ib_trx_release(
/*===========*/
	ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Commit a transaction. This function will release the schema latches too.
It will also free the transaction handle.

@ingroup trx
@param ib_trx is thr transaction handle
@return	DB_SUCCESS or err code */

ib_err_t
ib_trx_commit(
/*==========*/
	ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Rollback a transaction. This function will release the schema latches too.
It will also free the transaction handle.

@ingroup trx
@param ib_trx is the transaction handle
@return	DB_SUCCESS or err code */

ib_err_t
ib_trx_rollback(
/*============*/
	ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Add columns to a table schema. Tables are created in InnoDB by first
creating a table schema which is identified by a handle. Then you
add the column definitions to the table schema.

@ingroup ddl
@param ib_tbl_sch is the table schema instance
@param name is the name of the column to add
@param ib_col_type is the type of the column
@param ib_col_attr are the attributes of the column, including constraints
@param client_type is any 16 bit number relevant only to the client
@param len is the maximum length of the column
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_schema_add_col(
/*====================*/
	ib_tbl_sch_t	ib_tbl_sch,
	const char*	name,
	ib_col_type_t	ib_col_type,
	ib_col_attr_t	ib_col_attr,
	ib_u16_t	client_type,
	ib_ulint_t	len) UNIV_NO_IGNORE;

/*****************************************************************//**
Create and add an index key definition to a table schema. The index
schema is owned by the table schema instance and will be freed when
the table schema instance is freed.

@ingroup ddl
@param[in,out] ib_tbl_sch is the schema instance
@param name name of the key definition to create
@param[out] ib_idx_sch is the key definition schema instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_schema_add_index(
/*======================*/
	ib_tbl_sch_t	ib_tbl_sch,
	const char*	name,
	ib_idx_sch_t*	ib_idx_sch) UNIV_NO_IGNORE;

/*****************************************************************//**
Destroy a schema. The handle is freed by this function.

@ingroup ddl
@param ib_tbl_sch is the table schema to delte*/

void
ib_table_schema_delete(
/*===================*/
	ib_tbl_sch_t	ib_tbl_sch);

/*****************************************************************//**
Create a table schema.

@ingroup ddl
@param name is the table name for which to create the schema
@param[out] ib_tbl_sch is the schema instance that is created
@param ib_tbl_fmt is the format of the table to be created
@param page_size is the page size for the table or 0 for default

@return	DB_SUCCESS or err code */

ib_err_t
ib_table_schema_create(
/*===================*/
	const char*	name,
	ib_tbl_sch_t*	ib_tbl_sch,
	ib_tbl_fmt_t	ib_tbl_fmt,
	ib_ulint_t	page_size) UNIV_NO_IGNORE;

/*****************************************************************//**
Add columns to an index schema definition.

@ingroup ddl
@param[in,out] ib_idx_sch is the index schema instance
@param name is the name of the column to add to the index schema
@param prefix_len is the prefix length of the index or 0 if no prefix
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_add_col(
/*====================*/
	ib_idx_sch_t	ib_idx_sch,
	const char*	name,
	ib_ulint_t	prefix_len) UNIV_NO_IGNORE;

/*****************************************************************//**
Create an index schema instance.

@ingroup ddl
@param ib_usr_trx is the current user transaction
@param name is the name of the index to create
@param table_name is the name of the table the index belongs to
@param[out] ib_idx_sch is the newly created index schema instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_create(
/*===================*/
	ib_trx_t	ib_usr_trx,
	const char*	name,
	const char*	table_name,
	ib_idx_sch_t*	ib_idx_sch) UNIV_NO_IGNORE;

/*****************************************************************//**
Set index as clustered index. Implies UNIQUE.

@ingroup ddl
@param[in,out] ib_idx_sch is the index schema to update
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_set_clustered(
/*==========================*/
	ib_idx_sch_t	ib_idx_sch) UNIV_NO_IGNORE;

/*****************************************************************//**
Set to true if it's a simple select.

@ingroup sql
@param[in, out] ib_crsr is the cursor to update */

void
ib_cursor_set_simple_select(
/*========================*/
	ib_crsr_t	ib_crsr);

/*****************************************************************//**
Set index as a unique index.

@ingroup ddl
@param[in,out] ib_idx_sch is the index schema to update
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_set_unique(
/*=======================*/
	ib_idx_sch_t	ib_idx_sch) UNIV_NO_IGNORE;

/*****************************************************************//**
Destroy an index schema.

@ingroup ddl
@param ib_idx_sch is the index schema to delete */

void
ib_index_schema_delete(
/*===================*/
	ib_idx_sch_t	ib_idx_sch);

/*****************************************************************//**
Create a table in the InnoDB data dictionary using the schema definition.
If the table exists in the database then this function will return
DB_TABLE_IS_BEING_USED and id will contain that table's id.

@ingroup ddl
@param[in,out] ib_trx the current user transaction
@param ib_tbl_sch the the schema for the table to create
@param[out] id table id that was created
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_create(
/*============*/
	ib_trx_t		ib_trx,
	const ib_tbl_sch_t	ib_tbl_sch,
	ib_id_t*		id) UNIV_NO_IGNORE;

/*****************************************************************//**
Rename a table. Ensure that you have acquired the schema lock in
exclusive mode.

@ingroup ddl
@param[in,out] ib_trx is the current user transaction
@param old_name the current name of the table
@param new_name the new name for the table
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_rename(
/*============*/
	ib_trx_t	ib_trx,
	const char*	old_name,
	const char*	new_name) UNIV_NO_IGNORE;

/*****************************************************************//**
Create a secondary index. The index id encodes the table id in the high
4 bytes and the index id in the lower 4 bytes.

@ingroup ddl
@param[in,out] ib_idx_sch the schema for the index
@param[out] index_id is the new index id that was created
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_create(
/*============*/
	ib_idx_sch_t	ib_idx_sch,
	ib_id_t*	index_id) UNIV_NO_IGNORE;

/*****************************************************************//**
Drop a table. Ensure that you have acquired the schema lock in
exclusive mode.

@ingroup ddl
@param trx is the covering transaction.
@param name is the name of the table to drop
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_drop(
/*==========*/
	ib_trx_t	trx,
	const char*	name) UNIV_NO_IGNORE;

/*****************************************************************//**
Drop a secondary index. Ensure that you have acquired the schema lock in
exclusive mode.

@ingroup ddl
@param trx is the covering transaction.
@param index_id is the id of the index to drop
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_drop(
/*==========*/
	ib_trx_t	trx,
	ib_id_t		index_id) UNIV_NO_IGNORE;

/*****************************************************************//**
Open an InnoDB table and return a cursor handle to it.

@ingroup cursor
@param table_id is the id of the table to open
@param ib_trx is the current transaction handle, can be NULL
@param[out] ib_crsr is the new cursor
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_table_using_id(
/*==========================*/
	ib_id_t		table_id,
	ib_trx_t	ib_trx,
	ib_crsr_t*	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Open an InnoDB index and return a cursor handle to it.

@ingroup cursor
@param index_id is the id of the index to open
@param ib_trx is the current transaction handlem can be NULL
@param[out] ib_crsr is the new cursor
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_index_using_id(
/*==========================*/
	ib_id_t		index_id,
	ib_trx_t	ib_trx,
	ib_crsr_t*	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Open an InnoDB secondary index cursor and return a cursor handle to it.

@ingroup cursor
@param ib_open_crsr is an open cursor
@param index_name is the name of the index
@param[out] ib_crsr is the new cursor
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_index_using_name(
/*============================*/
	ib_crsr_t	ib_open_crsr,
	const char*	index_name,
	ib_crsr_t*	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Open an InnoDB table by name and return a cursor handle to it.

@ingroup cursor
@param name is the table name to open
@param ib_trx is the current transactionm, can be NULL
@param ib_crsr is the new cursor
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_table(
/*=================*/
	const char*	name,
	ib_trx_t	ib_trx,
	ib_crsr_t*	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Reset the cursor.

@ingroup cursor
@param ib_crsr is an open cursor
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_reset(
/*============*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Close an InnoDB table and free the cursor.

@ingroup cursor
@param ib_crsr is an open cursor
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_close(
/*============*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Insert a row to a table.

@ingroup dml
@param ib_crsr is an open cursor
@param ib_tpl is the tuple to insert
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_insert_row(
/*=================*/
	ib_crsr_t	ib_crsr,
	const ib_tpl_t	ib_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Update a row in a table.

@ingroup dml
@param ib_crsr is the cursor instance
@param ib_old_tpl is the old tuple in the table
@param ib_new_tpl is the new tuple with the updated values
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_update_row(
/*=================*/
	ib_crsr_t	ib_crsr,
	const ib_tpl_t	ib_old_tpl,
	const ib_tpl_t	ib_new_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Delete a row in a table.

@ingroup dml
@param ib_crsr is the cursor instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_delete_row(
/*=================*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Read current row.

@ingroup dml
@param ib_crsr is the cursor instance
@param[out] ib_tpl is the tuple to read the column values
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_read_row(
/*===============*/
	ib_crsr_t	ib_crsr,
	ib_tpl_t	ib_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Move cursor to the prev user record in the table.

@ingroup cursor
@param ib_crsr is the cursor instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_prev(
/*===========*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Move cursor to the next user record in the table.

@ingroup cursor
@param ib_crsr is the cursor instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_next(
/*===========*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Move cursor to the first record in the table.

@ingroup cursor
@param ib_crsr is the cursor instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_first(
/*============*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Move cursor to the last record in the table.

@ingroup cursor
@param ib_crsr is the cursor instance
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_last(
/*===========*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Search for key.

@ingroup cursor
@param ib_crsr is an open cursor instance
@param ib_tpl is a key to search for
@param ib_srch_mode is the search mode
@param[out] result is -1, 0 or 1 depending on tuple eq or gt than
       the current row
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_moveto(
/*=============*/
	ib_crsr_t	ib_crsr,
	ib_tpl_t	ib_tpl,
	ib_srch_mode_t	ib_srch_mode,
	int*		result) UNIV_NO_IGNORE;

/*****************************************************************//**
Attach the cursor to the transaction. The cursor must not already be
attached to another transaction.

@ingroup cursor
@param ib_crsr is the cursor instance
@param ib_trx is the transaction to attach to the cursor */

void
ib_cursor_attach_trx(
/*=================*/
	ib_crsr_t	ib_crsr,
	ib_trx_t	ib_trx);

/*****************************************************************//**
Set the client comparison function for BLOBs and client types.

@ingroup misc
@param client_cmp_func is the index key compare callback function */

void
ib_set_client_compare(
/*==================*/
	ib_client_cmp_t	client_cmp_func);

/*****************************************************************//**
Set the match mode for ib_cursor_move().

@ingroup cursor
@param ib_crsr is the cursor instance
@param match_mode is the match mode to set */

void
ib_cursor_set_match_mode(
/*=====================*/
	ib_crsr_t	ib_crsr,
	ib_match_mode_t	match_mode);

/*****************************************************************//**
Set a column of the tuple. Make a copy using the tuple's heap.

@ingroup dml
@param ib_tpl is the tuple instance
@param col_no is the column index in the tuple
@param src is the data value to set
@param len is the data value (src) length in bytes
@return	DB_SUCCESS or error code */

ib_err_t
ib_col_set_value(
/*=============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	col_no,
	const void*	src,
	ib_ulint_t	len) UNIV_NO_IGNORE;

/*****************************************************************//**
Get the size of the data available in the column the tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@return	bytes avail or IB_SQL_NULL */

ib_ulint_t
ib_col_get_len(
/*===========*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i) UNIV_NO_IGNORE;

/*****************************************************************//**
Copy a column value from the tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] dst is where the data will be copied
@param len is the maximum number of bytes that can be copied to dst
@return	bytes copied or IB_SQL_NULL */

ib_ulint_t
ib_col_copy_value(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	void*		dst,
	ib_ulint_t	len);

/*************************************************************//**
Read a signed int 8 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i8(
/*=============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_i8_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read an unsigned int 8 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u8(
/*=============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_u8_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read a signed int 16 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i16(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_i16_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read an unsigned int 16 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u16(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_u16_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read a signed int 32 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i32(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_i32_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read an unsigned int 32 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u32(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_u32_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read a signed int 64 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i64(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_i64_t*	ival) UNIV_NO_IGNORE;

/*************************************************************//**
Read an unsigned int 64 bit column from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ival is the integer value
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u64(
/*==============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_u64_t*	ival) UNIV_NO_IGNORE;

/*****************************************************************//**
Get a column value pointer from the tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@return	NULL or pointer to buffer */

const void*
ib_col_get_value(
/*=============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i) UNIV_NO_IGNORE;

/*****************************************************************//**
Get a column type, length and attributes from the tuple.

@ingroup dml
@param ib_tpl is the tuple instance
@param i is the index (ordinal position) of the column within the tuple
@param[out] ib_col_meta the column meta data
@return	len of column data */

ib_ulint_t
ib_col_get_meta(
/*============*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	i,
	ib_col_meta_t*	ib_col_meta);

/*****************************************************************//**
"Clear" or reset an InnoDB tuple. We free the heap and recreate the tuple.

@ingroup tuple
@param ib_tpl is the tuple to be freed
@return	new tuple, or NULL */

ib_tpl_t
ib_tuple_clear(
/*============*/
	ib_tpl_t	ib_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Create a new cluster key search tuple and copy the contents of  the
secondary index key tuple columns that refer to the cluster index record
to the cluster key. It does a deep copy of the column data.

@ingroup tuple
@param ib_crsr is a cursor opened on a secondary index
@param[out] ib_dst_tpl is the tuple where the key data will be copied
@param ib_src_tpl is the source secondary index tuple to copy from
@return	DB_SUCCESS or error code */

ib_err_t
ib_tuple_get_cluster_key(
/*=====================*/
	ib_crsr_t	ib_crsr,
	ib_tpl_t*	ib_dst_tpl,
	const ib_tpl_t	ib_src_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Copy the contents of  source tuple to destination tuple. The tuples
must be of the same type and belong to the same table/index.

@ingroup tuple
@param ib_dst_tpl is the destination tuple
@param ib_src_tpl is the source tuple
@return	DB_SUCCESS or error code */

ib_err_t
ib_tuple_copy(
/*==========*/
	ib_tpl_t	ib_dst_tpl,
	const ib_tpl_t	ib_src_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Create an InnoDB tuple used for index/table search.

@ingroup tuple
@param ib_crsr is the cursor instance
@return tuple for current index */

ib_tpl_t
ib_sec_search_tuple_create(
/*=======================*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Create an InnoDB tuple used for index/table search.

@ingroup tuple
@param ib_crsr is the cursor instance
@return	tuple for current index */

ib_tpl_t
ib_sec_read_tuple_create(
/*=====================*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Create an InnoDB tuple used for table key operations.

@ingroup tuple
@param ib_crsr is the cursor instance
@return	tuple for current table */

ib_tpl_t
ib_clust_search_tuple_create(
/*=========================*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Create an InnoDB tuple for table row operations.

@ingroup tuple
@param ib_crsr is the cursor instance
@return	tTuple for current table */

ib_tpl_t
ib_clust_read_tuple_create(
/*=======================*/
	ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Return the number of user columns in the tuple definition.

@ingroup tuple
@param ib_tpl is a tuple
@return	number of user columns */

ib_ulint_t
ib_tuple_get_n_user_cols(
/*=====================*/
	const ib_tpl_t	ib_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Return the number of columns in the tuple definition.

@ingroup tuple
@param ib_tpl is a tuple
@return	number of columns */

ib_ulint_t
ib_tuple_get_n_cols(
/*================*/
	const ib_tpl_t	ib_tpl) UNIV_NO_IGNORE;

/*****************************************************************//**
Destroy an InnoDB tuple.

@ingroup tuple
@param ib_tpl is the tuple instance to delete */

void
ib_tuple_delete(
/*============*/
	ib_tpl_t	ib_tpl);

/*****************************************************************//**
Truncate a table. The cursor handle will be closed and set to NULL
on success.

@ingroup ddl
@param[out] ib_crsr is the cursor for table to truncate
@param[out] table_id is the new table id
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_truncate(
/*===============*/
	ib_crsr_t*	ib_crsr,
	ib_id_t*	table_id) UNIV_NO_IGNORE;

/*****************************************************************//**
Truncate a table.

@ingroup ddl
@param table_name is the name of the table to truncate
@param[out] table_id is the new table id
@return	DB_SUCCESS or error code */

ib_err_t
ib_table_truncate(
/*==============*/
	const char*	table_name,
	ib_id_t*	table_id) UNIV_NO_IGNORE;

/*****************************************************************//**
Get a table id.

@ingroup ddl
@param table_name is the name of the table to lookup
@param[out] table_id is the new table id if found
@return	DB_SUCCESS if found */

ib_err_t
ib_table_get_id(
/*============*/
	const char*	table_name,
	ib_id_t*	table_id) UNIV_NO_IGNORE;

/*****************************************************************//**
Get an index id.

@ingroup ddl
@param table_name is the name of the table that contains the index
@param index_name is the name of the index to lookup
@param[out] index_id contains the index id if found
@return	DB_SUCCESS if found */

ib_err_t
ib_index_get_id(
/*============*/
	const char*	table_name,
	const char*	index_name,
	ib_id_t*	index_id) UNIV_NO_IGNORE;

/*********************************************************************//**
Create a database if it doesn't exist.

@ingroup ddl
@param dbname is the name of the database to create
@return	IB_TRUE on success */

ib_bool_t
ib_database_create(
/*===============*/
	const char*	dbname) UNIV_NO_IGNORE;

/*********************************************************************//**
Drop a database if it exists. This function will also drop all tables
within the database.

@ingroup ddl
@param dbname is the name of the database to drop
@return	DB_SUCCESS or error code */

ib_err_t
ib_database_drop(
/*=============*/
	const char*	dbname) UNIV_NO_IGNORE;

/*****************************************************************//**
Check if cursor is positioned.

@ingroup cursor
@param ib_crsr is the cursor instance to check
@return	IB_TRUE if positioned */

ib_bool_t
ib_cursor_is_positioned(
/*====================*/
	const ib_crsr_t	ib_crsr) UNIV_NO_IGNORE;

/*****************************************************************//**
Latches the data dictionary in shared mode.

@ingroup ddl
@param ib_trx is the transaction instance
@return	DB_SUCCESS or error code */

ib_err_t
ib_schema_lock_shared(
/*==================*/
	ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Latches the data dictionary in exclusive mode.

@ingroup ddl
@param ib_trx is the transaction instance
@return	DB_SUCCESS or error code */

ib_err_t
ib_schema_lock_exclusive(
/*======================*/
	ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Checks if the data dictionary is latched in exclusive mode by a
user transaction.

@ingroup ddl
@param ib_trx is a transaction instance
@return	TRUE if exclusive latch */

ib_bool_t
ib_schema_lock_is_exclusive(
/*========================*/
	const ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Checks if the data dictionary is latched in shared mode.
@param ib_trx is a transaction instance
@return	TRUE if shared latch */

ib_bool_t
ib_schema_lock_is_shared(
/*=====================*/
	const ib_trx_t	ib_trx) UNIV_NO_IGNORE;

/*****************************************************************//**
Unlocks the data dictionary.

@ingroup ddl
@param ib_trx is a transaction instance
@return	DB_SUCCESS or error code */

ib_err_t
ib_schema_unlock(
/*=============*/
	ib_trx_t	ib_trx);

/*****************************************************************//**
Lock an InnoDB cursor/table.

@ingroup trx
@param ib_crsr is the cursor instance
@param ib_lck_mode is the lock mode
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_lock(
/*===========*/
	ib_crsr_t	ib_crsr,
	ib_lck_mode_t	ib_lck_mode) UNIV_NO_IGNORE;

/*****************************************************************//**
Set the Lock an InnoDB table using the table id.

@ingroup trx
@param ib_trx is a transaction instance
@param table_id is the table to lock
@param ib_lck_mode is the lock mode
@return	DB_SUCCESS or error code */

ib_err_t
ib_table_lock(
/*===========*/
	ib_trx_t	ib_trx,
	ib_id_t		table_id,
	ib_lck_mode_t	ib_lck_mode) UNIV_NO_IGNORE;

/*****************************************************************//**
Set the Lock mode of the cursor.

@ingroup trx
@param ib_crsr is the cursor instance for which we want to set the lock mode
@param  ib_lck_mode is the lock mode
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_set_lock_mode(
/*====================*/
	ib_crsr_t	ib_crsr,
	ib_lck_mode_t	ib_lck_mode) UNIV_NO_IGNORE;

/*****************************************************************//**
Set need to access clustered index record flag.

@ingroup dml
@param ib_crsr is the cursor instance for which we want to set the flag */

void
ib_cursor_set_cluster_access(
/*=========================*/
	ib_crsr_t	ib_crsr);

/*****************************************************************//**
Read a table's schema using the visitor pattern. It will make the
following sequence of calls:

	visitor->table()
	visitor->table_col() for each user column
	visitor->index() for each user index
	visitor->index_col() for each column in user index

It will stop if any of the above functions returns a non-zero value.
The caller must have an exclusive lock on the InnoDB data dictionary

@ingroup ddl
@param ib_trx transaction that owns the schema lock
@param name is the table name to read
@param visitor visitor functions to invoke on each definition
@param arg is the argument passed to the visitor functions.
@return	DB_SUCCESS or DB_ERROR */

ib_err_t
ib_table_schema_visit(
/*==================*/
	ib_trx_t	ib_trx,
	const char*	name,
	const ib_schema_visitor_t*
			visitor,
	void*		arg) UNIV_NO_IGNORE;

/*****************************************************************//**
List all the tables in the InnoDB's data dictionary. It will abort
if visitor returns a non-zero value.

It will call the function:
	visitor.tables(arg, const char* name, int name_len);

The function will abort if visitor.tables() returns non-zero.

@ingroup ddl
@param ib_trx is the transaction that owns the schema lock
@param visitor is the visitor function
@param arg argument passed to the visitor function
@return DB_SUCCESS if successful */

ib_err_t
ib_schema_tables_iterate(
/*=====================*/
	ib_trx_t	ib_trx,
	ib_schema_visitor_table_all_t
			visitor,
	void*		arg) UNIV_NO_IGNORE;

/*********************************************************************//**
Get the type of a configuration variable. Returns DB_SUCCESS if the
variable with name "name" was found and "type" was set.

@ingroup config
@param name is the variable name to look up
@param[out] type is the type of the variable name if found
@return	DB_SUCCESS if successful */

ib_err_t
ib_cfg_var_get_type(
/*================*/
	const char*	name,
	ib_cfg_type_t*	type) UNIV_NO_IGNORE;

/*********************************************************************//**
Set a configuration variable. The second argument's type depends on the
type of the variable with the given "name". Returns DB_SUCCESS if the
variable with name "name" was found and if its value was set.

@ingroup config
@param name is the config variable name whose value is to be set
@return	DB_SUCCESS if set */

ib_err_t
ib_cfg_set(
/*=======*/
	const char*	name,
	...) UNIV_NO_IGNORE;

/*********************************************************************//**
Get the value of a configuration variable. The type of the returned value
depends on the type of the configuration variable. DB_SUCCESS is returned
if the variable with name "name" was found and "value" was set.

@ingroup config
@param name is the variable name whose value needs to be accessed
@param[out] value is the value of the variable if found
@return	DB_SUCCESS if retrieved successfully */

ib_err_t
ib_cfg_get(
/*=======*/
	const char*	name,
	void*		value) UNIV_NO_IGNORE;

/*********************************************************************//**
Get a list of the names of all configuration variables.
The caller is responsible for free(3)ing the returned array of strings
when it is not needed anymore and for not modifying the individual strings.

@ingroup config
@param[out] names pointer to array of strings
@param[out] names_num number of strings returned
@return	DB_SUCCESS or error code */

ib_err_t
ib_cfg_get_all(
/*===========*/
	const char***	names,
	ib_u32_t*	names_num) UNIV_NO_IGNORE;

/*******************************************************************//**
Creates a named savepoint. The transaction must be started. If there is
already a savepoint of the same name, this call erases that old savepoint
and replaces it with a new. Savepoints are deleted in a transaction
commit or rollback.

@ingroup trx
@param ib_trx is the transaction instance
@param name is the name of the savepoint
@param name_len is the length of name in bytes */

void
ib_savepoint_take(
/*==============*/
	ib_trx_t	ib_trx,
	const void*	name,
	ib_ulint_t	name_len);

/*******************************************************************//**
Releases only the named savepoint. Savepoints which were set after this
savepoint are left as is.

@ingroup trx
@param ib_trx is the active transaction
@param name is the name of the savepoint
@param name_len is the length of name in bytes
@return	if no savepoint of the name found then DB_NO_SAVEPOINT,
        otherwise DB_SUCCESS */

ib_err_t
ib_savepoint_release(
/*=================*/
	ib_trx_t	ib_trx,
	const void*	name,
	ib_ulint_t	name_len) UNIV_NO_IGNORE;

/*******************************************************************//**
Rolls back a transaction back to a named savepoint. Modifications after the
savepoint are undone but InnoDB does NOT release the corresponding locks
which are stored in memory. If a lock is 'implicit', that is, a new inserted
row holds a lock where the lock information is carried by the trx id stored in
the row, these locks are naturally released in the rollback. Savepoints which
were set after this savepoint are deleted. If name equals NULL then all the
savepoints are rolled back.

@ingroup trx
@param ib_trx is the active transaction
@param name is the savepoint name  can be NULL
@param name_len is the length of name in bytes
@return	if no savepoint of the name found then DB_NO_SAVEPOINT,
        otherwise DB_SUCCESS */

ib_err_t
ib_savepoint_rollback(
/*==================*/
	ib_trx_t	ib_trx,
	const void*	name,
	ib_ulint_t	name_len) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_i8(
/*==============*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_i8_t		val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_i16(
/*=================*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_i16_t	val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_i32(
/*===============*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_i32_t	val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_i64(
/*===============*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_i64_t	val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_u8(
/*==============*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_u8_t		val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_u16(
/*===============*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_u16_t	val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_u32(
/*=================*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_u32_t	val) UNIV_NO_IGNORE;

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_u64(
/*===============*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	ib_u64_t	val) UNIV_NO_IGNORE;

/*****************************************************************//**
Inform the cursor that it's the start of an SQL statement.

@ingroup cursor
@param ib_crsr is the cursor instance */

void
ib_cursor_stmt_begin(
/*=================*/
	ib_crsr_t	ib_crsr);

/*****************************************************************//**
Write a double value to a column.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_double(
/*==================*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	double		val) UNIV_NO_IGNORE;

/*************************************************************//**
Read a double column value from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple to read from
@param col_no is the column number to read
@param[out] dval is where the value is copied
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_double(
/*=================*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	col_no,
	double*		dval) UNIV_NO_IGNORE;

/*****************************************************************//**
Write a float value to a column.

@ingroup dml
@param[in,out] ib_tpl is the tuple to write to
@param col_no is the column number to update
@param val is the value to write
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_float(
/*=================*/
	ib_tpl_t	ib_tpl,
	int		col_no,
	float		val) UNIV_NO_IGNORE;

/*************************************************************//**
Read a float value from an InnoDB tuple.

@ingroup dml
@param ib_tpl is the tuple to read from
@param col_no is the column number to read
@param[out] fval is where the value is copied
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_float(
/*================*/
	ib_tpl_t	ib_tpl,
	ib_ulint_t	col_no,
	float*		fval) UNIV_NO_IGNORE;

/*************************************************************//**
Set the message logging function.

@ingroup misc
@param ib_msg_log is the message logging function
@param ib_msg_stream is the message stream, this is the first argument
       to the loggingfunction */

void
ib_logger_set(
/*==========*/
	ib_msg_log_t	ib_msg_log,
	ib_msg_stream_t	ib_msg_stream);

/*************************************************************//**
Convert an error number to a human readable text message. The
returned string is static and should not be freed or modified.

@ingroup misc
@param db_errno is the error number
@return	string, describing the error */

const char*
ib_strerror(
/*========*/
	ib_err_t	db_errno) UNIV_NO_IGNORE;

/*******************************************************************//**
Get the value of an INT status variable. 

@ingroup misc
@param name is the status variable name
@param[out] dst is where the output value is copied if name is found
@return	DB_SUCCESS if found and type is INT,
	DB_DATA_MISMATCH if found but type is not INT,
	DB_NOT_FOUND otherwise. */

ib_err_t
ib_status_get_i64(
/*==============*/
	const char*	name,
	ib_i64_t*	dst) UNIV_NO_IGNORE;

/* API_END_INCLUDE */
#include <stdarg.h>

/*********************************************************************//**
Declare private functions that should not be visible in the public API
below, outside of API_BEGIN_INCLUDE/API_END_INCLUDE.
*************************************************************************/

/*********************************************************************//**
Execute arbitrary SQL using InnoDB's internal parser. The statement
is executed in a new transaction. Table name parameters must be prefixed
with a '$' symbol and variables with ':'
@return	DB_SUCCESS or error code */

ib_err_t
ib_exec_sql(
/*========*/
	const char*     sql,            /*!< in: sql to execute */
	ib_ulint_t	n_args,         /*!< in: no. of args */
	...);

/*********************************************************************//**
Execute arbitrary SQL using InnoDB's internal parser. The statement
is executed in a background transaction. It will lock the data
dictionary lock for the duration of the query.
@return	DB_SUCCESS or error code */

ib_err_t
ib_exec_ddl_sql(
/*============*/
	const char*	sql,		/*!< in: sql to execute */
	ib_ulint_t	n_args,		/*!< in: no. of args */
	...);

/*********************************************************************//**
Initialize the config system.
@return	DB_SUCCESS or error code */

ib_err_t
ib_cfg_init(void);
/*==============*/

/*********************************************************************//**
Shutdown the config system.
@return	DB_SUCCESS or error code */

ib_err_t
ib_cfg_shutdown(void);
/*==================*/

#endif /* INNOBASE_API_H */
/******************************************************
Interface between Innobase and client. This file contains
the functions that don't have a proper home yet.

(c) 2008 Oracle Corpn./Innobase Oy
*******************************************************/

#include "univ.i"
#include "os0file.h"
#include "que0que.h"
#include "trx0trx.h"

/**************************************************************************
Determines if the currently running transaction has been interrupted.
@return	TRUE if interrupted */
UNIV_INTERN
ibool
trx_is_interrupted(
/*===============*/
	const trx_t*	trx);		/*!< in: transaction */

/**********************************************************************
Create a temporary file using the OS specific function. */
UNIV_INTERN
int
ib_create_tempfile(
/*===============*/
	const char*	filename);	/*!< in: temp filename prefix */
	
/********************************************************************
Handles user errors and lock waits detected by the database engine.
@return	TRUE if it was a lock wait and we should continue running the query thread */
UNIV_INTERN
ibool
ib_handle_errors(
/*=============*/
	enum db_err*	new_err,	/*!< out: possible new error
					encountered in lock wait, or if
					no new error, the value of
					trx->error_state at the entry of this
					function */
	trx_t*		trx,		/*!< in: transaction */
	que_thr_t*	thr,		/*!< in: query thread */
	trx_savept_t*	savept);	/*!< in: savepoint or NULL */

/*************************************************************************
Sets a lock on a table.
@return	error code or DB_SUCCESS */
UNIV_INTERN
enum db_err
ib_trx_lock_table_with_retry(
/*=========================*/
	trx_t*		trx,		/*!< in/out: transaction */
	dict_table_t*	table,		/*!< in: table to lock */
	enum lock_mode	mode);		/*!< in: lock mode */

/*************************************************************************
Updates the table modification counter and calculates new estimates
for table and index statistics if necessary. */
UNIV_INTERN
void
ib_update_statistics_if_needed(
/*===========================*/
	dict_table_t*	table);	/*!< in/out: table */
#ifndef INNOBASE_UNI0CODE_H

#define INNOBASE_UNI0CODE_H

/* Opaque type used by the Unicode implementation. */
typedef struct charset_struct charset_t;

/**************************************************************************
Determines the connection character set.
@return	connection character set */
UNIV_INTERN
const charset_t*
ib_ucode_get_connection_charset(void);
/*=================================*/

/**************************************************************************
Determines the character set based on id.
@return	connection character set */
UNIV_INTERN
const charset_t*
ib_ucode_get_charset(
/*=================*/
	ulint		id);		/*!< in: Charset-collation code */

/**********************************************************************
Get the variable length bounds of the given (multibyte) character set. */
UNIV_INTERN
void
ib_ucode_get_charset_width(
/*=======================*/
	const charset_t*cs,		/*!< in: character set */
	ulint*		mbminlen,	/*!< out: min len of a char (in bytes) */
	ulint*		mbmaxlen);	/*!< out: max len of a char (in bytes) */

/**********************************************************************
This function is used to find the storage length in bytes of the first 
prefix_n_bytes characters.
@return	number of bytes occupied by the first prefix_len characters */
UNIV_INTERN
ulint
ib_ucode_get_storage_size(
/*======================*/
	const charset_t*cs,		/*!< in: character set */
	ulint		prefix_n_bytes,	/*!< in: prefix length in bytes */
	ulint		str_len,	/*!< in: length of the string
					in bytes */
	const char*	str);		/*!< in: character string */

/**********************************************************************
This function is used to find the storage length in bytes of the
characters that will fit into prefix_len bytes.
@return	number of bytes required to copy the characters that will fit into prefix_len bytes. */
UNIV_INTERN
ulint
ib_ucode_get_storage_size(
/*======================*/
	const charset_t*cs,		/*!< in: character set id */
	ulint		prefix_len,	/*!< in: prefix length in bytes */
	ulint		str_len,	/*!< in: length of the string in bytes */
	const char*	str);		/*!< in: character string */

/**********************************************************************
Compares NUL-terminated UTF-8 strings case insensitively.
@return	0 if a=b, <0 if a<b, >1 if a>b */
UNIV_INTERN
int
ib_utf8_strcasecmp(
/*===============*/
	const char*	a,		/*!< in: first string to compare */
	const char*	b);		/*!< in: second string to compare */

/**********************************************************************
Compares NUL-terminated UTF-8 strings case insensitively.
@return	0 if a=b, <0 if a<b, >1 if a>b */
UNIV_INTERN
int
ib_utf8_strncasecmp(
/*================*/
	const char*	a,		/*!< in: first string to compare */
	const char*	b,		/*!< in: second string to compare */
	ulint		n);		/*!< in: no. of bytes to compare */

/**********************************************************************
Makes all characters in a NUL-terminated UTF-8 string lower case. */
UNIV_INTERN
void
ib_utf8_casedown(
/*============*/
	char*		a);		/*!< in/out: str to put in lower case */

/**************************************************************************
Test whether a UTF-8 character is a space or not.
@return	TRUE if isspace(c) */
UNIV_INTERN
int
ib_utf8_isspace(
/*============*/
	const charset_t*cs,		/*!< in: character set */
	char		c);		/*!< in: character to test */

/**********************************************************************
Converts an identifier to a UTF-8 table name. */
UNIV_INTERN
void
ib_utf8_convert_from_table_id(
/*==========================*/
	const charset_t*cs,		/*!< in: the 'from' character set */
	char*		to,		/*!< out: converted identifier */
	const char*	from,		/*!< in: identifier to convert */
	ulint		to_len);	/*!< in: length of 'to', in bytes;
					should be at least
					5 * strlen(to) + 1 */

/**********************************************************************
Converts an identifier to UTF-8. */
UNIV_INTERN
void
ib_utf8_convert_from_id(
/*=====================*/
	const charset_t*cs,		/*!< in: the 'from' character set */
	char*		to,		/*!< out: converted identifier */
	const char*	from,		/*!< in: identifier to convert */
	ulint		to_len);	/*!< in: length of 'to', in bytes;
					should be at least
					3 * strlen(to) + 1 */
#endif /* INNOBASE_UNI0CODE_H */
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/db0err.h
Global error codes for the database

Created 5/24/1996 Heikki Tuuri
*******************************************************/

#ifndef db0err_h
#define db0err_h

/* API_BEGIN_INCLUDE */

/** InnoDB error codes. Most of the error codes are internal to the engine
and will not be seen by user applications. The partial error codes reflect
the sub-state of an operation within InnoDB. Some of the error codes are
deprecated and are no longer used. */
enum db_err {
	DB_SUCCESS = 10,		/*!< A successult result */

	/* The following are error codes */
	DB_ERROR,			/*!< This is a generic error code. It
					is used to classify error conditions
					that can't be represented by other
					codes */

	DB_INTERRUPTED,			/*!< An operation was interrupted by
					a user. */

	DB_OUT_OF_MEMORY,		/*!< Operation caused an out of memory
					error. Within InnoDB core code this is
					normally a fatal error */

	DB_OUT_OF_FILE_SPACE,		/*!< The operating system returned
					an out of file space error when trying
					to do an IO operation. */

	DB_LOCK_WAIT,			/*!< A lock request by transaction
					resulted in a lock wait. The thread
					is suspended internally by InnoDB and
					is put on a lock wait queue. */

	DB_DEADLOCK,			/*!< A lock request by a transaction
					resulted in a deadlock. The transaction
					was rolled back */

	DB_ROLLBACK,			/*!< Not used */

	DB_DUPLICATE_KEY,		/*!< A record insert or update violates
					a unique contraint. */

	DB_QUE_THR_SUSPENDED,		/*!< A query thread should be in state
					suspended but is trying to acquire a
					lock. Currently this is treated as a
					hard error and a violation of an
					invariant. */

	DB_MISSING_HISTORY,		/*!< Required history data has been
					deleted due to lack of space in
					rollback segment */

	DB_CLUSTER_NOT_FOUND = 30,	/*!< This error is not used */

	DB_TABLE_NOT_FOUND,		/*!< The table could not be found */

	DB_MUST_GET_MORE_FILE_SPACE,	/*!< The database has to be stopped
					and restarted with more file space */

	DB_TABLE_IS_BEING_USED,		/*!< The user is trying to create a
					table in the InnoDB data dictionary but
					a table with that name already exists */

	DB_TOO_BIG_RECORD,		/*!< A record in an index would not fit
					on a compressed page, or it would
					become bigger than 1/2 free space in
					an uncompressed page frame */

	DB_LOCK_WAIT_TIMEOUT,		/*!< Lock wait lasted too long */

	DB_NO_REFERENCED_ROW,		/*!< Referenced key value not found
					for a foreign key in an insert or
					update of a row */

	DB_ROW_IS_REFERENCED,		/*!< Cannot delete or update a row
					because it contains a key value
					which is referenced */

	DB_CANNOT_ADD_CONSTRAINT,	/*!< Adding a foreign key constraint
					to a table failed */

	DB_CORRUPTION,			/*!< Data structure corruption
					noticed */

	DB_COL_APPEARS_TWICE_IN_INDEX,	/*!< InnoDB cannot handle an index
					where same column appears twice */

	DB_CANNOT_DROP_CONSTRAINT,	/*!< Dropping a foreign key constraint
					from a table failed */

	DB_NO_SAVEPOINT,		/*!< No savepoint exists with the given
					name */

	DB_TABLESPACE_ALREADY_EXISTS,	/*!< We cannot create a new single-table
					tablespace because a file of the same
					name already exists */

	DB_TABLESPACE_DELETED,		/*!< Tablespace does not exist or is
					being dropped right now */

	DB_LOCK_TABLE_FULL,		/*!< Lock structs have exhausted the
					buffer pool (for big transactions,
					InnoDB stores the lock structs in the
					buffer pool) */

	DB_FOREIGN_DUPLICATE_KEY,	/*!< Foreign key constraints
					activated but the operation would
					lead to a duplicate key in some
					table */

	DB_TOO_MANY_CONCURRENT_TRXS,	/*!< When InnoDB runs out of the
					preconfigured undo slots, this can
					only happen when there are too many
					concurrent transactions */

	DB_UNSUPPORTED,			/*!< When InnoDB sees any artefact or
					a feature that it can't recoginize or
					work with e.g., FT indexes created by
					a later version of the engine. */

	DB_PRIMARY_KEY_IS_NULL,		/*!< A column in the PRIMARY KEY
					was found to be NULL */

	DB_FATAL,			/*!< The application should clean up
					and quite ASAP. Fatal error, InnoDB
					cannot continue operation without
					risking database corruption. */

	/* The following are partial failure codes */
	DB_FAIL = 1000,			/*!< Partial failure code. */

	DB_OVERFLOW,			/*!< If an update or insert of a record
					doesn't fit in a Btree page */

	DB_UNDERFLOW,			/*!< If an update or delete of a
					record causes a Btree page to be below
					a minimum threshold */

	DB_STRONG_FAIL,			/*!< Failure to insert a secondary
					index entry to the insert buffer */

	DB_ZIP_OVERFLOW,		/*!< Failure trying to compress
					a page */

	DB_RECORD_NOT_FOUND = 1500,	/*!< Record not found */

	DB_END_OF_INDEX,		/*!< A cursor operation or search
					operation scanned to the end of the
					index. */

	/* The following are API only error codes. */
	DB_SCHEMA_ERROR = 2000,		/*!< Generic schema error */

	DB_DATA_MISMATCH,		/*!< Column update or read failed
					because the types mismatch */

	DB_SCHEMA_NOT_LOCKED,		/*!< If an API function expects the
					schema to be locked in exclusive mode
					and if it's not then that API function
					will return this error code */

	DB_NOT_FOUND,			/*!< Generic error code for "Not found"
					type of errors */

	DB_READONLY,			/*!< Generic error code for "Readonly"
					type of errors */

	DB_INVALID_INPUT,		/*!< Generic error code for "Invalid
					input" type of errors */
};
/* API_END_INCLUDE */
#endif
/******************************************************
Contains InnoDB DDL operations. 

(c) 2008 Oracle Corpn/Innobase Oy

Created 12 Oct 2008
*******************************************************/

#ifndef ddl0ddl_h
#define ddl0ddl_h

#include "univ.i"
#include "trx0types.h"
#include "dict0types.h"

/*************************************************************************
Get the background drop list length. NOTE: the caller must own the kernel
mutex!
@return	how many tables in list */
UNIV_INTERN
ulint
ddl_get_background_drop_list_len_low(void);
/*======================================*/

/*************************************************************************
Creates a table, if the name of the table ends in one of "innodb_monitor",
"innodb_lock_monitor", "innodb_tablespace_monitor", "innodb_table_monitor",
then this will also start the printing of monitor output by the master
thread. If the table name ends in "innodb_mem_validate", InnoDB will
try to invoke mem_validate().
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_create_table(
/*=============*/
	dict_table_t*	table,		/*!< in: table definition */
	trx_t*		trx);		/*!< in: transaction handle */

/*************************************************************************
Does an index creation operation. TODO: currently failure to create an
index results in dropping the whole table! This is no problem currently
as all indexes must be created at the same time as the table.
@return	error number or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_create_index(
/*=============*/
	dict_index_t*	index,		/*!< in: index definition */
	trx_t*		trx);		/*!< in: transaction handle */

/*************************************************************************
Drops a table but does not commit the transaction.  If the
name of the dropped table ends in one of "innodb_monitor",
"innodb_lock_monitor", "innodb_tablespace_monitor",
"innodb_table_monitor", then this will also stop the printing of
monitor output by the master thread.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_drop_table(
/*===========*/
	const char*	name,		/*!< in: table name */
	trx_t*		trx,		/*!< in: transaction handle */
	ibool		drop_db);	/*!< in: TRUE=dropping whole database */

/*************************************************************************
Drops an index.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_drop_index(
/*===========*/
	dict_table_t*	table,		/*!< in: table instance */
	dict_index_t*	index,		/*!< in: id of index to drop */
	trx_t*		trx);		/*!< in: transaction handle */

/*************************************************************************
The master thread in srv0srv.c calls this regularly to drop tables which
we must drop in background after queries to them have ended. Such lazy
dropping of tables is needed in ALTER TABLE on Unix.
@return	how many tables dropped + remaining tables in list */
UNIV_INTERN
ulint
ddl_drop_tables_in_background(void);
/*===============================*/

/*************************************************************************
Truncates a table
@return	error code or DB_SUCCESS */
UNIV_INTERN
enum db_err
ddl_truncate_table(
/*===============*/
	dict_table_t*	table,		/*!< in: table handle */
	trx_t*		trx);		/*!< in: transaction handle */
/*************************************************************************
Renames a table.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_rename_table(
/*=============*/
	const char*	old_name,	/*!< in: old table name */
	const char*	new_name,	/*!< in: new table name */
	trx_t*		trx);		/*!< in: transaction handle */

/*************************************************************************
Renames an index.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_rename_index(
/*=============*/
	const char*	table_name,	/*!< in: table that owns the index */
	const char*	old_name,	/*!< in: old table name */
	const char*	new_name,	/*!< in: new table name */
	trx_t*		trx);		/*!< in: transaction handle */

/*************************************************************************
Drops a database.
@return	error code or DB_SUCCESS */
UNIV_INTERN
enum db_err
ddl_drop_database(
/*==============*/
	const char*	name,		/*!< in: database name which ends
					in '/' */
	trx_t*		trx);		/*!< in: transaction handle */
/*********************************************************************//**
Drop all partially created indexes. */
UNIV_INTERN
void
ddl_drop_all_temp_indexes(
/*======================*/
	ib_recovery_t	recovery);	/*!< in: recovery level setting */
/*********************************************************************//**
Drop all temporary tables. */
UNIV_INTERN
void
ddl_drop_all_temp_tables(
/*=====================*/
	ib_recovery_t	recovery);	/*!< in: recovery level setting */
#endif /* ddl0ddl_h */


=== IMPLEMENTATION ===

/***********************************************************************
Copyright (c) 2008 Innobase Oy. All rights reserved.
Copyright (c) 2008 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "ib0config.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "univ.i"
#include "api0api.h"
#include "api0misc.h"
#include "srv0start.h"
#include "dict0dict.h"
#include "btr0pcur.h"
#include "row0ins.h"
#include "row0upd.h"
#include "row0vers.h"
#include "row0prebuilt.h"
#include "trx0roll.h"
#include "ddl0ddl.h"
#include "dict0crea.h"
#include "row0merge.h"
#include "pars0pars.h"
#include "api0ucode.h"
#include "lock0types.h"
#include "row0sel.h"
#include "lock0lock.h"
#include "rem0cmp.h"
#include "ut0dbg.h" /* for UT_DBG_ENTER_FUNC */

UNIV_STATIC const char* GEN_CLUST_INDEX = "GEN_CLUST_INDEX";

/* All InnoDB error messages are written to this stream. */
ib_logger_t	ib_logger;
ib_stream_t	ib_stream;

/* This must hold. */
#if IB_TRUE != TRUE || IB_FALSE != FALSE
#error IB_TRUE != TRUE or IB_FALSE != FALSE
#endif

UNIV_STATIC int				api_api_enter_func_enabled = 0;
#define UT_DBG_ENTER_FUNC_ENABLED	api_api_enter_func_enabled

/* Protected by the schema lock */
typedef struct ib_db_format_t {
	ulint		id;		/* Numeric representation
					of database format */

	const char*	name;		/* Text representation of name,
					allocated using ut_malloc() and
					should be automatically freed at
					InnoDB shutdown */
} ib_db_format_t;

/* This value is read at database startup. */
UNIV_STATIC ib_db_format_t db_format;

/*************************************************************//**
@file api/api0api.c
Does a simple memcmp(3).
@return	1, 0, -1, if a is greater, equal, less than b, respectively */
UNIV_STATIC
int
ib_default_compare(
/*===============*/
	const ib_col_meta_t*
			col_meta,	/*!< in: column meta data */
	const ib_byte_t*p1,		/*!< in: packed key */
	ib_ulint_t	p1_len,		/*!< in: packed key length */
	const ib_byte_t*p2,		/*!< in: packed key */
	ib_ulint_t	p2_len);	/*!< in: packed key length */

ib_client_cmp_t	ib_client_compare = ib_default_compare;

/* InnoDB tuple types. */
typedef enum ib_tuple_type_enum {
	TPL_ROW,			/* Data row tuple */
	TPL_KEY				/* Index key tuple */
} ib_tuple_type_t;

/* Query types supported. */
typedef enum ib_qry_type_enum {
	QRY_NON,			/* None/Sentinel */
	QRY_INS,			/* Insert operation */
	QRY_UPD,			/* Update operation */
	QRY_SEL				/* Select operation */
} ib_qry_type_t;

/* Query graph types. */
typedef struct ib_qry_grph_struct {
	que_fork_t*	ins;		/* Innobase SQL query graph used
					in inserts */
	que_fork_t*	upd;		/* Innobase SQL query graph used
					in updates or deletes */
	que_fork_t*	sel;		/* dummy query graph used in
					selects */

} ib_qry_grph_t;

/* Query node types. */
typedef struct ib_qry_node_struct {
	ins_node_t*	ins;		/* Innobase SQL insert node
					used to perform inserts to the table */
	upd_node_t*	upd;		/* Innobase SQL update node
					used to perform updates and deletes */
	sel_node_t*	sel;		/* Innobase SQL select node
					used to perform selects on the table */
} ib_qry_node_t;

/* Query processing fields. */
typedef struct ib_qry_proc_struct {

	ib_qry_node_t	node;		/* Query node*/

	ib_qry_grph_t	grph;		/* Query graph */
} ib_qry_proc_t;

/* Cursor instance for traversing tables/indexes. This will eventually
become row_prebuilt_t. */
typedef struct ib_cursor_struct {
	mem_heap_t*	heap;		/* Instance heap */

	mem_heap_t*	query_heap;	/* Heap to use for query graphs */

	ib_qry_proc_t	q_proc;		/* Query processing info */

	ib_match_mode_t	match_mode;	/* ib_cursor_moveto match mode */

	row_prebuilt_t*	prebuilt;	/* For reading rows */
} ib_cursor_t;

/* InnoDB table columns used during table and index schema creation. */
typedef struct ib_col_struct {
	const char*	name;		/* Name of column */

	ib_col_type_t	ib_col_type;	/* Main type of the column */

	ulint		len;		/* Length of the column */

	ib_col_attr_t	ib_col_attr;	/* Column attributes */
} ib_col_t;

/* InnoDB index columns used during index and index schema creation. */
typedef struct ib_key_col_struct {
	const char*	name;		/* Name of column */

	ulint		prefix_len;	/* Column index prefix len or 0 */
} ib_key_col_t;

typedef struct ib_table_def_struct ib_table_def_t;

/* InnoDB index schema used during index creation */
typedef struct ib_index_def_struct {
	mem_heap_t*	heap;		/* Heap used to build this and all
					its columns in the list */

	const char*	name;		/* Index name */

	dict_table_t*	table;		/* Parent InnoDB table */

	ib_table_def_t*	schema;		/* Parent table schema that owns
					this instance */

	ibool		clustered;	/* True if clustered index */

	ibool		unique;		/* True if unique index */

	ib_vector_t*	cols;		/* Vector of columns */

	trx_t*		usr_trx;	/* User transacton covering the
					DDL operations */
} ib_index_def_t;

/* InnoDB table schema used during table creation */
struct ib_table_def_struct {
	mem_heap_t*	heap;		/* Heap used to build this and all
					its columns in the list */
	const char*	name;		/* Table name */

	ib_tbl_fmt_t	ib_tbl_fmt;	/* Row format */

	ulint		page_size;	/* Page size */

	ib_vector_t*	cols;		/* Vector of columns */

	ib_vector_t*	indexes;	/* Vector of indexes */

	dict_table_t*	table;		/* Table read from or NULL */
};

/* InnoDB tuple used for key operations. */
typedef struct ib_tuple_struct {
	mem_heap_t*		heap;	/* Heap used to build
					this and for copying
					the column values. */

	ib_tuple_type_t		type;	/* Tuple discriminitor. */

	const dict_index_t*	index;	/* Index for tuple can be either
					secondary or cluster index. */

	dtuple_t*		ptr;	/* The internal tuple
					instance */
} ib_tuple_t;

/* I can't see what merge has to do with creating an Index. */
typedef merge_index_def_t index_def_t;
typedef merge_index_field_t index_field_t;

/* The following counter is used to convey information to InnoDB
about server activity: in selects it is not sensible to call
srv_active_wake_master_thread after each fetch or search, we only do
it every INNOBASE_WAKE_INTERVAL'th step. */

#define INNOBASE_WAKE_INTERVAL	32

/*************************************************************//**
Does a simple memcmp(3).
@return	1, 0, -1, if a is greater, equal, less than b, respectively */
UNIV_STATIC
int
ib_default_compare(
/*===============*/
	const ib_col_meta_t*
			ib_col_meta,	/*!< in: column meta data */
	const ib_byte_t*p1,		/*!< in: packed key */
	ib_ulint_t	p1_len,		/*!< in: packed key length */
	const ib_byte_t*p2,		/*!< in: packed key */
	ib_ulint_t	p2_len)		/*!< in: packed key length */
{
	int		ret;

	UT_DBG_ENTER_FUNC;

	ret = memcmp(p1, p2, ut_min(p1_len, p2_len));

	if (ret == 0) {
		ret = p1_len - p2_len;
	}

	return(ret < 0 ? -1 : ((ret > 0) ? 1 : 0));
}

/*****************************************************************//**
Check if the Innodb persistent cursor is positioned.
@return	IB_TRUE if positioned */
UNIV_INLINE
ib_bool_t
ib_btr_cursor_is_positioned(
/*========================*/
	btr_pcur_t*	pcur)		/*!< in: InnoDB persistent cursor */
{
	return(pcur->old_stored == BTR_PCUR_OLD_STORED
	       && (pcur->pos_state == BTR_PCUR_IS_POSITIONED
	           || pcur->pos_state == BTR_PCUR_WAS_POSITIONED));
}

/*******************************************************************//**
Delays an INSERT, DELETE or UPDATE operation if the purge is lagging. */
UNIV_STATIC
void
ib_delay_dml_if_needed(void)
/*========================*/
{
	if (srv_dml_needed_delay) {
		os_thread_sleep(srv_dml_needed_delay);
	}
}

/********************************************************************//**
Open a table using the table id, if found then increment table ref count.
@return	table instance if found */
UNIV_STATIC
dict_table_t*
ib_open_table_by_id(
/*================*/
	ib_id_t		tid,		/*!< in: table id to lookup */
	ib_bool_t	locked)		/*!< in: TRUE if own dict mutex */
{
	dict_table_t*	table;
	dulint		table_id;

	UT_DBG_ENTER_FUNC;

	/* We only return the lower 32 bits of the dulint. */
	ut_a(tid < 0xFFFFFFFFULL);
	table_id = ut_dulint_create(0, (ulint) tid);

	if (!locked) {
		dict_mutex_enter();
	}

	table = dict_table_get_using_id(srv_force_recovery, table_id, TRUE);

	if (table != NULL && table->ibd_file_missing) {

		ib_logger(ib_stream,
			"The .ibd file for table %s is missing.\n",
			table->name);

		dict_table_decrement_handle_count(table, TRUE);

		table = NULL;
	}

	if (!locked) {
		dict_mutex_exit();
	}

	return(table);
}

/********************************************************************//**
Open a table using the table name, if found then increment table ref count.
@return	table instance if found */
UNIV_STATIC
dict_table_t*
ib_open_table_by_name(
/*==================*/
	const char*	name)		/*!< in: table name to lookup */
{
	dict_table_t*	table;

	UT_DBG_ENTER_FUNC;

	table = dict_table_get(name, TRUE);

	if (table != NULL && table->ibd_file_missing) {

		ib_logger(ib_stream, "The .ibd file for table %s is missing.\n",
			  name);

		dict_table_decrement_handle_count(table, FALSE);

		table = NULL;
	}

	return(table);
}

/********************************************************************//**
Find table using table name.
@return	table instance if found */
UNIV_STATIC
dict_table_t*
ib_lookup_table_by_name(
/*====================*/
	const char*	name)		/*!< in: table name to lookup */
{
	dict_table_t*	table;

	UT_DBG_ENTER_FUNC;

	table = dict_table_get_low(name);

	if (table != NULL && table->ibd_file_missing) {

		ib_logger(ib_stream, "The .ibd file for table %s is missing.\n",
			  name);

		table = NULL;
	}

	return(table);
}

/********************************************************************//**
Increments innobase_active_counter and every INNOBASE_WAKE_INTERVALth
time calls srv_active_wake_master_thread. This function should be used
when a single database operation may introduce a small need for
server utility activity, like checkpointing. */
UNIV_INLINE
void
ib_wake_master_thread(void)
/*=======================*/
{
	static ulint	ib_signal_counter = 0;

	UT_DBG_ENTER_FUNC;

	++ib_signal_counter;

	if ((ib_signal_counter % INNOBASE_WAKE_INTERVAL) == 0) {
		srv_active_wake_master_thread();
	}
}

#if 0

/*****************************************************************//**
Calculate the length of the column data less trailing space. */
UNIV_STATIC
ulint
ib_varchar_len(
/*===========*/
	const dtype_t*	dtype,
	ib_byte_t*	ptr,
	ulint		len)
{
	/* Handle UCS2 strings differently. */
	ulint		mbminlen = dtype_get_mbminlen(dtype);

	if (mbminlen == 2) {
		/* SPACE = 0x0020. */
		/* Trim "half-chars", just in case. */
		len &= ~1;

		while (len >= 2
		       && ptr[len - 2] == 0x00
		       && ptr[len - 1] == 0x20) {

			len -= 2;
		}

	} else {
		ut_a(mbminlen == 1);

		/* SPACE = 0x20. */
		while (len > 0 && ptr[len - 1] == 0x20) {

			--len;
		}
	}

	return(len);
}

#endif

/*********************************************************************//**
Calculate the max row size of the columns in a cluster index.
@return	max row length */
UNIV_INLINE
ulint
ib_get_max_row_len(
/*===============*/
	dict_index_t*	cluster)		/*!< in: cluster index */
{
	ulint		i;
	ulint		max_len = 0;
	ulint		n_fields = cluster->n_fields;

	UT_DBG_ENTER_FUNC;

	/* Add the size of the ordering columns in the
	clustered index. */
	for (i = 0; i < n_fields; ++i) {
		const dict_col_t*	col;

		col = dict_index_get_nth_col(cluster, i);

		/* Use the maximum output size of
		mach_write_compressed(), although the encoded
		length should always fit in 2 bytes. */
		max_len += dict_col_get_max_size(col);
	}

	return(max_len);
}

/*****************************************************************//**
Read the colums from a rec into a tuple. */
UNIV_INLINE
void
ib_read_tuple(
/*==========*/
	ib_cursor_t*	cursor,		/*!< in: InnoDB cursor instance */
	const rec_t*	rec,		/*!< in: Record to read */
	ib_bool_t	page_format,	/*!< in: IB_TRUE if compressed format */
	ib_tuple_t*	tuple)		/*!< in: tuple to read into */
{
	ulint		i;
	void*		ptr;
	rec_t*		copy;
	ulint		rec_meta_data;
	ulint		n_index_fields;
	ulint		offsets_[REC_OFFS_NORMAL_SIZE];
	ulint*		offsets	= offsets_;
	dtuple_t*	dtuple = tuple->ptr;
	const dict_index_t* index = tuple->index;

	UT_DBG_ENTER_FUNC;

	rec_offs_init(offsets_);

	offsets = rec_get_offsets(
		rec, index, offsets, ULINT_UNDEFINED, &tuple->heap);

	rec_meta_data = rec_get_info_bits(rec, page_format);
	dtuple_set_info_bits(dtuple, rec_meta_data);

	/* Make a copy of the rec. */
	ptr = mem_heap_alloc(tuple->heap, rec_offs_size(offsets));
	copy = rec_copy(ptr, rec, offsets);

	/* Avoid a debug assertion in rec_offs_validate(). */
	rec_offs_make_valid(rec, index, (ulint*) offsets);

	n_index_fields = ut_min(
		rec_offs_n_fields(offsets), dtuple_get_n_fields(dtuple));

	for (i = 0; i < n_index_fields; ++i) {
		ulint		len;
		const byte*	data;
		dfield_t*	dfield;

		if (tuple->type == TPL_ROW) {
			const dict_col_t*	col;
			ulint			col_no;
			const dict_field_t*	index_field;

			index_field = dict_index_get_nth_field(index, i);
			col = dict_field_get_col(index_field);
			col_no = dict_col_get_no(col);

			dfield = dtuple_get_nth_field(dtuple, col_no);
		} else {
			dfield = dtuple_get_nth_field(dtuple, i);
		}

		data = rec_get_nth_field(copy, offsets, i, &len);

		/* Fetch and copy any externally stored column. */
		if (rec_offs_nth_extern(offsets, i)) {

			ulint	zip_size;

			zip_size = dict_table_zip_size(index->table);

			data = btr_rec_copy_externally_stored_field(
				copy, offsets, zip_size, i, &len,
				tuple->heap);

			ut_a(len != UNIV_SQL_NULL);
		}

		dfield_set_data(dfield, data, len);
	}
}

/*****************************************************************//**
Create an InnoDB key tuple.
@return	tuple instance created, or NULL */
UNIV_STATIC
ib_tpl_t
ib_key_tuple_new_low(
/*=================*/
	const dict_index_t*	index,	/*!< in: index for which tuple required */
	ulint			n_cols,	/*!< in: no. of user defined cols */
	mem_heap_t*		heap)	/*!< in: memory heap */
{
	ib_tuple_t*	tuple;
	ulint		i;
	ulint		n_cmp_cols;

	UT_DBG_ENTER_FUNC;

	tuple = mem_heap_alloc(heap, sizeof(*tuple));

	if (tuple == NULL) {
		mem_heap_free(heap);
		return(NULL);
	}

	tuple->heap  = heap;
	tuple->index = index;
	tuple->type  = TPL_KEY;

	/* Is it a generated clustered index ? */
	if (n_cols == 0) {
		++n_cols;
	}

	tuple->ptr = dtuple_create(heap, n_cols);

	/* Copy types and set to SQL_NULL. */
	dict_index_copy_types(tuple->ptr, index, n_cols);

	for (i = 0; i < n_cols; i++) {

		dfield_t*	dfield;

		dfield	= dtuple_get_nth_field(tuple->ptr, i);
		dfield_set_null(dfield);
	}

	n_cmp_cols = dict_index_get_n_ordering_defined_by_user(index);

	dtuple_set_n_fields_cmp(tuple->ptr, n_cmp_cols);

	return((ib_tpl_t) tuple);
}

/*****************************************************************//**
Create an InnoDB key tuple.
@return	tuple instance created, or NULL */
UNIV_STATIC
ib_tpl_t
ib_key_tuple_new(
/*=============*/
	const dict_index_t*	index,	/*!< in: index of tuple */
	ulint			n_cols)	/*!< in: no. of user defined cols */
{
	mem_heap_t*	heap;

	UT_DBG_ENTER_FUNC;

	heap = mem_heap_create(64);

	if (heap == NULL) {
		return(NULL);
	}

	return(ib_key_tuple_new_low(index, n_cols, heap));
}

/*****************************************************************//**
Create an InnoDB row tuple.
@return	tuple instance, or NULL */
UNIV_STATIC
ib_tpl_t
ib_row_tuple_new_low(
/*=================*/
	const dict_index_t*	index,	/*!< in: index of tuple */
	ulint			n_cols,	/*!< in: no. of cols in tuple */
	mem_heap_t*		heap)	/*!< in: memory heap */
{
	ib_tuple_t*	tuple;

	UT_DBG_ENTER_FUNC;

	tuple = mem_heap_alloc(heap, sizeof(*tuple));

	if (tuple == NULL) {
		mem_heap_free(heap);
		return(NULL);
	}

	tuple->heap  = heap;
	tuple->index = index;
	tuple->type  = TPL_ROW;

	tuple->ptr = dtuple_create(heap, n_cols);

	/* Copy types and set to SQL_NULL. */
	dict_table_copy_types(tuple->ptr, index->table);

	return((ib_tpl_t) tuple);
}

/*****************************************************************//**
Create an InnoDB row tuple.
@return	tuple instance, or NULL */
UNIV_STATIC
ib_tpl_t
ib_row_tuple_new(
/*=============*/
	const dict_index_t*	index,	/*!< in: index of tuple */
	ulint			n_cols)	/*!< in: no. of cols in tuple */
{
	mem_heap_t*	heap;

	UT_DBG_ENTER_FUNC;

	heap = mem_heap_create(64);

	if (heap == NULL) {
		return(NULL);
	}

	return(ib_row_tuple_new_low(index, n_cols, heap));
}

/*****************************************************************//**
Return the API version number, the version number format is:
| 16 bits future use | 16 bits current | 16 bits revision | 16 bits age |

- If the library source code has changed at all since the last release,
  then revision will be incremented (`c:r:a' becomes `c:r+1:a').
- If any interfaces have been added, removed, or changed since the last
  update, current will be incremented, and revision will be set to 0.
- If any interfaces have been added (but not changed or removed) since
  the last release, then age will be incremented.
- If any interfaces have been changed or removed since the last release,
  then age will be set to 0.

@return	API version number */

ib_u64_t
ib_api_version(void)
/*================*/
{
	return(((ib_u64_t) IB_API_VERSION_CURRENT << 32)
	       | (IB_API_VERSION_REVISION << 16)
	       | IB_API_VERSION_AGE);
}

/*****************************************************************//**
Initialize the InnoDB engine. This must be called prior to calling
any other InnoDB API function.
@return	DB_SUCCESS or error code */

ib_err_t
ib_init(void)
/*=========*/
{
	ib_err_t	ib_err;

	fprintf(stderr, "ib_init: start\n");

	ut_mem_init();
	fprintf(stderr, "ib_init: memory subsystem initialized\n");

	ib_logger = (ib_logger_t) fprintf;
	ib_stream = stderr;

	ib_err = ib_cfg_init();
	fprintf(stderr, "ib_init: ib_cfg_init returned %d\n", ib_err);

	return(ib_err);
}

/*****************************************************************//**
Startup the InnoDB engine.
@return	DB_SUCCESS or error code */

ib_err_t
ib_startup(
/*=======*/
	const char*	format)	/*!< in: file format name */
{
	ib_err_t	err = DB_SUCCESS;

	UT_DBG_ENTER_FUNC;

	db_format.id = 0;
	db_format.name = NULL;

	/* Validate the file format if set by the user. */
	if (format != NULL) {
		db_format.id = trx_sys_file_format_name_to_id(format);

		/* Check if format name was found. */
		if (db_format.id > DICT_TF_FORMAT_MAX) {
			err = DB_UNSUPPORTED;

			ib_logger(ib_stream, "InnoDB: format '%s' unknown.",
				  format);
		}
	}

	if (err == DB_SUCCESS) {

		db_format.name = trx_sys_file_format_id_to_name(db_format.id); 

		/* Set the highest file format id supported. */
		srv_file_format = db_format.id;

		err = innobase_start_or_create();
	}

	return(err);
}

/*****************************************************************//**
Shutdown the InnoDB engine.
@return	DB_SUCCESS or error code */

ib_err_t
ib_shutdown(
/*========*/
	ib_shutdown_t	flag)		/*!< in: Shutdown flags */
{
	ib_err_t	err;

	err = ib_cfg_shutdown();
	if (err != DB_SUCCESS) {
		ib_logger(ib_stream, "ib_cfg_shutdown(): %s; "
			  "continuing shutdown anyway\n",
			  ib_strerror(err));
	}

	db_format.id = 0;
	db_format.name = NULL;

	err = innobase_shutdown(flag);

	return(err);
}

/*****************************************************************//**
Begin a transaction.
@return	innobase txn handle */

ib_err_t
ib_trx_start(
/*=========*/
	ib_trx_t	ib_trx,		/*!< in: transaction to restart */
	ib_trx_level_t	ib_trx_level)	/*!< in: trx isolation level */
{
	ib_err_t	err = DB_SUCCESS;
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	ut_a(ib_trx_level >= IB_TRX_READ_UNCOMMITTED);
	ut_a(ib_trx_level <= IB_TRX_SERIALIZABLE);

	ut_ad(trx->client_thread_id == os_thread_get_curr_id());

	if (trx->conc_state == TRX_NOT_STARTED) {
		ib_bool_t	started;

		started = trx_start(trx, ULINT_UNDEFINED);
		ut_a(started);

		trx->isolation_level = ib_trx_level;
	} else {
		err = DB_ERROR;
	}

	/* FIXME: This is a place holder, we should add an arg that comes
	from the client. */
	trx->client_thd = trx;

	return(err);
}

/*****************************************************************//**
Begin a transaction. This will allocate a new transaction handle.
@return	innobase txn handle */

ib_trx_t
ib_trx_begin(
/*=========*/
	ib_trx_level_t	ib_trx_level)	/*!< in: trx isolation level */
{
	trx_t*		trx;
	ib_bool_t	started;

	UT_DBG_ENTER_FUNC;

	trx = trx_allocate_for_client(NULL);
	started = ib_trx_start((ib_trx_t) trx, ib_trx_level);
	ut_a(started);

	return((ib_trx_t) trx);
}

/*****************************************************************//**
Get the transaction's state.
@return	transaction state */

ib_trx_state_t
ib_trx_state(
/*=========*/
	ib_trx_t	ib_trx)		/*!< in: trx handle */
{
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	return((ib_trx_state_t) trx->conc_state);
}

/*****************************************************************//**
Release the resources of the transaction.
@return	DB_SUCCESS or err code */

ib_err_t
ib_trx_release(
/*===========*/
	ib_trx_t	ib_trx)		/*!< in: trx handle */
{
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	ut_ad(trx != NULL);
	trx_free_for_client(trx);

	return(DB_SUCCESS);
}

/*****************************************************************//**
Commit a transaction. This function will also release the schema
latches too.
@return	DB_SUCCESS or err code */

ib_err_t
ib_trx_commit(
/*==========*/
	ib_trx_t	ib_trx)		/*!< in: trx handle */
{
	ib_err_t	err;
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	err = trx_commit(trx);

        /* It should always succeed */
        ut_a(err == DB_SUCCESS);

	ib_schema_unlock(ib_trx);

	err = ib_trx_release(ib_trx);
	ut_a(err == DB_SUCCESS);

	ib_wake_master_thread();

	return(DB_SUCCESS);
}

/*****************************************************************//**
Rollback a transaction. This function will also release the schema
latches too.
@return	DB_SUCCESS or err code */

ib_err_t
ib_trx_rollback(
/*============*/
	ib_trx_t	ib_trx)		/*!< in: trx handle */
{
	ib_err_t	err;
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	err = trx_general_rollback(trx, FALSE, NULL);

        /* It should always succeed */
        ut_a(err == DB_SUCCESS);

	ib_schema_unlock(ib_trx);

	err = ib_trx_release(ib_trx);
	ut_a(err == DB_SUCCESS);

	ib_wake_master_thread();

	return(err);
}

/*****************************************************************//**
Check that the combination of values and name makes sense.
@return	TRUE if OK */
UNIV_INLINE
ibool
ib_check_col_is_ok(
/*===============*/
	const char*	name,		/*!< in: column name */
	ib_col_type_t	ib_col_type,	/*!< in: column type */
	ib_col_attr_t	ib_col_attr,	/*!< in: column attribute */
	ib_ulint_t	len)		/*!< in: length of the column */
{
	UT_DBG_ENTER_FUNC;

	if (ut_strlen(name) > IB_MAX_COL_NAME_LEN) {
		return(FALSE);
	} else if ((ib_col_type == IB_VARCHAR
		    || ib_col_type == IB_CHAR
		    || ib_col_type == IB_BINARY)
		   && len == 0) {
		return(FALSE);
	} else if (ib_col_type == IB_INT) {
		switch (len) {
		case 1: case 2: case 4: case 8:
			break;
		default:
			return(FALSE);
		}
	} else if (ib_col_type == IB_FLOAT && len != 4) {
		return(FALSE);
	} else if (ib_col_type == IB_DOUBLE && len != 8) {
		return(FALSE);
	}

	return(TRUE);
}

/*****************************************************************//**
Find an index definition from the index vector using index name.
@return	index def. if found else NULL */
UNIV_INLINE
const ib_index_def_t*
ib_table_find_index(
/*================*/
	ib_vector_t*	indexes,	/*!< in: vector of indexes */
	const char*	name)		/*!< in: index name */
{
	ulint		i;

	UT_DBG_ENTER_FUNC;

	for (i = 0; i < ib_vector_size(indexes); ++i) {
		const ib_index_def_t*	index_def;

		index_def = (ib_index_def_t*) ib_vector_get(indexes, i);

		if (ib_utf8_strcasecmp(name, index_def->name) == 0) {
			return(index_def);
		}
	}

	return(NULL);
}

/*****************************************************************//**
Get the InnoDB internal precise type from the schema column definition.
@return	precise type in api format */
UNIV_INLINE
ulint
ib_col_get_prtype(
/*==============*/
	const ib_col_t*	ib_col)		/*!< in: column definition */
{
	ulint		prtype = 0;

	UT_DBG_ENTER_FUNC;

	if (ib_col->ib_col_attr & IB_COL_UNSIGNED) {
		prtype |= DATA_UNSIGNED;

		ut_a(ib_col->ib_col_type == IB_INT);
	}

	if (ib_col->ib_col_attr & IB_COL_NOT_NULL) {
		prtype |= DATA_NOT_NULL;
	}

	if (ib_col->ib_col_attr & IB_COL_CUSTOM1) {
		prtype |= DATA_CUSTOM_TYPE;
	}

	if (ib_col->ib_col_attr & IB_COL_CUSTOM2) {
		prtype |= (DATA_CUSTOM_TYPE << 1);
	}

	if (ib_col->ib_col_attr & IB_COL_CUSTOM3) {
		prtype |= (DATA_CUSTOM_TYPE << 2);
	}

	return(prtype);
}

/*****************************************************************//**
Get the InnoDB internal main type from the schema column definition.
@return	column main type */
UNIV_INLINE
ulint
ib_col_get_mtype(
/*==============*/
	const ib_col_t*	ib_col)		/*!< in: column definition */
{
	UT_DBG_ENTER_FUNC;

	/* Note: The api0api.h types should map directly to
	the internal numeric codes. */
	return(ib_col->ib_col_type);
}

/*****************************************************************//**
Find a column in the the column vector with the same name.
@return	col. def. if found else NULL */
UNIV_INLINE
const ib_col_t*
ib_table_find_col(
/*==============*/
	const ib_vector_t*	cols,	/*!< in: column list head */
	const char*	name)		/*!< in: column name to find */
{
	ulint		i;

	UT_DBG_ENTER_FUNC;

	for (i = 0; i < ib_vector_size(cols); ++i) {
		const ib_col_t*	ib_col;

		ib_col = ib_vector_get((ib_vector_t*) cols, i);

		if (ib_utf8_strcasecmp(ib_col->name, name) == 0) {
			return(ib_col);
		}
	}

	return(NULL);
}

/*****************************************************************//**
Find a column in the the column list with the same name.
@return	col. def. if found else NULL */
UNIV_INLINE
const ib_key_col_t*
ib_index_find_col(
/*==============*/
	ib_vector_t*	cols,		/*!< in: column list head */
	const char*	name)		/*!< in: column name to find */
{
	ulint		i;

	UT_DBG_ENTER_FUNC;

	for (i = 0; i < ib_vector_size(cols); ++i) {
		const ib_key_col_t*	ib_col;

		ib_col = ib_vector_get(cols, i);

		if (ib_utf8_strcasecmp(ib_col->name, name) == 0) {
			return(ib_col);
		}
	}

	return(NULL);
}

/*****************************************************************//**
Add columns to a table schema.
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_schema_add_col(
/*====================*/
	ib_tbl_sch_t	ib_tbl_sch,	/*!< in: schema instance */
	const char*	name,		/*!< in: name of column */
	ib_col_type_t	ib_col_type,	/*!< in: column main type */
	ib_col_attr_t	ib_col_attr,	/*!< in: column attributes */
	ib_u16_t	client_type,	/*!< in: any 16 bit number relevant
					only to the client */
	ib_ulint_t	len)		/*!< in: max length of column */
{
	ib_col_t*	ib_col;
	ib_err_t	err = DB_SUCCESS;
	ib_table_def_t* table_def = (ib_table_def_t*) ib_tbl_sch;

	UT_DBG_ENTER_FUNC;

	if (table_def->table != NULL) {
		err = DB_ERROR;
	} else if (ib_table_find_col(table_def->cols, name) != NULL) {
		err = DB_DUPLICATE_KEY;
	} else if (!ib_check_col_is_ok(name, ib_col_type, ib_col_attr, len)) {
		err = DB_ERROR;
	} else {
		mem_heap_t*	heap;

		heap = table_def->heap;

		ib_col = (ib_col_t*) mem_heap_zalloc(heap, sizeof(*ib_col));

		if (ib_col == NULL) {
			err = DB_OUT_OF_MEMORY;
		} else {
			ib_col->name = mem_heap_strdup(heap, name);
			ib_col->ib_col_type = ib_col_type;
			ib_col->ib_col_attr = ib_col_attr;

			ib_col->len = len;

			ib_vector_push(table_def->cols, ib_col);
		}
	}

	return(err);
}

/*****************************************************************//**
Create and add an index key definition to a table schema. The index
schema is owned by the table schema instance and will be freed when
the table schema instance is freed.
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_schema_add_index(
/*======================*/
	ib_tbl_sch_t	ib_tbl_sch,	/*!< in/out: schema instance */
	const char*	name,		/*!< in: key defn. name to create */
	ib_idx_sch_t*	ib_idx_sch)	/*!< out: key definition instance */
{
	ib_err_t	err = DB_SUCCESS;
	ib_table_def_t* table_def = (ib_table_def_t*) ib_tbl_sch;

	UT_DBG_ENTER_FUNC;

	if (table_def->table != NULL) {
		err = DB_ERROR;
	} else if (ib_utf8_strcasecmp(name, GEN_CLUST_INDEX) == 0) {
		return(DB_INVALID_INPUT);
	} if (ib_table_find_index(table_def->indexes, name) != NULL) {
		err = DB_DUPLICATE_KEY;
	} else {
		ib_index_def_t*	index_def;
		mem_heap_t*	heap = table_def->heap;

		index_def = (ib_index_def_t*) mem_heap_zalloc(
			heap, sizeof(*index_def));

		if (index_def == NULL) {
			err = DB_OUT_OF_MEMORY;
		} else {

			index_def->heap = heap;

			index_def->schema = table_def;

			index_def->name = mem_heap_strdup(heap, name);

			index_def->cols = ib_vector_create(heap, 8);

			ib_vector_push(table_def->indexes, index_def);

			*ib_idx_sch = (ib_idx_sch_t) index_def;
		}
	}

	return(err);
}

/*****************************************************************//**
Destroy a schema. */

void
ib_table_schema_delete(
/*===================*/
	ib_tbl_sch_t	ib_tbl_sch)	/*!< in, own: table schema to delete */
{
	ulint		i;
	ib_table_def_t*	table_def = (ib_table_def_t*) ib_tbl_sch;

	UT_DBG_ENTER_FUNC;

	/* Check that all indexes are owned by the table schema. */
	for (i = 0; i < ib_vector_size(table_def->indexes); ++i) {
		ib_index_def_t*	index_def;

		index_def = (ib_index_def_t*) ib_vector_get(
			table_def->indexes, i);

		ut_a(index_def->schema != NULL);
	}

	if (table_def->table != NULL) {
		dict_table_decrement_handle_count(table_def->table, FALSE);
	}

	mem_heap_free(table_def->heap);
}

/*****************************************************************//**
Do some table page size validation. It should be set only
when ib_tbl_fmt == IB_TBL_COMPRESSED. */
UNIV_STATIC
ib_err_t
ib_table_schema_check(
/*==================*/
	ib_tbl_fmt_t	ib_tbl_fmt,	/*!< in: table format */
	ib_ulint_t*	page_size)	/*!< in,out: page size requested */
{
	ib_err_t	err = DB_SUCCESS;

#ifndef WITH_ZIP
	if (ib_tbl_fmt == IB_TBL_COMPRESSED) {
		return(DB_UNSUPPORTED);
	}
#endif /* WITH_ZIP */
	if (ib_tbl_fmt != IB_TBL_COMPRESSED) {
		/* Page size set but table format is not set to compressed.
		Reset to 0 since we ignore such values. */
		*page_size = 0;
	}

	switch (*page_size) {
	case 0:
		/* The page size value will be ignored for
		uncompressed tables. */
		if (ib_tbl_fmt == IB_TBL_COMPRESSED) {
			/* Set to the system default of 8K page size.
			Better to be conservative here. */
			*page_size = 8;
			/* Fall through. */
		} else {
			break;
		}
	case 1: case 2: case 4: case 8: case 16:
		if (!srv_file_per_table) {
			/* Compressed tables require file per table. */
			err = DB_UNSUPPORTED;
		} else if (srv_file_format < DICT_TF_FORMAT_ZIP) {
			/* File format unsuitable for compressed tables. */
			err = DB_UNSUPPORTED;
		}
		break;
	default:
		/* Unknown page size. */
		 err = DB_UNSUPPORTED;
		 break;
	}

	return(err);
}

#ifdef __WIN__
/*****************************************************************//**
Convert a string to lower case. */
UNIV_STATIC
void
ib_to_lower_case(
/*=============*/
	char*		ptr)		/*!< string to convert to lower case */
{
	while (*ptr) {
		*ptr = tolower(*ptr);
		++ptr;
	}
}
#endif /* __WIN__ */

/*****************************************************************//**
Normalizes a table name string. A normalized name consists of the
database name catenated to '/' and table name. An example:
test/mytable. On Windows normalization puts both the database name and the
table name always to lower case. This function can be called for system
tables and they don't have a database component. For tables that don't have
a database component, we don't normalize them to lower case on Windows.
The assumption is that they are system tables that reside in the system
table space. */
UNIV_STATIC
void
ib_normalize_table_name(
/*====================*/
	char*		norm_name,	/*!< out: normalized name as a
					null-terminated string */
	const char*	name)		/*!< in: table name string */
{
	const char*	ptr = name;

	/* Scan name from the end */

	ptr += ut_strlen(name) - 1;

	/* Find the start of the table name. */
	while (ptr >= name && *ptr != '\\' && *ptr != '/' && ptr > name) {
		--ptr;
	}


	/* For system tables there is no '/' or dbname. */
	ut_a(ptr >= name);

	if (ptr > name) {
		const char*	db_name;
		const char*	table_name;

		table_name = ptr + 1;

		--ptr;

		while (ptr >= name && *ptr != '\\' && *ptr != '/') {
			ptr--;
		}

		db_name = ptr + 1;

		memcpy(norm_name, db_name,
			ut_strlen(name) + 1 - (db_name - name));

		norm_name[table_name - db_name - 1] = '/';
#ifdef __WIN__
		ib_to_lower_case(norm_name);
#endif
	} else {
		ut_strcpy(norm_name, name);
	}
}

/*****************************************************************//**
Check whether the table name conforms to our requirements. Currently
we only do a simple check for the presence of a '/'.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_table_name_check(
/*================*/
	const char*	name)		/*!< in: table name to check */
{
	const char*	slash = NULL;
	ulint		len = ut_strlen(name);

	if (len < 2
	    || *name == '/'
	    || name[len - 1] == '/'
	    || (name[0] == '.' && name[1] == '/')
	    || (name[0] == '.' && name[1] == '.' && name[2] == '/')) {

		return(DB_DATA_MISMATCH);
	}

	for ( ; *name; ++name) {
#ifdef __WIN__
		/* Check for reserved characters in DOS filenames. */
		switch (*name) {
		case ':':
		case '|':
		case '"':
		case '*':
		case '<':
		case '>':
			return(DB_DATA_MISMATCH);
		}
#endif /* __WIN__ */
		if (*name == '/') {
			if (slash) {
				return(DB_DATA_MISMATCH);
			}
			slash = name;
		}
	}

	return(slash ? DB_SUCCESS : DB_DATA_MISMATCH);
}

/*****************************************************************//**
Create a table schema.
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_schema_create(
/*===================*/
	const char*	name,		/*!< in: table name to create */
	ib_tbl_sch_t*	ib_tbl_sch,	/*!< out: schema instance */
	ib_tbl_fmt_t	ib_tbl_fmt,	/*!< in: table format */
	ib_ulint_t	page_size)	/*!< in: Page size or 0 for default */
{
	ib_err_t	err = DB_SUCCESS;
	mem_heap_t*	heap = mem_heap_create(1024);

	UT_DBG_ENTER_FUNC;

	err = ib_table_name_check(name);

	if (err != DB_SUCCESS) {
		return(err);
	}

	err = ib_table_schema_check(ib_tbl_fmt, &page_size);
	if (err != DB_SUCCESS) {
		return(err);
	} else if (heap == NULL) {
		err  = DB_OUT_OF_MEMORY;
	} else {
		ib_table_def_t*	table_def;

		table_def = (ib_table_def_t*) mem_heap_zalloc(
			heap, sizeof(*table_def));

		if (table_def == NULL) {
			err = DB_OUT_OF_MEMORY;

			mem_heap_free(heap);
		} else {
			char*	normalized_name;

			table_def->heap = heap;

			normalized_name = mem_heap_strdup(heap, name);

			ib_normalize_table_name(normalized_name, name);

			table_def->name = normalized_name;

			table_def->page_size = page_size;

			table_def->ib_tbl_fmt = ib_tbl_fmt;

			table_def->cols = ib_vector_create(heap, 8);

			table_def->indexes = ib_vector_create(heap, 4);

			*ib_tbl_sch = (ib_tbl_sch_t) table_def;
		}
	}

	return(err);
}

/*****************************************************************//**
Get the column number within the index defnintion.
@return	-1 or column number */
UNIV_STATIC
int
ib_index_get_col_no(
/*================*/
	const ib_index_def_t*	ib_index_def,	/*!< in: index definition */
	const char*	name)		/*!< in: column name to search */
{
	int		col_no;

	UT_DBG_ENTER_FUNC;

	/* Is this column definition for an existing table ? */
	if (ib_index_def->table != NULL) {
		col_no = dict_table_get_col_no(ib_index_def->table, name);
	} else {
		ib_vector_t*	cols;
		const ib_col_t*	ib_col;

		cols = ib_index_def->schema->cols;
		ib_col = ib_table_find_col(cols, name);

		if (ib_col != NULL) {
			/* We simply note that we've found the column. */
			col_no = 0;
		} else {
			col_no = -1;
		}
	}

	return(col_no);
}

/*****************************************************************//**
Check whether a prefix length index is allowed on the column.
@return	TRUE if allowed. */
UNIV_STATIC
int
ib_index_is_prefix_allowed(
/*=======================*/
	const ib_index_def_t*	ib_index_def,	/*!< in: index definition */
	const char*	name)			/*!< in: column name to
						check */
{
	ib_bool_t	allowed = TRUE;
	ulint		mtype = ULINT_UNDEFINED;

	UT_DBG_ENTER_FUNC;

	/* Is this column definition for an existing table ? */
	if (ib_index_def->table != NULL) {
		const dict_col_t*	col;
		int			col_no;

		col_no = dict_table_get_col_no(ib_index_def->table, name);
		ut_a(col_no != -1);

		col = dict_table_get_nth_col(ib_index_def->table, col_no);
		ut_a(col != NULL);

		mtype = col->mtype;
	} else {
		const ib_vector_t*	cols;
		const ib_col_t*		ib_col;

		cols = ib_index_def->schema->cols;
		ib_col = ib_table_find_col(cols, name);

		ut_a(ib_col != NULL);

		mtype = (ulint) ib_col->ib_col_type;
	}

	/* The following column types can't have prefix column indexes. */
	switch (mtype) {
	case DATA_INT:
	case DATA_FLOAT:
	case DATA_DOUBLE:
	case DATA_DECIMAL:
		allowed = FALSE;
		break;

	case ULINT_UNDEFINED:
		ut_error;
	}

	return(allowed);
}

/*****************************************************************//**
Add columns to a schema definition.
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_add_col(
/*====================*/
	ib_idx_sch_t	ib_idx_sch,	/*!< in/out: index schema instance */
	const char*	name,		/*!< in: name of column */
	ib_ulint_t	prefix_len)	/*!< in: length of prefix or 0 */
{
	ib_err_t	err = DB_SUCCESS;
	ib_index_def_t*	index_def = (ib_index_def_t*) ib_idx_sch;

	UT_DBG_ENTER_FUNC;

	/* Check for duplicates. */
	if (ib_index_find_col(index_def->cols, name) != NULL) {
		err = DB_COL_APPEARS_TWICE_IN_INDEX;
	/* Check if the column exists in the table definition. */
	} else if (ib_index_get_col_no(index_def, name) == -1) {
		err = DB_NOT_FOUND;
	/* Some column types can't have prefix length indexes. */
	} else  if (prefix_len > 0
		    && !ib_index_is_prefix_allowed(index_def, name)) {
		err = DB_SCHEMA_ERROR;
	} else {
		mem_heap_t*	heap;
		ib_key_col_t*	ib_col;

		heap = index_def->heap;
		ib_col = (ib_key_col_t*) mem_heap_zalloc(heap, sizeof(*ib_col));

		if (ib_col == NULL) {
			err = DB_OUT_OF_MEMORY;
		} else {
			ib_col->name = mem_heap_strdup(heap, name);
			ib_col->prefix_len = prefix_len;

			ib_vector_push(index_def->cols, ib_col);
		}
	} 

	return(err);
}

/*****************************************************************//**
Create an index schema instance.
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_create(
/*===================*/
	ib_trx_t	ib_usr_trx,	/*!< in: transaction */
	const char*	name,		/*!< in: index name in schema */
	const char*	table_name,	/*!< in: table name */
	ib_idx_sch_t*	ib_idx_sch)	/*!< out: index schema instance */
{
	dict_table_t*	table = NULL;
	char*		normalized_name;
	ib_err_t	err = DB_SUCCESS;

	UT_DBG_ENTER_FUNC;

	if (!ib_schema_lock_is_exclusive(ib_usr_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	} else if (ib_utf8_strcasecmp(name, GEN_CLUST_INDEX) == 0) {
		return(DB_INVALID_INPUT);
	}

	normalized_name = mem_alloc(ut_strlen(table_name) + 1);
	ib_normalize_table_name(normalized_name, table_name);

	table = ib_lookup_table_by_name(normalized_name);

	mem_free(normalized_name);
	normalized_name = NULL;

	if (table == NULL) {
		err = DB_TABLE_NOT_FOUND;
	} else if (dict_table_get_index_on_name(table, name) != NULL) {
		err = DB_DUPLICATE_KEY;
	} else {
		mem_heap_t*	heap = mem_heap_create(1024);

		if (heap == NULL) {
			err  = DB_OUT_OF_MEMORY;
		} else {
			ib_index_def_t*	index_def;

			index_def = (ib_index_def_t*) mem_heap_zalloc(
				heap, sizeof(*index_def));

			if (index_def == NULL) {
				err = DB_OUT_OF_MEMORY;

				mem_heap_free(heap);
			} else {
				index_def->heap = heap;

				index_def->table = table;

				index_def->name = mem_heap_strdup(heap, name);

				index_def->cols = ib_vector_create(heap, 8);

				index_def->usr_trx = (trx_t*) ib_usr_trx;

				*ib_idx_sch = (ib_idx_sch_t) index_def;
			}
		}
	}

	return(err);
}

/*****************************************************************//**
Get an index definition that is tagged as a clustered index.
@return	cluster index schema */
UNIV_INLINE
ib_index_def_t*
ib_find_clustered_index(
/*====================*/
	ib_vector_t*	indexes)	/*!< in: index defs. to search */
{
	ulint		i;
	ulint		n_indexes;

	UT_DBG_ENTER_FUNC;

	n_indexes = ib_vector_size(indexes);

	for (i = 0; i < n_indexes; ++i) {
		ib_index_def_t*	ib_index_def;

		ib_index_def = ib_vector_get(indexes, i);

		if (ib_index_def->clustered) {
			return(ib_index_def);
		}
	}

	return(NULL);
}

/*****************************************************************//**
Set index as clustered index. Implies UNIQUE.
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_set_clustered(
/*==========================*/
	ib_idx_sch_t	ib_idx_sch)	/*!< in/out: index definition */
{
	ib_index_def_t*	index_def;
	ib_err_t	err = DB_SUCCESS;

	UT_DBG_ENTER_FUNC;

	index_def = (ib_index_def_t*) ib_idx_sch;

	/* If this index schema is part of a table schema then we need
	to check the state of the other indexes. */

	if (index_def->schema != NULL) {
		ib_index_def_t*	ib_clust_index_def;

		ib_clust_index_def = ib_find_clustered_index(
			index_def->schema->indexes);

		if (ib_clust_index_def != NULL) {
			ut_a(ib_clust_index_def->clustered);
			ib_clust_index_def->clustered = FALSE;
		}
	}

	index_def->unique = TRUE;
	index_def->clustered = TRUE;

	return(err);
}

/*****************************************************************//**
Set index as a unique index.
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_schema_set_unique(
/*=======================*/
	ib_idx_sch_t	ib_idx_sch)	/*!< in/out: index definition */
{
	ib_index_def_t*	index_def;
	ib_err_t	err = DB_SUCCESS;

	UT_DBG_ENTER_FUNC;

	index_def = (ib_index_def_t*) ib_idx_sch;
	index_def->unique = TRUE;

	return(err);
}

/*****************************************************************//**
Destroy an index schema. */

void
ib_index_schema_delete(
/*===================*/
	ib_idx_sch_t	ib_idx_sch)	/*!< in, own: index schema to delete */
{
	ib_index_def_t*	index_def = (ib_index_def_t*) ib_idx_sch;

	UT_DBG_ENTER_FUNC;

	ut_a(index_def->schema == NULL);

	mem_heap_free(index_def->heap);
}

/*****************************************************************//**
Convert the table definition table attributes to the internal format.
@return	flags */
UNIV_STATIC
ulint
ib_table_def_get_flags(
/*===================*/
	const ib_table_def_t*	table_def)	/*!< in: table definition */
{
	ulint		flags = 0;

	UT_DBG_ENTER_FUNC;

	switch(table_def->ib_tbl_fmt) {
	case IB_TBL_REDUNDANT:		/* Old row format */
		break;
	case IB_TBL_COMPACT:		/* The compact row format */
		flags = DICT_TF_COMPACT;
		break;
	case IB_TBL_DYNAMIC:		/* The dynamic row format */
		/* Dynamic format implies a page size of 0. */
		flags = DICT_TF_COMPACT
			| DICT_TF_FORMAT_ZIP << DICT_TF_FORMAT_SHIFT;
		break;
	case IB_TBL_COMPRESSED: {	/* Compact row format and
					compressed page */
		ulint	i;
		ulint	j;

		for (i = j = 1; i <= DICT_TF_ZSSIZE_MAX; ++i, j <<= 1) {

			if (j == table_def->page_size) {
				flags = i << DICT_TF_ZSSIZE_SHIFT
					| DICT_TF_COMPACT
					| DICT_TF_FORMAT_ZIP
					<< DICT_TF_FORMAT_SHIFT;
				break;
			}
		}
		ut_a(flags != 0);
		ut_a(i <= DICT_TF_ZSSIZE_MAX);
		break;
	}
	default:
		ut_error;
	}

	return(flags);
}

/*****************************************************************//**
Copy the index definition to row0merge.c format.

@return	converted index definition */
UNIV_STATIC
const index_def_t*
ib_copy_index_definition(
/*=====================*/
	ib_index_def_t*	ib_index_def,	/*!< in: key definition for index */
	ibool		clustered)	/*!< in: IB_TRUE if clustered index */
{
	ulint		i;
	ib_key_col_t*	ib_col;
	ulint		name_len;
	index_def_t*	index_def;
	char*		index_name;

	UT_DBG_ENTER_FUNC;

	index_def = (index_def_t*) mem_heap_zalloc(
		ib_index_def->heap, sizeof(*index_def));

	name_len = ut_strlen(ib_index_def->name);
	index_name = mem_heap_zalloc(ib_index_def->heap, name_len + 2);

	/* The TEMP_INDEX_PREFIX is only needed if we are rebuilding an
	index or creating a new index on a table that has records. If
	the definition is owned by a table schema then we can be sure that
	this index definition is part of a CREATE TABLE. */
	if (ib_index_def->schema == NULL) {
		*index_name = TEMP_INDEX_PREFIX;
		memcpy(index_name + 1, ib_index_def->name, name_len + 1);
	} else {
		memcpy(index_name, ib_index_def->name, name_len);
	}

	index_def->name = index_name;
	index_def->n_fields = ib_vector_size(ib_index_def->cols);

	if (ib_index_def->unique) {
		index_def->ind_type = DICT_UNIQUE;
	} else {
		index_def->ind_type = 0;
	}

	if (clustered) {
		index_def->ind_type |= DICT_CLUSTERED;
	}

	index_def->fields = (index_field_t*) mem_heap_zalloc(
		ib_index_def->heap,
		sizeof(index_field_t) * index_def->n_fields);

	for (i = 0; i < ib_vector_size(ib_index_def->cols); ++i) {

		ib_col = ib_vector_get(ib_index_def->cols, i);

		index_def->fields[i].field_name = ib_col->name;
		index_def->fields[i].prefix_len = ib_col->prefix_len;
	}

	return(index_def);
}

/*****************************************************************//**
(Re)Create a secondary index.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_build_secondary_index(
/*=====================*/
	trx_t*		usr_trx,	/*!< in: transaction */
	dict_table_t*	table,		/*!< in: parent table of index */
	ib_index_def_t*	ib_index_def,	/*!< in: index definition */
	ib_bool_t	create,		/*!< in: TRUE if part of table create */
	dict_index_t**	index)		/*!< out: index created */
{
	ib_err_t	err;
	trx_t*		ddl_trx;
	ib_bool_t	started;
	const index_def_t*	index_def;

	UT_DBG_ENTER_FUNC;

	ut_a(usr_trx->conc_state != TRX_NOT_STARTED);

	if (!create) {
		ddl_trx = trx_allocate_for_client(NULL);
		started = trx_start(ddl_trx, ULINT_UNDEFINED);
		ut_a(started);
	} else {
		ddl_trx = usr_trx;
	}

	/* Set the CLUSTERED flag to FALSE. */
	index_def = ib_copy_index_definition(ib_index_def, FALSE);

	ut_a(!(index_def->ind_type & DICT_CLUSTERED));

	ddl_trx->op_info = "creating secondary index";

	if (!(create || ib_schema_lock_is_exclusive((ib_trx_t) usr_trx))) {
		err = ib_schema_lock_exclusive((ib_trx_t) usr_trx);

		if (err != DB_SUCCESS) {
			return(err);
		}
	}

	if (!create) {
		/* Flag this transaction as a dictionary operation, so that
		the data dictionary will be locked in crash recovery. */
		trx_set_dict_operation(ddl_trx, TRX_DICT_OP_INDEX);
	}

	*index = row_merge_create_index(ddl_trx, table, index_def);

	if (!create) {
		/* Even if the user locked the schema, we release it here and
		build the index without holding the dictionary lock. */
		ib_schema_unlock((ib_trx_t) usr_trx);
	}

	err = ddl_trx->error_state;

	if (!create) {
		/* Commit the data dictionary transaction in order to release
		the table locks on the system tables. */
		trx_commit(ddl_trx);

		trx_free_for_client(ddl_trx);
	}

	ut_a(usr_trx->conc_state != TRX_NOT_STARTED);

	if (*index != NULL) {
		ut_a(err == DB_SUCCESS);

		(*index)->cmp_ctx = NULL;

	       /* Read the clustered index records and build the index. */
		err = row_merge_build_indexes(
			usr_trx, table, table, index, 1, NULL);
	}

	return(err);
}


/*******************************************************************//**
Create a temporary tablename using table name and id
@return	temporary tablename */
UNIV_STATIC
char*
ib_table_create_temp_name(
/*======================*/
	mem_heap_t*	heap,		/*!< in: memory heap */
	char		id,		/*!< in: identifier [0-9a-zA-Z] */
	const char*     table_name)	/*!< in: table name */
{
	ulint		len;
	char*		name;
	static const char	suffix[] = "# ";

	len = ut_strlen(table_name);

	name = (char*) mem_heap_zalloc(heap, len + sizeof(suffix));
	ut_memcpy(name, table_name, len);
	ut_memcpy(name + len, suffix, sizeof(suffix));
	name[len + (sizeof(suffix) - 2)] = id;

	return(name);
}

/*******************************************************************//**
Create an index definition from the index. */
UNIV_STATIC
void
ib_index_create_def(
/*================*/
	const dict_index_t*	index,	/*!< in: index definition to copy */
	index_def_t*		index_def,/*!< out: index definition */
	mem_heap_t*		heap)	/*!< in: heap where allocated */
{
	ulint			i;
	const dict_field_t*     dfield;
	ulint			n_fields;

	n_fields = index->n_user_defined_cols;

	index_def->fields = (merge_index_field_t*) mem_heap_zalloc(
		heap, n_fields * sizeof(*index_def->fields));

	index_def->name = index->name;
	index_def->n_fields = n_fields;
	index_def->ind_type = index->type & ~DICT_CLUSTERED;

	for (i = 0, dfield = index->fields; i < n_fields; ++i, ++dfield) {
		merge_index_field_t*	def_field;

		def_field = &index_def->fields[i];

		def_field->field_name = dfield->name;
		def_field->prefix_len = dfield->prefix_len;
	}
}

/*******************************************************************//**
Create and return an array of index definitions on a table. Skip the
old clustered index if it's a generated clustered index. If there is a
user defined clustered index on the table its CLUSTERED flag will be unset.
@return	index definitions or NULL */
UNIV_STATIC
index_def_t*
ib_table_create_index_defs(
/*=======================*/
	trx_t*		trx,		/*!< in: transaction */
	const dict_table_t*
			table,		/*!< in: table definition */
	mem_heap_t*	heap,		/*!< in: heap where space for index
					definitions are allocated */
	ulint*		n_indexes)	/*!< out: number of indexes retuned */
{
	ulint			sz;
	ib_err_t		err;
	const dict_index_t*	index;
	index_def_t*		index_defs;

	UT_DBG_ENTER_FUNC;

	sz = sizeof(*index_defs) * UT_LIST_GET_LEN(table->indexes);
	index_defs = (index_def_t*) mem_heap_zalloc(heap, sz);

	err = ib_schema_lock_exclusive((ib_trx_t) trx);
	ut_a(err == DB_SUCCESS);

	index = dict_table_get_first_index(table);

	/* Skip a generated cluster index. */
	if (ib_utf8_strcasecmp(index->name, GEN_CLUST_INDEX) == 0) {
		ut_a(dict_index_get_nth_col(index, 0)->mtype == DATA_SYS);
		index = dict_table_get_next_index(index);
	}

	while (index) {
		ib_index_create_def(index, index_defs++, heap);
		index = dict_table_get_next_index(index);
	}

	ib_schema_unlock((ib_trx_t) trx);

	return(index_defs);
}

/*****************************************************************//**
Create a cluster index specified by the user . The cluster index
shouldn't already exist.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_create_cluster_index(
/*====================*/
	trx_t*		trx,		/*!< in: transaction */
	dict_table_t*	table,		/*!< in: parent table of index */
	ib_index_def_t*	ib_index_def,	/*!< in: index definition */
	dict_index_t**	index)		/*!< out: index created */
{
	ib_err_t		err;
	const index_def_t*	index_def;

	UT_DBG_ENTER_FUNC;

	ut_a(!ib_vector_is_empty(ib_index_def->cols));

	/* Set the CLUSTERED flag to TRUE. */
	index_def = ib_copy_index_definition(ib_index_def, TRUE);

	trx->op_info = "creating clustered index";

	trx_set_dict_operation(trx, TRX_DICT_OP_TABLE);

	err = ib_trx_lock_table_with_retry(trx, table, LOCK_X);

	if (err == DB_SUCCESS) {
		*index = row_merge_create_index(trx, table, index_def);

		err = trx->error_state;
	}

	trx->op_info = "";

	return(err);
}

/*****************************************************************//**
Create the secondary indexes on new table using the index definitions
from the src table.  The assumption is that a cluster index on the
new table already exists. All the indexes in the source table will
be copied with the exception of any generated clustered indexes. */
UNIV_STATIC
ib_err_t
ib_table_clone_indexes(
/*===================*/
	trx_t*		trx,		/*!< in: transaction */
	dict_table_t*	src_table,	/*!< in: table to clone from */
	dict_table_t*	new_table,	/*!< in: table to clone to */
	mem_heap_t*	heap)		/*!< in: memory heap to use */
{
	ulint		i;
	index_def_t*	index_defs;
	ulint		n_index_defs = 0;

	index_defs = ib_table_create_index_defs(
		trx, src_table, heap, &n_index_defs);

	ut_a(index_defs != NULL);

	for (i = 0; i < n_index_defs; ++i) {
		dict_index_t*	index;

		ut_a(!(index_defs[i].ind_type & DICT_CLUSTERED));
		index = row_merge_create_index(trx, new_table, &index_defs[i]);

		if (index == NULL) {
			return(trx->error_state);
		}
	}

	return(DB_SUCCESS);
}

/*****************************************************************//**
Clone the indexes definitions from src_table to dst_table. The cluster
index is not cloned. If it was generated then it's dropped else it's
demoted to a secondary index. A new cluster index is created for the
new table. */
UNIV_STATIC
ib_err_t
ib_table_clone(
/*===========*/
	trx_t*		trx,		/*!< in: transaction */
	dict_table_t*	src_table,	/*!< in: table to clone from */
	dict_table_t**	new_table,	/*!< out: cloned table */
	ib_index_def_t*	ib_index_def,	/*!< in: new cluster index definition */
	mem_heap_t*	heap)		/*!< in: memory heap to use */
{
	ib_err_t		err;
	const index_def_t*	index_def;
	char*			new_table_name;

	new_table_name = ib_table_create_temp_name(heap, '1', src_table->name);

	err = ib_schema_lock_exclusive((ib_trx_t) trx);

	if (err != DB_SUCCESS) {
		return(err);
	}

	/* Set the CLUSTERED flag to TRUE. */
	index_def = ib_copy_index_definition(ib_index_def, TRUE);

	/* Create the new table and the cluster index. */
	*new_table = row_merge_create_temporary_table(
		new_table_name, index_def, src_table, trx);

	if (!new_table) {
		err = trx->error_state;
	} else {
		trx->table_id = (*new_table)->id;

		err = ib_table_clone_indexes(trx, src_table, *new_table, heap);
	}

	ib_schema_unlock((ib_trx_t) trx);

	return(err);
}

/*****************************************************************//**
Copy the data from the source table to dst table. */
UNIV_STATIC
ib_err_t
ib_table_copy(
/*==========*/
	trx_t*		trx,		/*!< in: transaction */
	dict_table_t*	src_table,	/*!< in: table to copy from */
	dict_table_t*	dst_table,	/*!< in: table to copy to */
	mem_heap_t*	heap)		/*!< in: heap to use */
{
	ib_err_t	err;
	dict_index_t*	index;
	dict_index_t**	indexes;
	ulint		n_indexes;

	err = ib_schema_lock_exclusive((ib_trx_t) trx);

	if (err != DB_SUCCESS) {
		return(err);
	}

	n_indexes = UT_LIST_GET_LEN(dst_table->indexes);

	indexes = (dict_index_t**) mem_heap_zalloc(
		heap, n_indexes * sizeof(index));

	n_indexes = 0;

	index = dict_table_get_first_index(dst_table);
	/* Copy the indexes to an array. */
	while (index) {
		indexes[n_indexes++] = index;
		index = dict_table_get_next_index(index);
	}
	ut_a(n_indexes == UT_LIST_GET_LEN(dst_table->indexes));

	ib_schema_unlock((ib_trx_t) trx);

	/* Build the actual indexes. */
	err = row_merge_build_indexes(
		trx, src_table, dst_table, indexes, n_indexes, NULL);

	return(err);
}

/*****************************************************************//**
Create a default cluster index, this usually means the user didn't
create a table with a primary key.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_create_default_cluster_index(
/*============================*/
	trx_t*		trx,		/*!< in: transaction */
	dict_table_t*	table,		/*!< in: parent table of index */
	dict_index_t**	index)		/*!< out: index created */
{
	ib_err_t	err;
	index_def_t	index_def;

	UT_DBG_ENTER_FUNC;

	index_def.name = GEN_CLUST_INDEX;
	index_def.ind_type = DICT_CLUSTERED;
	index_def.n_fields = 0;
	index_def.fields = NULL;

	trx->op_info = "creating default clustered index";

	trx_set_dict_operation(trx, TRX_DICT_OP_TABLE);

	ut_a(ib_schema_lock_is_exclusive((ib_trx_t) trx));

	err = ib_trx_lock_table_with_retry(trx, table, LOCK_X);

	if (err == DB_SUCCESS) {
		*index = row_merge_create_index(trx, table, &index_def);

		err = trx->error_state;
	}

	trx->op_info = "";

	return(err);
}

/*****************************************************************//**
Create the indexes for the table. Each index is created in a separate
transaction. The caller is responsible for dropping any indexes that
exist if there is a failure.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_create_indexes(
/*==============*/
	trx_t*		ddl_trx,	/*!< in: transaction */
	dict_table_t*	table,		/*!< in: table where index created */
	ib_vector_t*	indexes)	/*!< in: index defs. to create */
{
	ulint		i = 0;
	ulint		n_indexes;
	ib_index_def_t*	ib_index_def;
	dict_index_t*	index = NULL;
	ib_err_t	err = DB_ERROR;
	ib_index_def_t*	ib_clust_index_def = NULL;

	UT_DBG_ENTER_FUNC;

	n_indexes = ib_vector_size(indexes);

	if (n_indexes > 0) {
		ib_clust_index_def = ib_find_clustered_index(indexes);

		if (ib_clust_index_def != NULL) {
			ut_a(ib_clust_index_def->clustered);

			err = ib_create_cluster_index(
				ddl_trx, table, ib_clust_index_def, &index);
		}
	}

	if (ib_clust_index_def == NULL) {
		err = ib_create_default_cluster_index(ddl_trx, table, &index);
	}

	for (i= 0; err == DB_SUCCESS && i < n_indexes; ++i) {

		ib_index_def = ib_vector_get(indexes, i);

		ut_a(!ib_vector_is_empty(ib_index_def->cols));

		if (!ib_index_def->clustered) {
			/* Since this is part of CREATE TABLE, set the
			create flag to IB_TRUE. */
			err = ib_build_secondary_index(
				ddl_trx, table, ib_index_def, IB_TRUE, &index);
		} else {
			/* There can be at most one cluster definition. */
			ut_a(ib_clust_index_def == ib_index_def);
		}
	}

	return(err);
}

/*****************************************************************//**
Get a table id. The caller must have acquired the dictionary mutex.
@return	DB_SUCCESS if found */
UNIV_STATIC
ib_err_t
ib_table_get_id_low(
/*================*/
	const char*	table_name,	/*!< in: table to find */
	ib_id_t*	table_id)	/*!< out: table id if found */
{
	dict_table_t*	table;
	ib_err_t	err = DB_TABLE_NOT_FOUND;

	UT_DBG_ENTER_FUNC;

	*table_id = 0;

	table = ib_lookup_table_by_name(table_name);

	if (table != NULL) {
		*table_id = ut_conv_dulint_to_longlong(table->id);

		err = DB_SUCCESS;
	}

	return(err);
}

/*****************************************************************//**
Create a table. If the table exists in the database then this function
will return DB_TABLE_IS_BEING_USED and id will contain that tables id.
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_create(
/*============*/
	ib_trx_t		ib_trx,		/*!< in/out: transaction */
	const ib_tbl_sch_t	ib_tbl_sch,	/*!< in: table schema */
	ib_id_t*		id)		/*!< out: table id */
{
	ulint		i;
	ib_err_t	err;
	mem_heap_t*	heap;
	dict_table_t*	table;
	ulint		n_cols = 0;
	ulint		n_cluster = 0;
	ib_col_t*	ib_col = NULL;
	trx_t*		ddl_trx = (trx_t*) ib_trx;
	const ib_table_def_t*	table_def = (const ib_table_def_t*) ib_tbl_sch;

	UT_DBG_ENTER_FUNC;

	/* Another thread may have created the table already when we get
	here. We need to search the data dictionary before we attempt to
	create the table. */

	if (!ib_schema_lock_is_exclusive((ib_trx_t)ddl_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	}

	err = ib_table_get_id_low(table_def->name, id);

	if (err == DB_SUCCESS) {
		return(DB_TABLE_IS_BEING_USED);
	}

	*id = 0;

	n_cols = ib_vector_size(table_def->cols);

	if (n_cols == 0) {
		return(DB_SCHEMA_ERROR);
	}

	/* Check that all index definitions are valid. */
	for (i = 0; i < ib_vector_size(table_def->indexes); ++i) {
		ib_index_def_t*	ib_index_def;

		ib_index_def = ib_vector_get(table_def->indexes, i);

		/* Check that the index definition has at least one column. */
		if (ib_vector_is_empty(ib_index_def->cols)) {
			return(DB_SCHEMA_ERROR);
		}

		/* Check for duplicate cluster definitions. */
		if (ib_index_def->clustered) {
			++n_cluster;

			if (n_cluster > 1) {
				return(DB_SCHEMA_ERROR);
			}
		}
	}

	/* Create the table prototype. */
	table = dict_mem_table_create(
		table_def->name, 0, n_cols, ib_table_def_get_flags(table_def));

	heap = table->heap;

	/* Create the columns defined by the user. */
	for (i = 0; i < n_cols; i++) {
		ib_col = ib_vector_get(table_def->cols, i);

		dict_mem_table_add_col(
			table, heap, ib_col->name,
			ib_col_get_mtype(ib_col),
			ib_col_get_prtype(ib_col),
			ib_col->len);
	}

	/* Create the table using the prototype in the data dictionary. */
	err = ddl_create_table(table, ddl_trx);

	table = NULL;

	if (err == DB_SUCCESS) {

		table = ib_lookup_table_by_name(table_def->name);
		ut_a(table != NULL);

		/* Bump up the reference count, so that another transaction
		doesn't delete it behind our back. */
		dict_table_increment_handle_count(table, TRUE);

		err = ib_create_indexes(ddl_trx, table, table_def->indexes);
	}

	/* FIXME: If ib_create_indexes() fails, it's unclear what state
	the data dictionary is in. */

	if (err == DB_SUCCESS) {
		*id = ut_dulint_get_low(table->id);
	}

	if (table != NULL) {
		ulint		format_id;
		const char*	format = NULL;

		/* We update the highest file format in the system
		table space, if this table has a higher file format
		setting. */

		format_id = dict_table_get_format(table);
		trx_sys_file_format_max_upgrade(&format, format_id);

		if (format != NULL && format_id > db_format.id) {

			db_format.name = trx_sys_file_format_id_to_name(
				format_id); 

			db_format.id = trx_sys_file_format_name_to_id(format);

			ut_a(db_format.id <= DICT_TF_FORMAT_MAX);
		}

		dict_table_decrement_handle_count(table, TRUE);
	}

	return(err);
}

/*****************************************************************//**
Rename a table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_rename(
/*============*/
	ib_trx_t	ib_trx,		/*!< in/out: transaction */
	const char*	old_name,	/*!< in: old name*/
	const char*	new_name)	/*!< in: old name*/
{
	ib_err_t	err;
	char*		normalized_old_name;
	char*		normalized_new_name;
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	if (!ib_schema_lock_is_exclusive(ib_trx)) {
		err = ib_schema_lock_exclusive(ib_trx);

		if (err != DB_SUCCESS) {
			return(err);
		}
	}

	normalized_old_name = mem_alloc(ut_strlen(old_name) + 1);
	ib_normalize_table_name(normalized_old_name, old_name);

	normalized_new_name = mem_alloc(ut_strlen(new_name) + 1);
	ib_normalize_table_name(normalized_new_name, new_name);

	err = ddl_rename_table(normalized_old_name, normalized_new_name, trx);

	mem_free(normalized_old_name);
	mem_free(normalized_new_name);

	return(err);
}

/*****************************************************************//**
Create a primary index. The index id encodes the table id in the high
4 bytes and the index id in the lower 4 bytes.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_create_primary_index(
/*====================*/
	ib_idx_sch_t	ib_idx_sch,	/*!< in: key definition for index */
	ib_id_t*	index_id)	/*!< out: index id */
{
	ib_err_t	err;
	mem_heap_t*	heap;
	const index_def_t*
			index_def;
	dict_table_t*	new_table = NULL;
	ib_index_def_t*	ib_index_def = (ib_index_def_t*) ib_idx_sch;
	trx_t*		usr_trx = ib_index_def->usr_trx;
	dict_table_t*	table = ib_index_def->table;

	UT_DBG_ENTER_FUNC;
	/* This should only be called on index schema instances
	created outside of table schemas. */
	ut_a(ib_index_def->schema == NULL);
	ut_a(ib_index_def->clustered);

	/* Recreate the cluster index and all the secondary indexes
	on a table. If there was a user defined cluster index on the
	table, it will be recreated a secondary index. The InnoDB
	generated cluster index if one exists will be dropped. */

	usr_trx->op_info = "recreating clustered index";

	heap = mem_heap_create(1024);

	/* This transaction should be the only one operating on the table. */
	ut_a(table->n_handles_opened == 1);

	trx_set_dict_operation(usr_trx, TRX_DICT_OP_TABLE);

	ut_a(!ib_vector_is_empty(ib_index_def->cols));

	/* Set the CLUSTERED flag to TRUE. */
	index_def = ib_copy_index_definition(ib_index_def, TRUE);

	err = ib_trx_lock_table_with_retry(usr_trx, table, LOCK_X);

	if (err == DB_SUCCESS) {
		err = ib_table_clone(
			usr_trx, table, &new_table, ib_index_def, heap);
	}

	if (err == DB_SUCCESS) {
		err = ib_trx_lock_table_with_retry(usr_trx, new_table, LOCK_X);
	}

	if (err == DB_SUCCESS) {
		err = ib_table_copy(usr_trx, table, new_table, heap);
	}

	if (err == DB_SUCCESS) {
		char*		tmp_name;
		const char*	old_name;

		/* Swap the cloned table with the original table.
		On success drop the original table. */
		old_name = table->name;
		tmp_name = ib_table_create_temp_name(heap, '2', old_name);

		err = row_merge_rename_tables(
			table, new_table, tmp_name, usr_trx);

		if (err != DB_SUCCESS) {
			row_merge_drop_table(usr_trx, new_table);
		}
	}

	mem_heap_free(heap);

	usr_trx->op_info = "";

	return(err);
}

/*****************************************************************//**
Create a secondary index. The index id encodes the table id in the high
4 bytes and the index id in the lower 4 bytes.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_create_secondary_index(
/*======================*/
	ib_idx_sch_t	ib_idx_sch,	/*!< in: key definition for index */
	ib_id_t*	index_id)	/*!< out: index id */
{
	ib_err_t	err;
	dict_index_t*	index = NULL;
	trx_t*		ddl_trx = NULL;
	ib_index_def_t*	ib_index_def = (ib_index_def_t*) ib_idx_sch;
	trx_t*		usr_trx = ib_index_def->usr_trx;
	dict_table_t*	table = ib_index_def->table;

	UT_DBG_ENTER_FUNC;

	/* This should only be called on index schema instances
	created outside of table schemas. */
	ut_a(ib_index_def->schema == NULL);
	ut_a(!ib_index_def->clustered);

	err = ib_trx_lock_table_with_retry(usr_trx, table, LOCK_S);

	if (err == DB_SUCCESS) {

		/* Since this is part of ALTER TABLE set the create flag
		to IB_FALSE. */
		err = ib_build_secondary_index(
			usr_trx, table, ib_index_def, IB_FALSE, &index);

		err = ib_schema_lock_exclusive((ib_trx_t) usr_trx);
		ut_a(err == DB_SUCCESS);

		if (index != NULL && err != DB_SUCCESS) {
			row_merge_drop_indexes(usr_trx, table, &index, 1);
			index = NULL;
		} else {
			ib_bool_t	started;

			ddl_trx = trx_allocate_for_client(NULL);
			started = trx_start(ddl_trx, ULINT_UNDEFINED);
			ut_a(started);
		}
	}

	ut_a(!(ddl_trx == NULL && err == DB_SUCCESS));

	/* Rename from the TEMP new index to the actual name. */
	if (index != NULL && err == DB_SUCCESS) {
		err = row_merge_rename_indexes(usr_trx, table);

		if (err != DB_SUCCESS) {
			row_merge_drop_indexes(usr_trx, table, &index, 1);
			index = NULL;
		}
	}

	if (index != NULL && err == DB_SUCCESS) {
		/* We only support 32 bit table and index ids. Because
		we need to pack the table id into the index id. */
		ut_a(ut_dulint_get_high(table->id) == 0);
		ut_a(ut_dulint_get_high(index->id) == 0);

		*index_id = ut_dulint_get_low(table->id);
		*index_id <<= 32;
		*index_id |= ut_dulint_get_low(index->id);

		trx_commit(ddl_trx);
	} else if (ddl_trx != NULL) {
		trx_general_rollback(ddl_trx, FALSE, NULL);
	}

	if (ddl_trx != NULL) {
		ddl_trx->op_info = "";
		trx_free_for_client(ddl_trx);
	}

	return(err);
}

/*****************************************************************//**
Create a secondary index. The index id encodes the table id in the high
4 bytes and the index id in the lower 4 bytes.
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_create(
/*============*/
	ib_idx_sch_t	ib_idx_sch,	/*!< in/out: key definition for index */
	ib_id_t*	index_id)	/*!< out: index id */
{
	ib_err_t	err;
	ib_index_def_t*	ib_index_def = (ib_index_def_t*) ib_idx_sch;

	if (!ib_schema_lock_is_exclusive((ib_trx_t) ib_index_def->usr_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	} else if (ib_index_def->clustered) {
		err = ib_create_primary_index(ib_idx_sch, index_id);
	} else {
		err = ib_create_secondary_index(ib_idx_sch, index_id);
	}

	return(err);
}

/*****************************************************************//**
Drop a table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_table_drop(
/*==========*/
	ib_trx_t	ib_trx,		/*!< in: transaction */
	const char*	name)		/*!< in: table name to drop*/
{
	ib_err_t	err;
	char*		normalized_name;

	UT_DBG_ENTER_FUNC;

	if (!ib_schema_lock_is_exclusive(ib_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	}

	normalized_name = mem_alloc(ut_strlen(name) + 1);
	ib_normalize_table_name(normalized_name, name);

	err = ddl_drop_table(normalized_name, (trx_t*) ib_trx, FALSE);

	mem_free(normalized_name);

	return(err);
}

/*****************************************************************//**
Drop a secondary index.
@return	DB_SUCCESS or err code */

ib_err_t
ib_index_drop(
/*==========*/
	ib_trx_t	ib_trx,		/*!< in: transaction */
	ib_id_t		index_id)	/*!< in: index id to drop */
{
	ib_err_t	err;
	dict_table_t*	table;
	dict_index_t*	index;
	ulint		table_id = (ulint) (index_id >> 32);

	UT_DBG_ENTER_FUNC;

	if (!ib_schema_lock_is_exclusive(ib_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	}

	table = ib_open_table_by_id(table_id, TRUE);

	if (table == NULL) {
		return(DB_TABLE_NOT_FOUND);
	}

	/* We use only the lower 32 bits of the dulint. */
	index_id &= 0xFFFFFFFFULL;

	index = dict_index_get_on_id_low(
		table, ut_dulint_create(0, (ulint) index_id));

	if (index != NULL) {
		err = ddl_drop_index(table, index, (trx_t*) ib_trx);
	} else {
		err = DB_TABLE_NOT_FOUND;
	}

	dict_table_decrement_handle_count(table, FALSE);

	return(err);
}

/*****************************************************************//**
Create an internal cursor instance.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_create_cursor(
/*=============*/
	ib_crsr_t*	ib_crsr,	/*!< out: InnoDB cursor */
	dict_table_t*	table,		/*!< in: table instance */
	ib_id_t		index_id,	/*!< in: index id or 0 */
	trx_t*		trx)		/*!< in: transaction */
{
	mem_heap_t*	heap;
	ib_cursor_t*	cursor;
	ib_err_t	err = DB_SUCCESS;
	dulint		id = ut_dulint_create(0, (ulint) index_id);

	UT_DBG_ENTER_FUNC;

	heap = mem_heap_create(sizeof(*cursor) * 2);

	if (heap != NULL) {
		row_prebuilt_t*	prebuilt;

		cursor = mem_heap_zalloc(heap, sizeof(*cursor));

		cursor->heap = heap;

		cursor->query_heap = mem_heap_create(64);

		if (cursor->query_heap == NULL) {
			mem_heap_free(heap);

			return(DB_OUT_OF_MEMORY);
		}

		cursor->prebuilt = row_prebuilt_create(table);

		prebuilt = cursor->prebuilt;

		prebuilt->trx = trx;
		prebuilt->table = table;
		prebuilt->select_lock_type = LOCK_NONE;

		if (index_id > 0) {
			prebuilt->index = dict_index_get_on_id_low(table, id);
		} else {
			prebuilt->index = dict_table_get_first_index(table);
		}

		ut_a(prebuilt->index != NULL);

		if (prebuilt->trx != NULL) {
			++prebuilt->trx->n_client_tables_in_use;

			 prebuilt->index_usable =
				row_merge_is_index_usable(
					prebuilt->trx, prebuilt->index);

			/* Assign a read view if the transaction does
			not have it yet */

			trx_assign_read_view(prebuilt->trx);
		}

		*ib_crsr = (ib_crsr_t) cursor;
	} else {
		err = DB_OUT_OF_MEMORY;
	}

	return(err);
}

/*****************************************************************//**
Open an InnoDB table and return a cursor handle to it.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_table_using_id(
/*==========================*/
	ib_id_t		table_id,	/*!< in: table id of table to open */
	ib_trx_t	ib_trx,		/*!< in: Current transaction handle
					can be NULL */
	ib_crsr_t*	ib_crsr)	/*!< out,own: InnoDB cursor */
{
	ib_err_t	err;
	dict_table_t*	table;

	UT_DBG_ENTER_FUNC;

	if (ib_trx == NULL || !ib_schema_lock_is_exclusive(ib_trx)) {
		table = ib_open_table_by_id(table_id, FALSE);
	} else {
		table = ib_open_table_by_id(table_id, TRUE);
	}

	if (table == NULL) {

		return(DB_TABLE_NOT_FOUND);
	}

	err = ib_create_cursor(ib_crsr, table, 0, (trx_t*) ib_trx);

	return(err);
}

/*****************************************************************//**
Open an InnoDB index and return a cursor handle to it.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_index_using_id(
/*==========================*/
	ib_id_t		index_id,	/*!< in: index id of index to open */
	ib_trx_t	ib_trx,		/*!< in: Current transaction handle
					can be NULL */
	ib_crsr_t*	ib_crsr)	/*!< out: InnoDB cursor */
{
	ib_err_t	err;
	dict_table_t*	table;
	ulint		table_id = (ulint)( index_id >> 32);

	UT_DBG_ENTER_FUNC;

	if (ib_trx == NULL || !ib_schema_lock_is_exclusive(ib_trx)) {
		table = ib_open_table_by_id(table_id, FALSE);
	} else {
		table = ib_open_table_by_id(table_id, TRUE);
	}

	if (table == NULL) {

		return(DB_TABLE_NOT_FOUND);
	}

	/* We only return the lower 32 bits of the dulint. */
	err = ib_create_cursor(
		ib_crsr, table, index_id & 0xFFFFFFFFULL, (trx_t*) ib_trx);

	if (ib_crsr != NULL) {
		const ib_cursor_t*	cursor;

		cursor = *(ib_cursor_t**) ib_crsr;

		if (cursor->prebuilt->index == NULL) {
			ib_err_t	crsr_err;

			crsr_err = ib_cursor_close(*ib_crsr);
			ut_a(crsr_err == DB_SUCCESS);

			*ib_crsr = NULL;
		}
	}

	return(err);
}

/*****************************************************************//**
Open an InnoDB secondary index cursor and return a cursor handle to it.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_index_using_name(
/*============================*/
	ib_crsr_t	ib_open_crsr,	/*!< in: open/active cursor */
	const char*	index_name,	/*!< in: secondary index name */
	ib_crsr_t*	ib_crsr)	/*!< out,own: InnoDB index cursor */
{
	dict_table_t*	table;
	dict_index_t*	index;
	ib_id_t		index_id = 0;
	ib_err_t	err = DB_TABLE_NOT_FOUND;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_open_crsr;
	trx_t*		trx = cursor->prebuilt->trx;

	UT_DBG_ENTER_FUNC;

	if (trx != NULL && !ib_schema_lock_is_exclusive((ib_trx_t) trx)) {
		dict_mutex_enter();
	}

	/* We want to increment the ref count, so we do a redundant search. */
	table = dict_table_get_using_id(
		srv_force_recovery, cursor->prebuilt->table->id, TRUE);
	ut_a(table != NULL);

	if (trx != NULL && !ib_schema_lock_is_exclusive((ib_trx_t) trx)) {
		dict_mutex_exit();
	}

	/* The first index is always the cluster index. */
	index = dict_table_get_first_index(table);

	/* Traverse the user defined indexes. */
	while (index != NULL) {
		if (strcmp(index->name, index_name) == 0) {
			index_id = ut_conv_dulint_to_longlong(index->id);
		}
		index = UT_LIST_GET_NEXT(indexes, index);
	}

	*ib_crsr = NULL;

	if (index_id > 0) {
		err = ib_create_cursor(
			ib_crsr, table, index_id, cursor->prebuilt->trx);
	}

	if (ib_crsr != NULL) {
		const ib_cursor_t*	cursor;

		cursor = *(ib_cursor_t**) ib_crsr;

		if (cursor->prebuilt->index == NULL) {
			err = ib_cursor_close(*ib_crsr);
			ut_a(err == DB_SUCCESS);
			*ib_crsr = NULL;
		}
	}

	return(err);
}

/*****************************************************************//**
Open an InnoDB table and return a cursor handle to it.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_open_table(
/*=================*/
	const char*	name,		/*!< in: table name */
	ib_trx_t	ib_trx,		/*!< in: Current transaction handle
					can be NULL */
	ib_crsr_t*	ib_crsr)	/*!< out,own: InnoDB cursor */
{
	ib_err_t	err;
	dict_table_t*	table;
	char*		normalized_name;

	UT_DBG_ENTER_FUNC;

	normalized_name = mem_alloc(ut_strlen(name) + 1);
	ib_normalize_table_name(normalized_name, name);

	if (ib_trx != NULL) {
	       if (!ib_schema_lock_is_exclusive(ib_trx)) {
			table = ib_open_table_by_name(normalized_name);
		} else {
			table = ib_lookup_table_by_name(normalized_name);

			if (table != NULL) {
				dict_table_increment_handle_count(table, TRUE);
			}
		}
	} else {
		table = ib_open_table_by_name(normalized_name);
	}

	mem_free(normalized_name);
	normalized_name = NULL;

	/* It can happen that another thread has created the table but
	not the cluster index or it's a broken table definition. Refuse to
	open if that's the case. */
	if (table != NULL && dict_table_get_first_index(table) == NULL) {
		dict_table_decrement_handle_count(table, FALSE);
		table = NULL;
	}

	if (table != NULL) {
		err = ib_create_cursor(ib_crsr, table, 0, (trx_t*) ib_trx);
	} else {
		err = DB_TABLE_NOT_FOUND;
	}

	return(err);
}

/********************************************************************//**
Free a context struct for a table handle. */
UNIV_STATIC
void
ib_qry_proc_free(
/*=============*/
	ib_qry_proc_t*	q_proc)		/*!< in, own: qproc struct */
{
	UT_DBG_ENTER_FUNC;

	que_graph_free_recursive(q_proc->grph.ins);
	que_graph_free_recursive(q_proc->grph.upd);
	que_graph_free_recursive(q_proc->grph.sel);

	memset(q_proc, 0x0, sizeof(*q_proc));
}

/*****************************************************************//**
Reset the cursor.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_reset(
/*============*/
	ib_crsr_t	ib_crsr)	/*!< in/out: InnoDB cursor */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	if (prebuilt->trx != NULL
	    && prebuilt->trx->n_client_tables_in_use > 0) {

		--prebuilt->trx->n_client_tables_in_use;
	}

	/* The fields in this data structure are allocated from
	the query heap and so need to be reset too. */
	ib_qry_proc_free(&cursor->q_proc);

	mem_heap_empty(cursor->query_heap);

	row_prebuilt_reset(prebuilt);

	return(DB_SUCCESS);
}

/*****************************************************************//**
Close the cursor.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_close(
/*============*/
	ib_crsr_t	ib_crsr)	/*!< in,own: InnoDB cursor */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;
	trx_t*		trx = prebuilt->trx;

	UT_DBG_ENTER_FUNC;

	ib_qry_proc_free(&cursor->q_proc);

	/* The transaction could have been detached from the cursor. */
	if (trx != NULL && trx->n_client_tables_in_use > 0) {
		--trx->n_client_tables_in_use;
	}

	if (trx && ib_schema_lock_is_exclusive((ib_trx_t) trx)) {
		row_prebuilt_free(cursor->prebuilt, TRUE);
	} else {
		row_prebuilt_free(cursor->prebuilt, FALSE);
	}

	mem_heap_free(cursor->query_heap);
	mem_heap_free(cursor->heap);

	return(DB_SUCCESS);
}

/**********************************************************************//**
Run the insert query and do error handling.
@return	DB_SUCCESS or error code */
UNIV_INLINE
ib_err_t
ib_insert_row_with_lock_retry(
/*==========================*/
	que_thr_t*	thr,		/*!< in: insert query graph */
	ins_node_t*	node,		/*!< in: insert node for the query */
	trx_savept_t*	savept)		/*!< in: savepoint to rollback to
					in case of an error */
{
	trx_t*		trx;
	ib_err_t	err;
	ib_bool_t	lock_wait;

	trx = thr_get_trx(thr);

	do {
		thr->run_node = node;
		thr->prev_node = node;

		row_ins_step(thr);

		err = trx->error_state;

		if (err != DB_SUCCESS) {
			que_thr_stop_client(thr);

			thr->lock_state = QUE_THR_LOCK_ROW;
			lock_wait = ib_handle_errors(&err, trx, thr, savept);
			thr->lock_state = QUE_THR_LOCK_NOLOCK;
		} else {
			lock_wait = FALSE;
		}
	} while (lock_wait);

	return(err);
}

/*****************************************************************//**
Write a row.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_execute_insert_query_graph(
/*==========================*/
	dict_table_t*	table,		/*!< in: table where to insert */
	que_fork_t*	ins_graph,	/*!< in: query graph */
	ins_node_t*	node)		/*!< in: insert node */
{
	trx_t*		trx;
	que_thr_t*	thr;
	trx_savept_t	savept;
	ib_err_t	err = DB_SUCCESS;

	UT_DBG_ENTER_FUNC;

	/* This is a short term solution to fix the purge lag. */
	ib_delay_dml_if_needed();

	trx = ins_graph->trx;

	savept = trx_savept_take(trx);

	thr = que_fork_get_first_thr(ins_graph);

	que_thr_move_to_run_state(thr);

	err = ib_insert_row_with_lock_retry(thr, node, &savept);

	if (err == DB_SUCCESS) {
		que_thr_stop_for_client_no_error(thr, trx);

		table->stat_n_rows++;

		srv_n_rows_inserted++;

		ib_update_statistics_if_needed(table);

		ib_wake_master_thread();
	}

	trx->op_info = "";

	return(err);
}

/*****************************************************************//**
Create an insert query graph node. */
UNIV_STATIC
void
ib_insert_query_graph_create(
/*==========================*/
	ib_cursor_t*	cursor)		/*!< in: Cursor instance */
{
	ib_qry_proc_t*	q_proc = &cursor->q_proc;
	ib_qry_node_t*	node = &q_proc->node;
	trx_t*		trx = cursor->prebuilt->trx;

	UT_DBG_ENTER_FUNC;

	ut_a(trx->conc_state != TRX_NOT_STARTED);

	if (node->ins == NULL) {
		dtuple_t*	row;
		ib_qry_grph_t*	grph = &q_proc->grph;
		mem_heap_t*	heap = cursor->query_heap;
		dict_table_t*	table = cursor->prebuilt->table;

		node->ins = row_ins_node_create(INS_DIRECT, table, heap);

		node->ins->select = NULL;
		node->ins->values_list = NULL;

		row = dtuple_create(heap, dict_table_get_n_cols(table));
		dict_table_copy_types(row, table);

		row_ins_node_set_new_row(node->ins, row);

		grph->ins = que_node_get_parent(
			pars_complete_graph_for_exec(node->ins, trx, heap));

		grph->ins->state = QUE_FORK_ACTIVE;
	}
}

/*****************************************************************//**
Insert a row to a table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_insert_row(
/*=================*/
	ib_crsr_t	ib_crsr,	/*!< in/out: InnoDB cursor instance */
	const ib_tpl_t	ib_tpl)		/*!< in: tuple to insert */
{
	ib_ulint_t	i;
	ib_qry_node_t*	node;
	ib_qry_proc_t*	q_proc;
	ulint		n_fields;
	dtuple_t*	dst_dtuple;
	ib_err_t	err = DB_SUCCESS;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	const ib_tuple_t* src_tuple = (const ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	ib_insert_query_graph_create(cursor);

	ut_ad(src_tuple->type == TPL_ROW);

	q_proc = &cursor->q_proc;
	node = &q_proc->node;

	node->ins->state = INS_NODE_ALLOC_ROW_ID;
	dst_dtuple = node->ins->row;

	n_fields = dtuple_get_n_fields(src_tuple->ptr);
	ut_ad(n_fields == dtuple_get_n_fields(dst_dtuple));

	/* Do a shallow copy of the data fields and check for NULL
	constraints on columns. */
	for (i = 0; i < n_fields; i++) {
		ulint		mtype;
		dfield_t*	src_field;
		dfield_t*	dst_field;

		src_field = dtuple_get_nth_field(src_tuple->ptr, i);

		mtype = dtype_get_mtype(dfield_get_type(src_field));

		/* Don't touch the system columns. */
		if (mtype != DATA_SYS) {
			ulint	prtype;

			prtype = dtype_get_prtype(dfield_get_type(src_field));

			if ((prtype & DATA_NOT_NULL)
			    && dfield_is_null(src_field)) {

				err = DB_DATA_MISMATCH;
				break;
			}

			dst_field = dtuple_get_nth_field(dst_dtuple, i);
			ut_ad(mtype
			      == dtype_get_mtype(dfield_get_type(dst_field)));

			/* Do a shallow copy. */
			dfield_set_data(
				dst_field, src_field->data, src_field->len);

			UNIV_MEM_ASSERT_RW(src_field->data, src_field->len);
			UNIV_MEM_ASSERT_RW(dst_field->data, dst_field->len);
		}
	}

	if (err == DB_SUCCESS) {
		err = ib_execute_insert_query_graph(
			src_tuple->index->table, q_proc->grph.ins, node->ins);
	}

	return(err);
}

/*********************************************************************//**
Gets pointer to a prebuilt update vector used in updates.
@return	update vector */
UNIV_INLINE
upd_t*
ib_update_vector_create(
/*====================*/
	ib_cursor_t*	cursor)		/*!< in: current cursor */
{
	trx_t*		trx = cursor->prebuilt->trx;
	mem_heap_t*	heap = cursor->query_heap;
	dict_table_t*	table = cursor->prebuilt->table;
	ib_qry_proc_t*	q_proc = &cursor->q_proc;
	ib_qry_grph_t*	grph = &q_proc->grph;
	ib_qry_node_t*	node = &q_proc->node;

	UT_DBG_ENTER_FUNC;

	ut_a(trx->conc_state != TRX_NOT_STARTED);

	if (node->upd == NULL) {
		node->upd = row_create_update_node(table, heap);
	}

	grph->upd = que_node_get_parent(
		pars_complete_graph_for_exec(node->upd, trx, heap));

	grph->upd->state = QUE_FORK_ACTIVE;

	return(node->upd->update);
}

/**********************************************************************//**
Note that a column has changed. */
UNIV_STATIC
void
ib_update_col(
/*==========*/

	ib_cursor_t*	cursor,		/*!< in: current cursor */
	upd_field_t*	upd_field,	/*!< in/out: update field */
	ulint		col_no,		/*!< in: column number */
	dfield_t*	dfield)		/*!< in: updated dfield */
{
	ulint		data_len;
	dict_table_t*	table = cursor->prebuilt->table;
	dict_index_t*	index = dict_table_get_first_index(table);

	UT_DBG_ENTER_FUNC;

	data_len = dfield_get_len(dfield);

	if (data_len == UNIV_SQL_NULL) {
		dfield_set_null(&upd_field->new_val);
	} else {
		dfield_copy_data(&upd_field->new_val, dfield);
	}

	upd_field->exp = NULL;

	upd_field->orig_len = 0;

	upd_field->field_no = dict_col_get_clust_pos(
		&table->cols[col_no], index);
}

/**********************************************************************//**
Checks which fields have changed in a row and stores the new data
to an update vector.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_calc_diff(
/*=========*/
	ib_cursor_t*	cursor,		/*!< in: current cursor */
	upd_t*		upd,		/*!< in/out: update vector */
	const ib_tuple_t*old_tuple,	/*!< in: Old tuple in table */
	const ib_tuple_t*new_tuple)	/*!< in: New tuple to update */
{
	ulint		i;
	ulint		n_changed = 0;
	ib_err_t	err = DB_SUCCESS;
	ulint		n_fields = dtuple_get_n_fields(new_tuple->ptr);

	UT_DBG_ENTER_FUNC;

	ut_a(old_tuple->type == TPL_ROW);
	ut_a(new_tuple->type == TPL_ROW);
	ut_a(old_tuple->index->table == new_tuple->index->table);

	for (i = 0; i < n_fields; ++i) {
		ulint		mtype;
		ulint		prtype;
		upd_field_t*	upd_field;
		dfield_t*	new_dfield;
		dfield_t*	old_dfield;

		new_dfield = dtuple_get_nth_field(new_tuple->ptr, i);
		old_dfield = dtuple_get_nth_field(old_tuple->ptr, i);

		mtype = dtype_get_mtype(dfield_get_type(old_dfield));
		prtype = dtype_get_prtype(dfield_get_type(old_dfield));

		/* Skip the system columns */
		if (mtype == DATA_SYS) {
			continue;

		} else if ((prtype & DATA_NOT_NULL)
			   && dfield_is_null(new_dfield)) {

			err = DB_DATA_MISMATCH;
			break;
		}

		if (dfield_get_len(new_dfield) != dfield_get_len(old_dfield)
		    || (!dfield_is_null(old_dfield)
		        && memcmp(dfield_get_data(new_dfield),
			      dfield_get_data(old_dfield),
			      dfield_get_len(old_dfield)) != 0)) {

			upd_field = &upd->fields[n_changed];

			ib_update_col(cursor, upd_field, i, new_dfield);

			++n_changed;
		}
	}

	if (err == DB_SUCCESS) {
		upd->info_bits = 0;
		upd->n_fields = n_changed;
	}

	return(err);
}

/**********************************************************************//**
Run the update query and do error handling.
@return	DB_SUCCESS or error code */
UNIV_INLINE
ib_err_t
ib_update_row_with_lock_retry(
/*==========================*/
	que_thr_t*	thr,		/*!< in: Update query graph */
	upd_node_t*	node,		/*!< in: Update node for the query */
	trx_savept_t*	savept)		/*!< in: savepoint to rollback to
					in case of an error */

{
	trx_t*		trx;
	ib_err_t	err;
	ib_bool_t	lock_wait;

	trx = thr_get_trx(thr);

	do {
		thr->run_node = node;
		thr->prev_node = node;

		row_upd_step(thr);

		err = trx->error_state;

		if (err != DB_SUCCESS) {
			que_thr_stop_client(thr);

			if (err != DB_RECORD_NOT_FOUND) {
				thr->lock_state = QUE_THR_LOCK_ROW;

				lock_wait = ib_handle_errors(
					&err, trx, thr, savept);

				thr->lock_state = QUE_THR_LOCK_NOLOCK;
			} else {
				lock_wait = FALSE;
			}
		} else {
			lock_wait = FALSE;
		}
	} while (lock_wait);

	return(err);
}

/*********************************************************************//**
Does an update or delete of a row.
@return	DB_SUCCESS or err code */
UNIV_INLINE
ib_err_t
ib_execute_update_query_graph(
/*==========================*/
	ib_cursor_t*	cursor,		/*!< in: Cursor instance */
	btr_pcur_t*	pcur)		/*!< in: Btree persistent cursor */
{
	ib_err_t	err;
	que_thr_t*	thr;
	upd_node_t*	node;
	trx_savept_t	savept;
	trx_t*		trx = cursor->prebuilt->trx;
	dict_table_t*	table = cursor->prebuilt->table;
	ib_qry_proc_t*	q_proc = &cursor->q_proc;

	UT_DBG_ENTER_FUNC;

	/* The transaction must be running. */
	ut_a(trx->conc_state != TRX_NOT_STARTED);

	node = q_proc->node.upd;

	/* This is a short term solution to fix the purge lag. */
	ib_delay_dml_if_needed();

	ut_a(dict_index_is_clust(pcur->btr_cur.index));
	btr_pcur_copy_stored_position(node->pcur, pcur);

	ut_a(node->pcur->rel_pos == BTR_PCUR_ON);

	savept = trx_savept_take(trx);

	thr = que_fork_get_first_thr(q_proc->grph.upd);

	node->state = UPD_NODE_UPDATE_CLUSTERED;

	que_thr_move_to_run_state(thr);

	err = ib_update_row_with_lock_retry(thr, node, &savept);

	if (err == DB_SUCCESS) {

		que_thr_stop_for_client_no_error(thr, trx);

		if (node->is_delete) {

			if (table->stat_n_rows > 0) {
				table->stat_n_rows--;
			}

			srv_n_rows_deleted++;
		} else {
			srv_n_rows_updated++;
		}

		ib_update_statistics_if_needed(table);

	} else if (err == DB_RECORD_NOT_FOUND) {
		trx->error_state = DB_SUCCESS;
	}

	ib_wake_master_thread();

	trx->op_info = "";

	return(err);
}

/*****************************************************************//**
Update a row in a table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_update_row(
/*=================*/
	ib_crsr_t	ib_crsr,	/*!< in: InnoDB cursor instance */
	const ib_tpl_t	ib_old_tpl,	/*!< in: Old tuple in table */
	const ib_tpl_t	ib_new_tpl)	/*!< in: New tuple to update */
{
	upd_t*		upd;
	ib_err_t	err;
	btr_pcur_t*	pcur;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;
	const ib_tuple_t*old_tuple = (const ib_tuple_t*) ib_old_tpl;
	const ib_tuple_t*new_tuple = (const ib_tuple_t*) ib_new_tpl;

	UT_DBG_ENTER_FUNC;

	if (dict_index_is_clust(prebuilt->index)) {
		pcur = cursor->prebuilt->pcur;
	} else if (prebuilt->need_to_access_clustered
		   && cursor->prebuilt->clust_pcur != NULL) {
		pcur = cursor->prebuilt->clust_pcur;
	} else {
		return(DB_ERROR);
	}

	ut_a(old_tuple->type == TPL_ROW);
	ut_a(new_tuple->type == TPL_ROW);

	upd = ib_update_vector_create(cursor);

	err = ib_calc_diff(cursor, upd, old_tuple, new_tuple);

	if (err == DB_SUCCESS) {
		/* Note that this is not a delete. */
		cursor->q_proc.node.upd->is_delete = FALSE;

		err = ib_execute_update_query_graph(cursor, pcur);
	}

	return(err);
}

/**********************************************************************//**
Build the update query graph to delete a row from an index.
@return	DB_SUCCESS or err code */
UNIV_STATIC
ib_err_t
ib_delete_row(
/*==========*/
	ib_cursor_t*	cursor,		/*!< in: current cursor */
	btr_pcur_t*	pcur,		/*!< in: Btree persistent cursor */
	const rec_t*	rec)		/*!< in: record to delete */
{
	ulint		i;
	upd_t*		upd;
	ib_err_t	err;
	ib_tuple_t*	tuple;
	ib_tpl_t	ib_tpl;
	ulint		n_cols;
	upd_field_t*	upd_field;
	ib_bool_t	page_format;
	dict_table_t*	table = cursor->prebuilt->table;
	dict_index_t*	index = dict_table_get_first_index(table);

	UT_DBG_ENTER_FUNC;

	n_cols = dict_index_get_n_ordering_defined_by_user(index);
	ib_tpl = ib_key_tuple_new(index, n_cols);

	if (!ib_tpl) {
		return(DB_OUT_OF_MEMORY);
	}

	tuple = (ib_tuple_t*) ib_tpl;

	upd = ib_update_vector_create(cursor);

	page_format = dict_table_is_comp(index->table);
	ib_read_tuple(cursor, rec, page_format, tuple);

	upd->n_fields = ib_tuple_get_n_cols(ib_tpl);

	for (i = 0; i < upd->n_fields; ++i) {
		dfield_t*	dfield;

		upd_field = &upd->fields[i];
		dfield = dtuple_get_nth_field(tuple->ptr, i);

		dfield_copy_data(&upd_field->new_val, dfield);

		upd_field->exp = NULL;

		upd_field->orig_len = 0;

		upd->info_bits = 0;

		upd_field->field_no = dict_col_get_clust_pos(
			&table->cols[i], index);
	}

	/* Note that this is a delete. */
	cursor->q_proc.node.upd->is_delete = TRUE;

	err = ib_execute_update_query_graph(cursor, pcur);

	ib_tuple_delete(ib_tpl);

	return(err);
}

/*****************************************************************//**
Delete a row in a table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_delete_row(
/*=================*/
	ib_crsr_t	ib_crsr)	/*!< in: InnoDB cursor instance */
{
	ib_err_t	err;
	btr_pcur_t*	pcur;
	dict_index_t*	index;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	index = dict_table_get_first_index(prebuilt->index->table);

	/* Check whether this is a secondary index cursor */
	if (index != prebuilt->index) {
		if (prebuilt->need_to_access_clustered) {
			pcur = prebuilt->clust_pcur;
		} else {
			return(DB_ERROR);
		}
	} else {
		pcur = prebuilt->pcur;
	}

	if (ib_btr_cursor_is_positioned(pcur)) {
		const rec_t*	rec;
		ib_bool_t	page_format;

		page_format = dict_table_is_comp(index->table);

		if (!row_sel_row_cache_is_empty(prebuilt)) {
			rec = row_sel_row_cache_get(prebuilt);
			ut_a(rec != NULL);
		} else {
			mtr_t	mtr;

			mtr_start(&mtr);

			if (btr_pcur_restore_position(
				BTR_SEARCH_LEAF, pcur, &mtr)) {

				rec = btr_pcur_get_rec(pcur);
			} else {
				rec = NULL;
			}

			mtr_commit(&mtr);
		}

		if (rec && !rec_get_deleted_flag(rec, page_format)) {
			err = ib_delete_row(cursor, pcur, rec);
		} else{
			err = DB_RECORD_NOT_FOUND;
		}
	} else {
		err = DB_RECORD_NOT_FOUND;
	}

	return(err);
}

/*****************************************************************//**
Read current row.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_read_row(
/*===============*/
	ib_crsr_t	ib_crsr,	/*!< in: InnoDB cursor instance */
	ib_tpl_t	ib_tpl)		/*!< out: read cols into this tuple */
{
	ib_err_t	err;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;

	UT_DBG_ENTER_FUNC;

	ut_a(cursor->prebuilt->trx->conc_state != TRX_NOT_STARTED);

	/* When searching with IB_EXACT_MATCH set, row_search_for_client()
	will not position the persistent cursor but will copy the record
	found into the row cache. It should be the only entry. */
	if (!ib_cursor_is_positioned(ib_crsr)
	    && row_sel_row_cache_is_empty(cursor->prebuilt)) {
		err = DB_RECORD_NOT_FOUND;
	} else if (!row_sel_row_cache_is_empty(cursor->prebuilt)) {
                const rec_t*	rec;
                ib_bool_t	page_format;

                page_format = dict_table_is_comp(tuple->index->table);

                rec = row_sel_row_cache_get(cursor->prebuilt);
                ut_a(rec != NULL);

                if (!rec_get_deleted_flag(rec, page_format)) {
                        ib_read_tuple(cursor, rec, page_format, tuple);
			err = DB_SUCCESS;
                } else{
                        err = DB_RECORD_NOT_FOUND;
                }
        } else {
		mtr_t		mtr;
		btr_pcur_t*	pcur;
		row_prebuilt_t*	prebuilt = cursor->prebuilt;

		if (prebuilt->need_to_access_clustered
		    && tuple->type == TPL_ROW) {
			pcur = prebuilt->clust_pcur;
		} else {
			pcur = prebuilt->pcur;
		}

		if (pcur == NULL) {
			return(DB_ERROR);
		}

		mtr_start(&mtr);

		if (btr_pcur_restore_position(BTR_SEARCH_LEAF, pcur, &mtr)) {
			const rec_t*	rec;
			ib_bool_t	page_format;

			page_format = dict_table_is_comp(tuple->index->table);
			rec = btr_pcur_get_rec(pcur);

			if (!rec_get_deleted_flag(rec, page_format)) {
				ib_read_tuple(cursor, rec, page_format, tuple);
				err = DB_SUCCESS;
			} else{
				err = DB_RECORD_NOT_FOUND;
			}
		} else {
			err = DB_RECORD_NOT_FOUND;
		}

		mtr_commit(&mtr);
	}

	return(err);
}

/*****************************************************************//**
Move cursor to the prev user record in the table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_prev(
/*===========*/
	ib_crsr_t	ib_crsr)	/*!< in: InnoDB cursor instance */
{
	ib_err_t	err;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	/* We want to move to the next record */
	dtuple_set_n_fields(prebuilt->search_tuple, 0);

	row_sel_row_cache_next(prebuilt);

	err = row_search_for_client(
		srv_force_recovery,
		IB_CUR_L, prebuilt, ROW_SEL_DEFAULT, ROW_SEL_PREV);

	return(err);
}

/*****************************************************************//**
Move cursor to the next user record in the table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_next(
/*===========*/
	ib_crsr_t	ib_crsr)	/*!< in: InnoDB cursor instance */
{
	ib_err_t	err;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	/* We want to move to the next record */
	dtuple_set_n_fields(prebuilt->search_tuple, 0);

	row_sel_row_cache_next(prebuilt);

	err = row_search_for_client(
		srv_force_recovery,
		IB_CUR_G, prebuilt, ROW_SEL_DEFAULT, ROW_SEL_NEXT);

	return(err);
}

/*****************************************************************//**
Move cursor to the first record in the table.
@return	DB_SUCCESS or err code */
UNIV_INLINE
ib_err_t
ib_cursor_position(
/*===============*/
	ib_cursor_t*	cursor,		/*!< in: InnoDB cursor instance */
	ib_srch_mode_t	mode)		/*!< in: Search mode */
{
	ib_err_t	err;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	/* We want to position at one of the ends, row_search_for_client()
	uses the search_tuple fields to work out what to do. */
	dtuple_set_n_fields(prebuilt->search_tuple, 0);

	err = row_search_for_client(
		srv_force_recovery,
		mode, prebuilt, ROW_SEL_DEFAULT, ROW_SEL_MOVETO);

	return(err);
}

/*****************************************************************//**
Move cursor to the first record in the table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_first(
/*============*/
	ib_crsr_t	ib_crsr)	/*!< in: InnoDB cursor instance */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;

	return(ib_cursor_position(cursor, IB_CUR_G));
}

/*****************************************************************//**
Move cursor to the last record in the table.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_last(
/*===========*/
	ib_crsr_t	ib_crsr)	/*!< in: InnoDB cursor instance */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;

	return(ib_cursor_position(cursor, IB_CUR_L));
}

/*****************************************************************//**
Search for key.
@return	DB_SUCCESS or err code */

ib_err_t
ib_cursor_moveto(
/*=============*/
	ib_crsr_t	ib_crsr,	/*!< in: InnoDB cursor instance */
	ib_tpl_t	ib_tpl,		/*!< in: Key to search for */
	ib_srch_mode_t	ib_srch_mode,	/*!< in: search mode */
	int*		result)		/*!< out: -1, 0 or 1 depending on
					tuple eq or gt than current row */
{
	ulint		i;
	ulint		n_fields;
	ib_err_t	err = DB_SUCCESS;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;
	dtuple_t*	search_tuple = prebuilt->search_tuple;

	UT_DBG_ENTER_FUNC;

	ut_a(tuple->type == TPL_KEY);

	n_fields = dict_index_get_n_ordering_defined_by_user(prebuilt->index);

	dtuple_set_n_fields(search_tuple, n_fields);
	dtuple_set_n_fields_cmp(search_tuple, n_fields);

	/* Do a shallow copy */
	for (i = 0; i < n_fields; ++i) {
		dfield_copy(dtuple_get_nth_field(search_tuple, i),
			    dtuple_get_nth_field(tuple->ptr, i));
	}

	ut_a(prebuilt->select_lock_type <= LOCK_NUM);

	err = row_search_for_client(
		srv_force_recovery, ib_srch_mode,
		prebuilt, (ib_match_t) cursor->match_mode, ROW_SEL_MOVETO);

	*result = prebuilt->result;

	return(err);
}

/*****************************************************************//**
Attach the cursor to the transaction. */

void
ib_cursor_attach_trx(
/*=================*/
	ib_crsr_t	ib_crsr,	/*!< in: cursor instance */
	ib_trx_t	ib_trx)		/*!< in: transaction */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	ut_a(ib_trx != NULL);
	ut_a(prebuilt->trx == NULL);

	row_prebuilt_reset(prebuilt);
	row_prebuilt_update_trx(prebuilt, (trx_t*) ib_trx);

	/* Assign a read view if the transaction does not have it yet */
	trx_assign_read_view(prebuilt->trx);

	ut_a(prebuilt->trx->conc_state != TRX_NOT_STARTED);

	++prebuilt->trx->n_client_tables_in_use;
}

/*****************************************************************//**
Set the client comparison function for BLOBs and client types. */

void
ib_set_client_compare(
/*==================*/
	ib_client_cmp_t	client_cmp_func)/*!< in: client col. compare callback */
{
	UT_DBG_ENTER_FUNC;

	ib_client_compare = client_cmp_func;
}

/*****************************************************************//**
Set the cursor search mode. */

void
ib_cursor_set_match_mode(
/*=====================*/
	ib_crsr_t	ib_crsr,	/*!< in: Cursor instance */
	ib_match_mode_t	match_mode)	/*!< in: ib_cursor_moveto match mode */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;

	UT_DBG_ENTER_FUNC;

	cursor->match_mode = match_mode;
}

/*****************************************************************//**
Get the dfield instance for the column in the tuple.
@return	dfield instance in tuple */
UNIV_INLINE
dfield_t*
ib_col_get_dfield(
/*==============*/
	ib_tuple_t*	tuple,		/*!< in: tuple instance */
	ulint		col_no)		/*!< in: col no. in tuple */
{
	dfield_t*	dfield;

	UT_DBG_ENTER_FUNC;

	dfield = dtuple_get_nth_field(tuple->ptr, col_no);

	return(dfield);
}

/*****************************************************************//**
Predicate to check whether a column type contains variable length data.
@return	DB_SUCCESS or error code */
UNIV_INLINE
ib_err_t
ib_col_is_capped(
/*==============*/
	const dtype_t*  dtype)		/* in: column type */
{
	return((dtype_get_mtype(dtype) == DATA_VARCHAR
		|| dtype_get_mtype(dtype) == DATA_CHAR
		|| dtype_get_mtype(dtype) == DATA_CLIENT
		|| dtype_get_mtype(dtype) == DATA_VARCLIENT
		|| dtype_get_mtype(dtype) == DATA_FIXBINARY
		|| dtype_get_mtype(dtype) == DATA_BINARY)
	       && dtype_get_len(dtype) > 0);
}

/*****************************************************************//**
Set a column of the tuple. Make a copy using the tuple's heap.
@return	DB_SUCCESS or error code */

ib_err_t
ib_col_set_value(
/*=============*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	col_no,		/*!< in: column index in tuple */
	const void*	src,		/*!< in: data value */
	ib_ulint_t	len)		/*!< in: data value len */
{
	const dtype_t*  dtype;
	dfield_t*	dfield;
	void*		dst = NULL;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

#ifdef UNIV_DEBUG
	mem_heap_verify(tuple->heap);
#endif

	dfield = ib_col_get_dfield(tuple, col_no);

	/* User wants to set the column to NULL. */
	if (len == IB_SQL_NULL) {
		dfield_set_null(dfield);
		return(DB_SUCCESS);
	}

	dtype = dfield_get_type(dfield);

	/* Not allowed to update system columns. */
	if (dtype_get_mtype(dtype) == DATA_SYS) {
		return(DB_DATA_MISMATCH);
	}

	dst = dfield_get_data(dfield);

	/* Since TEXT/CLOB also map to DATA_VARCHAR we need to make an
	exception. Perhaps we need to set the precise type and check
	for that. */
	if (ib_col_is_capped(dtype)) {

		len = ut_min(len, dtype_get_len(dtype));

		if (dst == NULL) {
			dst = mem_heap_alloc(tuple->heap, dtype_get_len(dtype));
			ut_a(dst != NULL);
		}
	} else if (dst == NULL || len > dfield_get_len(dfield)) {
		dst = mem_heap_alloc(tuple->heap, len);
	}

	if (dst == NULL) {
		return(DB_OUT_OF_MEMORY);
	}

	switch (dtype_get_mtype(dtype)) {
	case DATA_INT: {

		if (dtype_get_len(dtype) == len) {
			ibool		usign;

			usign = dtype_get_prtype(dtype) & DATA_UNSIGNED;
			mach_write_int_type(dst, src, len, usign);
		} else {
			return(DB_DATA_MISMATCH);
		}
		break;
	}

	case DATA_FLOAT:
		if (len == sizeof(float)) {
			mach_float_ptr_write(dst, src);
		} else {
			return(DB_DATA_MISMATCH);
		}
		break;

	case DATA_DOUBLE:
		if (len == sizeof(double)) {
			mach_double_ptr_write(dst, src);
		} else {
			return(DB_DATA_MISMATCH);
		}
		break;

	case DATA_SYS:
		ut_error;
		break;

	case DATA_CHAR: {
		ulint	pad_char = ULINT_UNDEFINED;

		pad_char = dtype_get_pad_char(
			dtype_get_mtype(dtype),	dtype_get_prtype(dtype));

		ut_a(pad_char != ULINT_UNDEFINED);

		memset((byte*) dst + len,
		       pad_char,
		       dtype_get_len(dtype) - len);

		len = dtype_get_len(dtype);
		/* Fall through */
	}
	case DATA_BLOB:
	case DATA_BINARY:
	case DATA_CLIENT:
	case DATA_DECIMAL:
	case DATA_VARCHAR:
	case DATA_VARCLIENT:
	case DATA_FIXBINARY:
		memcpy(dst, src, len);
		break;

	default:
		ut_error;
	}

	if (dst != dfield_get_data(dfield)) {
		dfield_set_data(dfield, dst, len);
	} else {
		dfield_set_len(dfield, len);
	}

#ifdef UNIV_DEBUG
	mem_heap_verify(tuple->heap);
#endif

	return(DB_SUCCESS);
}

/*****************************************************************//**
Get the size of the data available in a column of the tuple.
@return	bytes avail or IB_SQL_NULL */

ib_ulint_t
ib_col_get_len(
/*===========*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	i)		/*!< in: column index in tuple */
{
	const dfield_t*		dfield;
	ulint			data_len;
	ib_tuple_t*		tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, i);

	data_len = dfield_get_len(dfield);

	return(data_len == UNIV_SQL_NULL ? IB_SQL_NULL : data_len);
}

/*****************************************************************//**
Copy a column value from the tuple.
@return	bytes copied or IB_SQL_NULL */
UNIV_INLINE
ib_ulint_t
ib_col_copy_value_low(
/*==================*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	i,		/*!< in: column index in tuple */
	void*		dst,		/*!< out: copied data value */
	ib_ulint_t	len)		/*!< in: max data value len to copy */
{
	const void*	data;
	const dfield_t*	dfield;
	ulint		data_len;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, i);

	data = dfield_get_data(dfield);
	data_len = dfield_get_len(dfield);

	if (data_len != UNIV_SQL_NULL) {

		const dtype_t*  dtype = dfield_get_type(dfield);

		switch (dtype_get_mtype(dfield_get_type(dfield))) {
		case DATA_INT: {
			ibool		usign;

			ut_a(data_len == len);

			usign = dtype_get_prtype(dtype) & DATA_UNSIGNED;
			mach_read_int_type(dst, data, data_len, usign);
			break;
		}
		case DATA_FLOAT:
			if (len == data_len) {
				float	f;

				ut_a(data_len == sizeof(f));
				f = mach_float_read(data);
				memcpy(dst, &f, sizeof(f));
			} else {
				data_len = 0;
			}
			break;
		case DATA_DOUBLE:
			if (len == data_len) {
				double	d;

				ut_a(data_len == sizeof(d));
				d = mach_double_read(data);
				memcpy(dst, &d, sizeof(d));
			} else {
				data_len = 0;
			}
			break;
		default:
			data_len = ut_min(data_len, len);
			memcpy(dst, data, data_len);
		}
	} else {
		data_len = IB_SQL_NULL;
	}

	return(data_len);
}

/*****************************************************************//**
Copy a column value from the tuple.
@return	bytes copied or IB_SQL_NULL */

ib_ulint_t
ib_col_copy_value(
/*==============*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	i,		/*!< in: column index in tuple */
	void*		dst,		/*!< out: copied data value */
	ib_ulint_t	len)		/*!< in: max data value len to copy */
{
	return(ib_col_copy_value_low(ib_tpl, i, dst, len));
}

/*****************************************************************//**
Get the InnoDB column attribute from the internal column precise type.
@return	precise type in api format */
UNIV_INLINE
ib_col_attr_t
ib_col_get_attr(
/*============*/
	ulint		prtype)		/*!< in: column definition */
{
	ib_col_attr_t	attr = IB_COL_NONE;

	UT_DBG_ENTER_FUNC;

	if (prtype & DATA_UNSIGNED) {
		attr |= IB_COL_UNSIGNED;
	}

	if (prtype & DATA_NOT_NULL) {
		attr |= IB_COL_NOT_NULL;
	}

	if (prtype & DATA_CUSTOM_TYPE) {
		attr |= IB_COL_CUSTOM1;
	}

	if (prtype & (DATA_CUSTOM_TYPE << 1)) {
		attr |= IB_COL_CUSTOM2;
	}

	if (prtype & (DATA_CUSTOM_TYPE << 2)) {
		attr |= IB_COL_CUSTOM3;
	}

	return(attr);
}

/*****************************************************************//**
Get a column type, length and attributes from the tuple.
@return	len of column data */
UNIV_INLINE
ib_ulint_t
ib_col_get_meta_low(
/*================*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	i,		/*!< in: column index in tuple */
	ib_col_meta_t*	ib_col_meta)	/*!< out: column meta data */
{
	ib_u16_t	prtype;
	const dfield_t*	dfield;
	ulint		data_len;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, i);

	data_len = dfield_get_len(dfield);

	/* We assume 1-1 mapping between the ENUM and internal type codes. */
	ib_col_meta->type = dtype_get_mtype(dfield_get_type(dfield));

	ib_col_meta->type_len = dtype_get_len(dfield_get_type(dfield));

	prtype = (ib_u16_t) dtype_get_prtype(dfield_get_type(dfield));

	ib_col_meta->attr = ib_col_get_attr(prtype);
	ib_col_meta->client_type = prtype & DATA_CLIENT_TYPE_MASK;

	return(data_len);
}

/*************************************************************//**
Read a signed int 8 bit column from an InnoDB tuple. */
UNIV_INLINE
ib_err_t
ib_tuple_check_int(
/*===============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_bool_t		usign,	/*!< in: true if unsigned */
	ulint			size)	/*!< in: size of integer */
{
	ib_col_meta_t		ib_col_meta;

	ib_col_get_meta_low(ib_tpl, i, &ib_col_meta);

	if (ib_col_meta.type != IB_INT) {
		return(DB_DATA_MISMATCH);
	} else if (ib_col_meta.type_len == IB_SQL_NULL) {
		return(DB_UNDERFLOW);
	} else if (ib_col_meta.type_len != size) {
		return(DB_DATA_MISMATCH);
	} else if ((ib_col_meta.attr & IB_COL_UNSIGNED) && !usign) {
		return(DB_DATA_MISMATCH);
	}

	return(DB_SUCCESS);
}

/*************************************************************//**
Read a signed int 8 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i8(
/*=============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_i8_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, IB_FALSE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read an unsigned int 8 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u8(
/*=============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_u8_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, IB_TRUE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read a signed int 16 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i16(
/*==============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_i16_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, FALSE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read an unsigned int 16 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u16(
/*==============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_u16_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, IB_TRUE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read a signed int 32 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i32(
/*==============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_i32_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, FALSE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read an unsigned int 32 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u32(
/*==============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_u32_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, IB_TRUE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read a signed int 64 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_i64(
/*==============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_i64_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, FALSE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*************************************************************//**
Read an unsigned int 64 bit column from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_u64(
/*==============*/
	ib_tpl_t		ib_tpl,	/*!< in: InnoDB tuple */
	ib_ulint_t		i,	/*!< in: column number */
	ib_u64_t*		ival)	/*!< out: integer value */
{
	ib_err_t		err;

	err = ib_tuple_check_int(ib_tpl, i, IB_TRUE, sizeof(*ival));

	if (err == DB_SUCCESS) {
		ib_col_copy_value_low(ib_tpl, i, ival, sizeof(*ival));
	}

	return(err);
}

/*****************************************************************//**
Get a column value pointer from the tuple.
@return	NULL or pointer to buffer */

const void*
ib_col_get_value(
/*=============*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	i)		/*!< in: column index in tuple */
{
	const void*	data;
	const dfield_t*	dfield;
	ulint		data_len;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, i);

	data = dfield_get_data(dfield);
	data_len = dfield_get_len(dfield);

	return(data_len != UNIV_SQL_NULL ? data : NULL);
}

/*****************************************************************//**
Get a column type, length and attributes from the tuple.
@return	len of column data */

ib_ulint_t
ib_col_get_meta(
/*============*/
	ib_tpl_t	ib_tpl,		/*!< in: tuple instance */
	ib_ulint_t	i,		/*!< in: column index in tuple */
	ib_col_meta_t*	ib_col_meta)	/*!< out: column meta data */
{
	return(ib_col_get_meta_low(ib_tpl, i, ib_col_meta));
}

/*****************************************************************//**
"Clear" or reset an InnoDB tuple. We free the heap and recreate the tuple.
@return	new tuple, or NULL */

ib_tpl_t
ib_tuple_clear(
/*============*/
	ib_tpl_t	ib_tpl)		/*!< in,own: tuple (will be freed) */
{
	const dict_index_t*	index;
	ulint			n_cols;
	ib_tuple_t*		tuple	= (ib_tuple_t*) ib_tpl;
	ib_tuple_type_t		type	= tuple->type;
	mem_heap_t*		heap	= tuple->heap;

	UT_DBG_ENTER_FUNC;

	index = tuple->index;
	n_cols = dtuple_get_n_fields(tuple->ptr);

	mem_heap_empty(heap);

	if (type == TPL_ROW) {
		return(ib_row_tuple_new_low(index, n_cols, heap));
	} else {
		return(ib_key_tuple_new_low(index, n_cols, heap));
	}
}

/*****************************************************************//**
Create a new cluster key search tuple and copy the contents of  the
secondary index key tuple columns that refer to the cluster index record
to the cluster key. It does a deep copy of the column data.
@return	DB_SUCCESS or error code */

ib_err_t
ib_tuple_get_cluster_key(
/*=====================*/
	ib_crsr_t	ib_crsr,	/*!< in: secondary index cursor */
	ib_tpl_t*	ib_dst_tpl,	/*!< out,own: destination tuple */
	const ib_tpl_t	ib_src_tpl)	/*!< in: source tuple */
{
	ulint		i;
	ulint		n_fields;
	ib_err_t	err = DB_SUCCESS;
	ib_tuple_t*	dst_tuple = NULL;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	ib_tuple_t*	src_tuple = (ib_tuple_t*) ib_src_tpl;
	dict_index_t*	clust_index;

	clust_index = dict_table_get_first_index(cursor->prebuilt->table);

	/* We need to ensure that the src tuple belongs to the same table
	as the open cursor and that it's not a tuple for a cluster index. */
	if (src_tuple->type != TPL_KEY) {
		return(DB_ERROR);
	} else if (src_tuple->index->table != cursor->prebuilt->table) {
		return(DB_DATA_MISMATCH);
	} else if (src_tuple->index == clust_index) {
		return(DB_ERROR);
	}

	/* Create the cluster index key search tuple. */
	*ib_dst_tpl = ib_clust_search_tuple_create(ib_crsr);

	if (!*ib_dst_tpl) {
		return(DB_OUT_OF_MEMORY);
	}

	dst_tuple = (ib_tuple_t*) *ib_dst_tpl;
	ut_a(dst_tuple->index == clust_index);

	n_fields = dict_index_get_n_unique(dst_tuple->index);

	/* Do a deep copy of the data fields. */
	for (i = 0; i < n_fields; i++) {
		ulint		pos;
		dfield_t*	src_field;
		dfield_t*	dst_field;

		pos = dict_index_get_nth_field_pos(
			src_tuple->index, dst_tuple->index, i);

		ut_a(pos != ULINT_UNDEFINED);

		src_field = dtuple_get_nth_field(src_tuple->ptr, pos);
		dst_field = dtuple_get_nth_field(dst_tuple->ptr, i);

		if (!dfield_is_null(src_field)) {
			UNIV_MEM_ASSERT_RW(src_field->data, src_field->len);

			dst_field->data = mem_heap_dup(
				dst_tuple->heap,
				src_field->data,
				src_field->len);

			dst_field->len = src_field->len;
		} else {
			dfield_set_null(dst_field);
		}
	}

	return(err);
}

/*****************************************************************//**
Copy the contents of  source tuple to destination tuple. The tuples
must be of the same type and belong to the same table/index.
@return	DB_SUCCESS or error code */

ib_err_t
ib_tuple_copy(
/*==========*/
	ib_tpl_t	ib_dst_tpl,	/*!< in: destination tuple */
	const ib_tpl_t	ib_src_tpl)	/*!< in: source tuple */
{
	ulint		i;
	ulint		n_fields;
	ib_err_t	err = DB_SUCCESS;
	const ib_tuple_t*src_tuple = (const ib_tuple_t*) ib_src_tpl;
	ib_tuple_t*	dst_tuple = (ib_tuple_t*) ib_dst_tpl;

	/* Make sure src and dst are not the same. */
	ut_a(src_tuple != dst_tuple);

	/* Make sure they are the same type and refer to the same index. */
	if (src_tuple->type != dst_tuple->type
	   || src_tuple->index != dst_tuple->index) {

		return(DB_DATA_MISMATCH);
	}

	n_fields = dtuple_get_n_fields(src_tuple->ptr);
	ut_ad(n_fields == dtuple_get_n_fields(dst_tuple->ptr));

	/* Do a deep copy of the data fields. */
	for (i = 0; i < n_fields; ++i) {
		dfield_t*	src_field;
		dfield_t*	dst_field;

		src_field = dtuple_get_nth_field(src_tuple->ptr, i);
		dst_field = dtuple_get_nth_field(dst_tuple->ptr, i);

		if (!dfield_is_null(src_field)) {
			UNIV_MEM_ASSERT_RW(src_field->data, src_field->len);

			dst_field->data = mem_heap_dup(
				dst_tuple->heap,
				src_field->data,
				src_field->len);

			dst_field->len = src_field->len;
		} else {
			dfield_set_null(dst_field);
		}
	}

	return(err);
}

/*****************************************************************//**
Create an InnoDB tuple used for index/table search.
@return	own: Tuple for current index */

ib_tpl_t
ib_sec_search_tuple_create(
/*=======================*/
	ib_crsr_t	ib_crsr)	/*!< in: Cursor instance */
{
	ulint		n_cols;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	dict_index_t*	index = cursor->prebuilt->index;

	UT_DBG_ENTER_FUNC;

	n_cols = dict_index_get_n_unique_in_tree(index);
	return(ib_key_tuple_new(index, n_cols));
}

/*****************************************************************//**
Create an InnoDB tuple used for index/table search.
@return	own: Tuple for current index */

ib_tpl_t
ib_sec_read_tuple_create(
/*=====================*/
	ib_crsr_t	ib_crsr)	/*!< in: Cursor instance */
{
	ulint		n_cols;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	dict_index_t*	index = cursor->prebuilt->index;

	UT_DBG_ENTER_FUNC;

	n_cols = dict_index_get_n_fields(index);
	return(ib_row_tuple_new(index, n_cols));
}

/*****************************************************************//**
Create an InnoDB tuple used for table key operations.
@return	own: Tuple for current table */

ib_tpl_t
ib_clust_search_tuple_create(
/*=========================*/
	ib_crsr_t	ib_crsr)	/*!< in: Cursor instance */
{
	ulint		n_cols;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	dict_index_t*	index;

	index = dict_table_get_first_index(cursor->prebuilt->table);

	UT_DBG_ENTER_FUNC;

	n_cols = dict_index_get_n_ordering_defined_by_user(index);
	return(ib_key_tuple_new(index, n_cols));
}

/*****************************************************************//**
Create an InnoDB tuple for table row operations.
@return	own: Tuple for current table */

ib_tpl_t
ib_clust_read_tuple_create(
/*=======================*/
	ib_crsr_t	ib_crsr)	/*!< in: Cursor instance */
{
	ulint		n_cols;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	dict_index_t*	index;

	index = dict_table_get_first_index(cursor->prebuilt->table);

	UT_DBG_ENTER_FUNC;

	n_cols = dict_table_get_n_cols(cursor->prebuilt->table);
	return(ib_row_tuple_new(index, n_cols));
}

/*****************************************************************//**
Return the number of user columns in the tuple definition.
@return	number of user columns */

ib_ulint_t
ib_tuple_get_n_user_cols(
/*=====================*/
	const ib_tpl_t	ib_tpl)		/*!< in: Tuple for current table */
{
	const ib_tuple_t*	tuple = (const ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	if (tuple->type == TPL_ROW) {
		return(dict_table_get_n_user_cols(tuple->index->table));
	}

	return(dict_index_get_n_ordering_defined_by_user(tuple->index));
}

/*****************************************************************//**
Return the number of columns in the tuple definition.
@return	number of columns */

ib_ulint_t
ib_tuple_get_n_cols(
/*================*/
	const ib_tpl_t	ib_tpl)		/*!< in: Tuple for table/index */
{
	const ib_tuple_t*	tuple = (const ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	return(dtuple_get_n_fields(tuple->ptr));
}

/*****************************************************************//**
Destroy an InnoDB tuple. */

void
ib_tuple_delete(
/*============*/
	ib_tpl_t	ib_tpl)		/*!< in,own: Tuple instance to delete */
{
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	mem_heap_free(tuple->heap);
}

/*****************************************************************//**
Truncate a table. The cursor handle will be closed and set to NULL
on success.
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_truncate(
/*===============*/
	ib_crsr_t*	ib_crsr,	/*!< in/out: cursor for table
					to truncate */
	ib_id_t*	table_id)	/*!< out: new table id */
{
	ib_err_t	err;
	ib_cursor_t*	cursor = *(ib_cursor_t**) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	ut_a(ib_schema_lock_is_exclusive((ib_trx_t) prebuilt->trx));

	*table_id = 0;

	err = ib_cursor_lock(*ib_crsr, IB_LOCK_X);

	if (err == DB_SUCCESS) {
		trx_t*		trx;
		dict_table_t*	table = prebuilt->table;

		/* We are going to free the cursor and the prebuilt. Store
		the transaction handle locally. */
		trx = prebuilt->trx;
		err = ib_cursor_close(*ib_crsr);
		ut_a(err == DB_SUCCESS);

		*ib_crsr = NULL;

		/* This function currently commits the transaction
		on success. */
		err = ddl_truncate_table(table, trx);

		if (err == DB_SUCCESS) {
			*table_id = ut_conv_dulint_to_longlong(table->id);
		}
	}

	return(err);
}

/*****************************************************************//**
Truncate a table.
@return	DB_SUCCESS or error code */

ib_err_t
ib_table_truncate(
/*==============*/
	const char*	table_name,	/*!< in: table name */
	ib_id_t*	table_id)	/*!< out: new table id */
{
	ib_err_t	err;
	dict_table_t*	table;
	ib_err_t	trunc_err;
	ib_trx_t	ib_trx = NULL;
	ib_crsr_t	ib_crsr = NULL;

	ib_trx = ib_trx_begin(IB_TRX_SERIALIZABLE);

	dict_mutex_enter();

	table = dict_table_get_low(table_name);

	if (table != NULL && dict_table_get_first_index(table)) {
		dict_table_increment_handle_count(table, TRUE);
		err = ib_create_cursor(&ib_crsr, table, 0, (trx_t*) ib_trx);
	} else {
		err = DB_TABLE_NOT_FOUND;
	}

	dict_mutex_exit();

	if (err == DB_SUCCESS) {
		err = ib_schema_lock_exclusive(ib_trx);
	}

	if (err == DB_SUCCESS) {
		trunc_err = ib_cursor_truncate(&ib_crsr, table_id);
		ut_a(err == DB_SUCCESS);
	} else {
		trunc_err = err;
	}

	if (ib_crsr != NULL) {
		err = ib_cursor_close(ib_crsr);
		ut_a(err == DB_SUCCESS);
	}

	if (trunc_err == DB_SUCCESS) {
		ut_a(ib_trx_state(ib_trx) == IB_TRX_NOT_STARTED);

		err = ib_schema_unlock(ib_trx);
		ut_a(err == DB_SUCCESS);

		err = ib_trx_release(ib_trx);
		ut_a(err == DB_SUCCESS);
	} else {
		err = ib_trx_rollback(ib_trx);
		ut_a(err == DB_SUCCESS);
	}

	return(trunc_err);
}

/*****************************************************************//**
Get a table id. This function will acquire the dictionary mutex.
@return	DB_SUCCESS if found */

ib_err_t
ib_table_get_id(
/*============*/
	const char*	table_name,	/*!< in: table to find */
	ib_id_t*	table_id)	/*!< out: table id if found */
{
	ib_err_t	err;

	UT_DBG_ENTER_FUNC;

	dict_mutex_enter();

	err = ib_table_get_id_low(table_name, table_id);

	dict_mutex_exit();

	return(err);
}

/*****************************************************************//**
Get an index id.
@return	DB_SUCCESS if found */

ib_err_t
ib_index_get_id(
/*============*/
	const char*	table_name,	/*!< in: find index for this table */
	const char*	index_name,	/*!< in: index to find */
	ib_id_t*	index_id)	/*!< out: index id if found */
{
	dict_table_t*	table;
	char*		normalized_name;
	ib_err_t	err = DB_TABLE_NOT_FOUND;

	UT_DBG_ENTER_FUNC;

	*index_id = 0;

	normalized_name = mem_alloc(ut_strlen(table_name) + 1);
	ib_normalize_table_name(normalized_name, table_name);

	table = ib_lookup_table_by_name(normalized_name);

	mem_free(normalized_name);
	normalized_name = NULL;

	if (table != NULL) {
		dict_index_t*	index;

		index = dict_table_get_index_on_name(table, index_name);

		if (index != NULL) {
			/* We only support 32 bit table and index ids. Because
			we need to pack the table id into the index id. */
			ut_a(ut_dulint_get_high(table->id) == 0);
			ut_a(ut_dulint_get_high(index->id) == 0);

			*index_id = ut_dulint_get_low(table->id);
			*index_id <<= 32;
			*index_id |= ut_dulint_get_low(index->id);

			err = DB_SUCCESS;
		}
	}

	return(err);
}

/*********************************************************************//**
Create a database if it doesn't exist.
@return	IB_TRUE on success */

ib_bool_t
ib_database_create(
/*===============*/
	const char*	dbname)		/*!< in: database name to create */
{
	const char*	ptr;

	UT_DBG_ENTER_FUNC;

	for (ptr = dbname; *ptr; ++ptr) {
		if (*ptr == SRV_PATH_SEPARATOR) {
			return(IB_FALSE);
		}
	}

	/* Only necessary if file per table is set. */
	if (srv_file_per_table) {
		return(fil_mkdir(dbname));
	}

	return(IB_TRUE);
}

/*********************************************************************//**
Drop a database if it exists. Drop all tables in the database too.
@return	DB_SUCCESS or error code */

ib_err_t
ib_database_drop(
/*=============*/
	const char*	dbname)		/*!< in: database name to drop */
{
	ib_trx_t	ib_trx;
	char*		ptr = NULL;
	ib_err_t	err = DB_SUCCESS;
	ulint		len = ut_strlen(dbname);

	UT_DBG_ENTER_FUNC;

	if (len == 0) {
		return(DB_INVALID_INPUT);
	}

	ptr = (char*) mem_alloc(len + 2);
	memset(ptr, 0x0, len + 2);
	ut_strcpy(ptr, dbname);
#ifdef __WIN__
	ib_to_lower_case(ptr);
#endif /* __WIN__ */

	ib_trx = ib_trx_begin(IB_TRX_SERIALIZABLE);

	/* Drop all the tables in the database first. */
	/* ddl_drop_database() expects a string that ends in '/'. */
	if (ptr[len - 1] != '/') {
		ptr[len] = '/';
	}

	err = ddl_drop_database(ptr, (trx_t*) ib_trx);

	/* Only necessary if file per table is set. */
	if (err == DB_SUCCESS && srv_file_per_table) {
		fil_rmdir(ptr);
	}

	mem_free(ptr);

	if (err == DB_SUCCESS) {
		ib_err_t	trx_err;

		trx_err = ib_trx_commit(ib_trx);
		ut_a(trx_err == DB_SUCCESS);
	} else {
		ib_err_t	trx_err;

		trx_err = ib_trx_rollback(ib_trx);
		ut_a(trx_err == DB_SUCCESS);
	}

	return(err);
}

/*****************************************************************//**
Check if cursor is positioned.
@return	IB_TRUE if positioned */

ib_bool_t
ib_cursor_is_positioned(
/*====================*/
	const ib_crsr_t	ib_crsr)	/*!< in: InnoDB cursor instance */
{
	const ib_cursor_t*	cursor = (const ib_cursor_t*) ib_crsr;
	const row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	return(ib_btr_cursor_is_positioned(prebuilt->pcur));
}

/*****************************************************************//**
Latches the data dictionary in shared mode.
@return	DB_SUCCESS or error code */

ib_err_t
ib_schema_lock_shared(
/*==================*/
	ib_trx_t	ib_trx)		/*!< in/out: transaction */
{
	ib_err_t	err = DB_SUCCESS;
	trx_t*		trx = (trx_t*) ib_trx;

	if (trx->dict_operation_lock_mode == 0
	    || trx->dict_operation_lock_mode == RW_S_LATCH) {

		dict_freeze_data_dictionary((trx_t*) ib_trx);
	}

	return(err);
}

/*****************************************************************//**
Latches the data dictionary in exclusive mode.
@return	DB_SUCCESS or error code */

ib_err_t
ib_schema_lock_exclusive(
/*======================*/
	ib_trx_t	ib_trx)		/*!< in/out: transaction */
{
	ib_err_t	err = DB_SUCCESS;
	trx_t*		trx = (trx_t*) ib_trx;

	if (trx->dict_operation_lock_mode == 0
	    || trx->dict_operation_lock_mode == RW_X_LATCH) {

		dict_lock_data_dictionary((trx_t*) ib_trx);
	} else {
		err = DB_SCHEMA_NOT_LOCKED;
	}

	return(err);
}

/*****************************************************************//**
Checks if the data dictionary is latched in exclusive mode.
@return	TRUE if exclusive latch */

ib_bool_t
ib_schema_lock_is_exclusive(
/*========================*/
	const ib_trx_t	ib_trx)		/*!< in: transaction */
{
	const trx_t*	trx = (const trx_t*) ib_trx;

	return(trx->dict_operation_lock_mode == RW_X_LATCH);
}

/*****************************************************************//**
Checks if the data dictionary is latched in shared mode.
@return	TRUE if shared latch */

ib_bool_t
ib_schema_lock_is_shared(
/*=====================*/
	const ib_trx_t	ib_trx)		/*!< in: transaction */
{
	const trx_t*	trx = (const trx_t*) ib_trx;

	return(trx->dict_operation_lock_mode == RW_S_LATCH);
}

/*****************************************************************//**
Unlocks the data dictionary.
@return	DB_SUCCESS or error code */

ib_err_t
ib_schema_unlock(
/*=============*/
	ib_trx_t	ib_trx)		/*!< in/out: transaction */
{
	ib_err_t	err = DB_SUCCESS;
	trx_t*		trx = (trx_t*) ib_trx;

	if (trx->dict_operation_lock_mode == RW_X_LATCH) {
		dict_unlock_data_dictionary((trx_t*) ib_trx);
	} else if (trx->dict_operation_lock_mode == RW_S_LATCH) {
		dict_unfreeze_data_dictionary((trx_t*) ib_trx);
	} else {
		err = DB_SCHEMA_NOT_LOCKED;
	}

	return(err);
}

/*****************************************************************//**
Set the Lock an InnoDB cursor/table.
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_lock(
/*===========*/
	ib_crsr_t	ib_crsr,	/*!< in/out: InnoDB cursor */
	ib_lck_mode_t	ib_lck_mode)	/*!< in: InnoDB lock mode */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;
	trx_t*		trx = prebuilt->trx;
	dict_table_t*	table = prebuilt->table;

	return(ib_trx_lock_table_with_retry(
		trx, table, (enum lock_mode) ib_lck_mode));
}

/*****************************************************************//**
Set the Lock an InnoDB table using the table id.
@return	DB_SUCCESS or error code */

ib_err_t
ib_table_lock(
/*==========*/
	ib_trx_t	ib_trx,		/*!< in/out: transaction */
	ib_id_t		table_id,	/*!< in: table id */
	ib_lck_mode_t	ib_lck_mode)	/*!< in: InnoDB lock mode */
{
	ib_err_t	err;
	que_thr_t*	thr;
	mem_heap_t*	heap;
	dict_table_t*	table;
	ib_qry_proc_t	q_proc;
	trx_t*		trx = (trx_t*) ib_trx;

	UT_DBG_ENTER_FUNC;

	ut_a(trx->conc_state != TRX_NOT_STARTED);

	table = ib_open_table_by_id(table_id, FALSE);

	if (table == NULL) {
		return(DB_TABLE_NOT_FOUND);
	}

	ut_a(ib_lck_mode <= LOCK_NUM);

	heap = mem_heap_create(128);

	q_proc.node.sel = sel_node_create(heap);

	thr = pars_complete_graph_for_exec(q_proc.node.sel, trx, heap);

	q_proc.grph.sel = que_node_get_parent(thr);
	q_proc.grph.sel->state = QUE_FORK_ACTIVE;

	trx->op_info = "setting table lock";

	ut_a(ib_lck_mode == IB_LOCK_IS || ib_lck_mode == IB_LOCK_IX);
	err = lock_table(0, table, (enum lock_mode) ib_lck_mode, thr);

	trx->error_state = err;

	dict_table_decrement_handle_count(table, FALSE);

	mem_heap_free(heap);

	return(err);
}

/*****************************************************************//**
Unlock an InnoDB table.
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_unlock(
/*=============*/
	ib_crsr_t	ib_crsr)	/*!< in/out: InnoDB cursor */
{
	ib_err_t	err;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	if (prebuilt->trx->client_n_tables_locked > 0) {
		--prebuilt->trx->client_n_tables_locked;
	} else {
		err = DB_ERROR;
	}

	return(DB_SUCCESS);
}

/*****************************************************************//**
Set the Lock mode of the cursor.
@return	DB_SUCCESS or error code */

ib_err_t
ib_cursor_set_lock_mode(
/*====================*/
	ib_crsr_t	ib_crsr,	/*!< in/out: InnoDB cursor */
	ib_lck_mode_t	ib_lck_mode)	/*!< in: InnoDB lock mode */
{
	ib_err_t	err = DB_SUCCESS;
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	ut_a(ib_lck_mode <= LOCK_NUM);

	if (ib_lck_mode == IB_LOCK_X) {
		err = ib_cursor_lock(ib_crsr, IB_LOCK_IX);
	} else {
		err = ib_cursor_lock(ib_crsr, IB_LOCK_IS);
	}

	if (err == DB_SUCCESS) {
		prebuilt->select_lock_type = (enum lock_mode) ib_lck_mode;
		ut_a(prebuilt->trx->conc_state != TRX_NOT_STARTED);
	}

	return(err);
}

/*****************************************************************//**
Set need to access clustered index record. */

void
ib_cursor_set_cluster_access(
/*=========================*/
	ib_crsr_t	ib_crsr)	/*!< in/out: InnoDB cursor */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	prebuilt->need_to_access_clustered = TRUE;
}

/*****************************************************************//**
Set to true if it's a simple select. */

void
ib_cursor_set_simple_select(
/*=========================*/
	ib_crsr_t	ib_crsr)	/*!< in/out: InnoDB cursor */
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;
	row_prebuilt_t*	prebuilt = cursor->prebuilt;

	UT_DBG_ENTER_FUNC;

	prebuilt->simple_select = TRUE;
}

/*******************************************************************//**
Creates a named savepoint. The transaction must be started. If there is
already a savepoint of the same name, this call erases that old savepoint
and replaces it with a new. Savepoints are deleted in a transaction
commit or rollback. */

void
ib_savepoint_take(
/*==============*/
	ib_trx_t	ib_trx,		/*!< in: transaction */
	const void*	name,		/*!< in: savepoint name */
	ib_ulint_t	name_len)	/*!< in: length of name in bytes */
{
	trx_named_savept_t*	savep;
	trx_t*			trx = (trx_t*) ib_trx;

	ut_a(trx);
	ut_a(name != NULL);
	ut_a(name_len > 0);

	ut_a(trx->conc_state != TRX_NOT_STARTED);

	savep = UT_LIST_GET_FIRST(trx->trx_savepoints);

	/* Check if there is a savepoint with the same name already. */
	while (savep != NULL) {

		if (name_len == savep->name_len
		    && 0 == ut_memcmp(savep->name, name, name_len)) {
			break;
		}

		savep = UT_LIST_GET_NEXT(trx_savepoints, savep);
	}

	if (savep) {
		/* There is a savepoint with the same name: free that */
		UT_LIST_REMOVE(trx_savepoints, trx->trx_savepoints, savep);

		mem_free(savep);
	}

	/* Create a new savepoint and add it as the last in the list */
	savep = mem_alloc(sizeof(trx_named_savept_t) + name_len);

	savep->name = savep + 1;
	savep->savept = trx_savept_take(trx);

	savep->name_len = name_len;
	ut_memcpy(savep->name, name, name_len);

	UT_LIST_ADD_LAST(trx_savepoints, trx->trx_savepoints, savep);
}

/*******************************************************************//**
Releases only the named savepoint. Savepoints which were set after this
savepoint are left as is.
@return	if no savepoint of the name found then DB_NO_SAVEPOINT, otherwise DB_SUCCESS */

ib_err_t
ib_savepoint_release(
/*=================*/
	ib_trx_t	ib_trx,		/*!< in: transaction handle */
	const void*	name,		/*!< in: savepoint name */
	ib_ulint_t	name_len)	/*!< in: length of name in bytes */
{
	trx_named_savept_t*	savep;
	trx_t*			trx = (trx_t*) ib_trx;

	savep = UT_LIST_GET_FIRST(trx->trx_savepoints);

	/* Search for the savepoint by name and free if found. */
	while (savep != NULL) {

		if (name_len == savep->name_len
		    && 0 == ut_memcmp(savep->name, name, name_len)) {

			UT_LIST_REMOVE(trx_savepoints,
					trx->trx_savepoints, savep);
			mem_free(savep);

			return(DB_SUCCESS);
		}

		savep = UT_LIST_GET_NEXT(trx_savepoints, savep);
	}

	return(DB_NO_SAVEPOINT);
}

/*******************************************************************//**
Rolls back a transaction back to a named savepoint. Modifications after the
savepoint are undone but InnoDB does NOT release the corresponding locks
which are stored in memory. If a lock is 'implicit', that is, a new inserted
row holds a lock where the lock information is carried by the trx id stored in
the row, these locks are naturally released in the rollback. Savepoints which
were set after this savepoint are deleted. If name equals NULL then all the
savepoints are rolled back.
@return	if no savepoint of the name found then DB_NO_SAVEPOINT, otherwise DB_SUCCESS */

ib_err_t
ib_savepoint_rollback(
/*==================*/
	ib_trx_t	ib_trx,		/*!< in: transaction handle */
	const void*	name,		/*!< in: savepoint name  can be NULL */
	ib_ulint_t	name_len)	/*!< in: length of name in bytes */
{
	ib_err_t		err;
	trx_named_savept_t*	savep;
	trx_t*			trx = (trx_t*) ib_trx;

	if (trx->conc_state == TRX_NOT_STARTED) {
		ut_print_timestamp(ib_stream);
		ib_logger(ib_stream,
			"  InnoDB: Error: transaction trying to rollback a  "
			"savepoint ");
		ut_print_name(ib_stream, trx, FALSE, name);
		ib_logger(ib_stream, " though it is not started\n");

		return(DB_ERROR);
	}

	savep = UT_LIST_GET_FIRST(trx->trx_savepoints);

	if (name != NULL) {
		while (savep != NULL) {
			if (savep->name_len == name_len
			    && 0 == ut_memcmp(savep->name, name, name_len)) {

				/* Found */
				break;
			}
			savep = UT_LIST_GET_NEXT(trx_savepoints, savep);
		}
	}

	if (savep == NULL) {

		return(DB_NO_SAVEPOINT);
	}

	/* We can now free all savepoints strictly later than this one */
	trx_roll_savepoints_free(trx, savep);

	trx->op_info = "rollback to a savepoint";

	err = trx_general_rollback(trx, TRUE, &savep->savept);

	/* Store the current undo_no of the transaction so that we know where
	to roll back if we have to roll back the next SQL statement: */
	trx_mark_sql_stat_end(trx);

	trx->op_info = "";

	return(err);
}

/*****************************************************************//**
Convert from internal format to the the table definition table attributes */
UNIV_STATIC
void
ib_table_get_format(
/*================*/
	const dict_table_t*	table,	/*!< in: table definition */
	ib_tbl_fmt_t*		tbl_fmt,/*!< out: table format */
	ulint*			page_size)/*!< out: page size */
{
	UT_DBG_ENTER_FUNC;

	*page_size = 0;
	*tbl_fmt = IB_TBL_REDUNDANT;

	switch(table->flags) {
	case 0:
		break;
	case DICT_TF_COMPACT:		/* The compact row format */
		*tbl_fmt = IB_TBL_COMPACT;
		break;
	case DICT_TF_COMPACT | DICT_TF_FORMAT_ZIP << DICT_TF_FORMAT_SHIFT:
		*tbl_fmt = IB_TBL_DYNAMIC;
		break;
#if DICT_TF_FORMAT_MAX > DICT_TF_FORMAT_ZIP
# error "missing case labels for DICT_TF_FORMAT_ZIP .. DICT_TF_FORMAT_MAX"
#endif
	default:
		if (table->flags & DICT_TF_ZSSIZE_MASK) {
			*tbl_fmt = IB_TBL_COMPRESSED;

			*page_size = ((PAGE_ZIP_MIN_SIZE >> 1)
				<< ((table->flags & DICT_TF_ZSSIZE_MASK)
					>> DICT_TF_ZSSIZE_SHIFT));
		}
	}
}

/*****************************************************************//**
Call the visitor for each column in a table.
@return	return value from index_col */
UNIV_STATIC
int
ib_table_schema_visit_table_columns(
/*================================*/
	const dict_table_t*		table,	/*!< in: table to visit */
	ib_schema_visitor_table_col_t	table_col,
						/*!< in: table column visitor */
	void*				arg)	/*!< in: argument to visitor */
{
	ulint		i;

	for (i = 0; i < table->n_cols; ++i) {
		dict_col_t*	col;
		const char*	name;
		ib_col_attr_t	attr;
		ulint		col_no;
		int		user_err;

		col = dict_table_get_nth_col(table, i);
		col_no = dict_col_get_no(col);
		name = dict_table_get_col_name(table, col_no);
		attr = ib_col_get_attr(col->prtype);

		user_err = table_col(
			arg, name, col->mtype, col->len, attr);

		if (user_err) {
			return(user_err);
		}
	}

	return(0);
}

/*****************************************************************//**
Call the visitor for each column in an index.
@return	return value from index_col */
UNIV_STATIC
int
ib_table_schema_visit_index_columns(
/*================================*/
	const dict_index_t*		index,	/*!< in: index to visit */
	ib_schema_visitor_index_col_t	index_col,
						/*!< in: index column
						visitor */
	void*				arg)	/*!< in: argument to visitor */
{
	ulint	i;
	ulint	n_index_cols = index->n_user_defined_cols;

	for (i = 0; i < n_index_cols; ++i) {
		const dict_field_t*	dfield;
		int			user_err;

		dfield = &index->fields[i];

		user_err = index_col(arg, dfield->name, dfield->prefix_len);

		if (user_err) {
			return(user_err);
		}
	}

	return(0);
}

/*****************************************************************//**
Read a table's schema using the visitor pattern. It will make the
following sequence of calls:

	visitor->table()
	visitor->table_col() for each user column
	visitor->index() for each user index
	visitor->index_col() for each column in user index

It will stop if any of the above functions returns a non-zero value.
The caller must have an exclusive lock on the InnoDB data dictionary
@return	DB_SUCCESS or DB_ERROR */

ib_err_t
ib_table_schema_visit(
/*==================*/
	ib_trx_t			ib_trx,	/*!< in: transaction that
						owns the schema lock */
	const char*			name,	/*!< in: table name to read */
	const ib_schema_visitor_t*	visitor,/*!< in: visitor functions
						to invoke on each
						definition */
	void*				arg)	/*!< Argument passed to the
						visitor functions. */
{
	dict_index_t*	index;
	dict_table_t*	table;
	ib_tbl_fmt_t	tbl_fmt;
	ulint		page_size;
	int		n_indexes;
	int		user_err = 0;
	char*		normalized_name;

	UT_DBG_ENTER_FUNC;

	if (!ib_schema_lock_is_exclusive(ib_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	}

	normalized_name = mem_alloc(ut_strlen(name) + 1);
	ib_normalize_table_name(normalized_name, name);

	table = ib_lookup_table_by_name(normalized_name);

	mem_free(normalized_name);
	normalized_name = NULL;

	if (table != NULL) {
		dict_table_increment_handle_count(table, TRUE);
	}  else {
		return(DB_TABLE_NOT_FOUND);
	}

	ib_table_get_format(table, &tbl_fmt, &page_size);

	/* We need the count of user defined indexes only. */
	n_indexes = UT_LIST_GET_LEN(table->indexes);

	/* The first index is always the cluster index. */
	index = dict_table_get_first_index(table);

	/* Only the clustered index can be auto generated. */
	if (index->n_user_defined_cols == 0) {
		--n_indexes;
	}

	if (visitor->version < IB_SCHEMA_VISITOR_TABLE) {

		goto func_exit;

	} else if (visitor->table) {
		user_err = visitor->table(
			arg,
			table->name,
			tbl_fmt,
			page_size,
			table->n_cols,
			n_indexes);

		if (user_err) {
			goto func_exit;
		}
	}

	if (visitor->version < IB_SCHEMA_VISITOR_TABLE_COL) {

		goto func_exit;

	} else if (visitor->table_col) {
		user_err = ib_table_schema_visit_table_columns(
			table, visitor->table_col, arg);

		if (user_err) {
			goto func_exit;
		}
	}

	if (!visitor->index) {
		goto func_exit;
	} else if (visitor->version < IB_SCHEMA_VISITOR_TABLE_AND_INDEX) {
		goto func_exit;
	}

	/* Traverse the user defined indexes. */
	do {
		ulint		n_index_cols;

		n_index_cols = index->n_user_defined_cols;

		/* Ignore system generated indexes. */
		if (n_index_cols > 0) {
			user_err = visitor->index(
				arg,
				index->name,
				dict_index_is_unique(index) != 0,
				dict_index_is_clust(index) != 0,
				n_index_cols);
			if (user_err) {
				goto func_exit;
			}

			if (visitor->version
			    >= IB_SCHEMA_VISITOR_TABLE_AND_INDEX_COL
			    && visitor->index_col) {
				user_err = ib_table_schema_visit_index_columns(
					index, visitor->index_col, arg);

				if (user_err) {
					break;	
				}
			}
		}

		index = UT_LIST_GET_NEXT(indexes, index);
	} while (index != NULL);

func_exit:
	ut_a(ib_schema_lock_is_exclusive(ib_trx));
	dict_table_decrement_handle_count(table, TRUE);

	return(user_err != 0 ? DB_ERROR : DB_SUCCESS);
}

/*****************************************************************//**
List all the tables in the InnoDB's data dictionary. It will abort
if visitor returns a non-zero value.

It will call the function:
	visitor.tables(arg, const char* name, int name_len);

The function will abort if visitor.tables() returns non-zero. */

ib_err_t
ib_schema_tables_iterate(
/*=====================*/
	ib_trx_t		ib_trx,	/*!< in: transaction that
					owns the schema lock */
	ib_schema_visitor_table_all_t
				visitor,/*!< in: visitor function */
	void*			arg)	/*!< in: argument passed to the visitor
					function */
{
	ib_err_t	err;
	dict_table_t*	table;
	ib_crsr_t	ib_crsr;
	ib_err_t	crsr_err;
	ib_tpl_t	ib_tpl = NULL;

	if (!ib_schema_lock_is_exclusive(ib_trx)) {
		return(DB_SCHEMA_NOT_LOCKED);
	}

	table = ib_lookup_table_by_name("SYS_TABLES");

	if (table != NULL) {
		dict_table_increment_handle_count(table, TRUE);
		err = ib_create_cursor(&ib_crsr, table, 0, (trx_t*) ib_trx);
	} else {
		return(DB_TABLE_NOT_FOUND);
	}

	if (err == DB_SUCCESS) {
		err = ib_cursor_first(ib_crsr);
	}

	ib_tpl = ib_clust_read_tuple_create(ib_crsr);

	while (err == DB_SUCCESS) {
		const void*	ptr;
		ib_ulint_t	len;
		ib_col_meta_t	ib_col_meta;

		err = ib_cursor_read_row(ib_crsr, ib_tpl);

		if (err == DB_SUCCESS) {
			ptr = ib_col_get_value(ib_tpl, 0);
			/* Can't have NULL columns. */
			ut_a(ptr != NULL);

			len = ib_col_get_meta_low(ib_tpl, 0, &ib_col_meta);
			ut_a(len != UNIV_SQL_NULL);

			if (visitor(arg, (const char*) ptr, len)) {
				break;
			}

			err = ib_cursor_next(ib_crsr);
		}

	}

	ib_tuple_delete(ib_tpl);

	crsr_err = ib_cursor_close(ib_crsr);
	ut_a(crsr_err == DB_SUCCESS);

	if (err == DB_END_OF_INDEX) {
		err = DB_SUCCESS;
	}

	return(err);
}

/*************************************************************//**
Convert and write an INT column value to an InnoDB tuple.
@return	DB_SUCCESS or error */
UNIV_INLINE
ib_err_t
ib_tuple_write_int(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	ulint		col_no,		/*!< in: column number */
	const void*	value,		/*!< in: integer value */
	ulint		value_len)	/*!< in: sizeof value type */
{
	const dfield_t*	dfield;
	ulint		data_len;
	ulint		type_len;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	ut_a(col_no < ib_tuple_get_n_cols(ib_tpl));

	dfield = ib_col_get_dfield(tuple, col_no);

	data_len = dfield_get_len(dfield);
	type_len = dtype_get_len(dfield_get_type(dfield));

	if (dtype_get_mtype(dfield_get_type(dfield)) != DATA_INT
	    || value_len != data_len) {

		return(DB_DATA_MISMATCH);
	}

	return(ib_col_set_value(ib_tpl, col_no, value, type_len));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_i8(
/*==============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_i8_t		val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCESS or error */

ib_err_t
ib_tuple_write_i16(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_i16_t	val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_i32(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_i32_t	val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_i64(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_i64_t	val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_u8(
/*==============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_u8_t		val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_u16(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tupe to write to */
	int		col_no,		/*!< in: column number */
	ib_u16_t	val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_u32(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_u32_t	val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Write an integer value to a column. Integers are stored in big-endian
format and will need to be converted from the host format.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_u64(
/*===============*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	ib_u64_t	val)		/*!< in: value to write */
{
	return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
}

/*****************************************************************//**
Inform the cursor that it's the start of an SQL statement. */

void
ib_cursor_stmt_begin(
/*=================*/
	ib_crsr_t	ib_crsr)
{
	ib_cursor_t*	cursor = (ib_cursor_t*) ib_crsr;

	cursor->prebuilt->sql_stat_start = TRUE;
}

/*****************************************************************//**
Write a double value to a column.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_double(
/*==================*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	double		val)		/*!< in: value to write */
{
	const dfield_t*	dfield;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, col_no);

	if (dtype_get_mtype(dfield_get_type(dfield)) == DATA_DOUBLE) {
		return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
	} else {
		return(DB_DATA_MISMATCH);
	}
}

/*************************************************************//**
Read a double column value from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_double(
/*=================*/
	ib_tpl_t	ib_tpl,		/*!< in: InnoDB tuple */
	ib_ulint_t	col_no,		/*!< in: column number */
	double*		dval)		/*!< out: double value */
{
	ib_err_t	err;
	const dfield_t*	dfield;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, col_no);

	if (dtype_get_mtype(dfield_get_type(dfield)) == DATA_DOUBLE) {
		ib_col_copy_value_low(ib_tpl, col_no, dval, sizeof(*dval));
		err = DB_SUCCESS;
	} else {
		err = DB_DATA_MISMATCH;
	}

	return(err);
}

/*****************************************************************//**
Write a float value to a column.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_write_float(
/*=================*/
	ib_tpl_t	ib_tpl,		/*!< upd: tuple to write to */
	int		col_no,		/*!< in: column number */
	float		val)		/*!< in: value to write */
{
	const dfield_t*	dfield;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, col_no);

	if (dtype_get_mtype(dfield_get_type(dfield)) == DATA_FLOAT) {
		return(ib_col_set_value(ib_tpl, col_no, &val, sizeof(val)));
	} else {
		return(DB_DATA_MISMATCH);
	}
}

/*************************************************************//**
Read a float value from an InnoDB tuple.
@return	DB_SUCCESS or error */

ib_err_t
ib_tuple_read_float(
/*================*/
	ib_tpl_t	ib_tpl,		/*!< in: InnoDB tuple */
	ib_ulint_t	col_no,		/*!< in: column number */
	float*		fval)		/*!< out: float value */
{
	ib_err_t	err;
	const dfield_t*	dfield;
	ib_tuple_t*	tuple = (ib_tuple_t*) ib_tpl;

	UT_DBG_ENTER_FUNC;

	dfield = ib_col_get_dfield(tuple, col_no);

	if (dtype_get_mtype(dfield_get_type(dfield)) == DATA_FLOAT) {
		ib_col_copy_value_low(ib_tpl, col_no, fval, sizeof(*fval));
		err = DB_SUCCESS;
	} else {
		err = DB_DATA_MISMATCH;
	}

	return(err);
}

/*************************************************************//**
Set the message logging function. */

void
ib_logger_set(
/*==========*/
	ib_msg_log_t	ib_msg_log,	/*!< in: the logging function */
	ib_msg_stream_t	ib_msg_stream)	/*!< in: the message stream, this is
					the first argument to the logging
					function */
{
	ib_logger = (ib_logger_t) ib_msg_log;
	ib_stream = (ib_stream_t) ib_msg_stream;
}

/*************************************************************//**
Convert an error number to a human readable text message. The
returned string is static and should not be freed or modified.
@return	string, describing the error */

const char*
ib_strerror(
/*========*/
	ib_err_t	num)	/*!< in: error number */
{
	switch (num) {
	case DB_SUCCESS:
		return("Success");
	case DB_ERROR:
		return("Generic error");
	case DB_OUT_OF_MEMORY:
		return("Cannot allocate memory");
	case DB_OUT_OF_FILE_SPACE:
		return("Out of disk space");
	case DB_LOCK_WAIT:
		return("Lock wait");
	case DB_DEADLOCK:
		return("Deadlock");
	case DB_ROLLBACK:
		return("Rollback");
	case DB_DUPLICATE_KEY:
		return("Duplicate key");
	case DB_QUE_THR_SUSPENDED:
		return("The queue thread has been suspended");
	case DB_MISSING_HISTORY:
		return("Required history data has been deleted");
	case DB_CLUSTER_NOT_FOUND:
		return("Cluster not found");
	case DB_TABLE_NOT_FOUND:
		return("Table not found");
	case DB_MUST_GET_MORE_FILE_SPACE:
		return("More file space needed");
	case DB_TABLE_IS_BEING_USED:
		return("Table is being used");
	case DB_TOO_BIG_RECORD:
		return("Record too big");
	case DB_LOCK_WAIT_TIMEOUT:
		return("Lock wait timeout");
	case DB_NO_REFERENCED_ROW:
		return("Referenced key value not found");
	case DB_ROW_IS_REFERENCED:
		return("Row is referenced");
	case DB_CANNOT_ADD_CONSTRAINT:
		return("Cannot add constraint");
	case DB_CORRUPTION:
		return("Data structure corruption");
	case DB_COL_APPEARS_TWICE_IN_INDEX:
		return("Column appears twice in index");
	case DB_CANNOT_DROP_CONSTRAINT:
		return("Cannot drop constraint");
	case DB_NO_SAVEPOINT:
		return("No such savepoint");
	case DB_TABLESPACE_ALREADY_EXISTS:
		return("Tablespace already exists");
	case DB_TABLESPACE_DELETED:
		return("No such tablespace");
	case DB_LOCK_TABLE_FULL:
		return("Lock structs have exhausted the buffer pool");
	case DB_FOREIGN_DUPLICATE_KEY:
		return("Foreign key activated with duplicate keys");
	case DB_TOO_MANY_CONCURRENT_TRXS:
		return("Too many concurrent transactions");
	case DB_UNSUPPORTED:
		return("Unsupported");
	case DB_PRIMARY_KEY_IS_NULL:
		return("Primary key is NULL");
	case DB_FAIL:
		return("Failed, retry may succeed");
	case DB_OVERFLOW:
		return("Overflow");
	case DB_UNDERFLOW:
		return("Underflow");
	case DB_STRONG_FAIL:
		return("Failed, retry will not succeed");
	case DB_ZIP_OVERFLOW:
		return("Zip overflow");
	case DB_RECORD_NOT_FOUND:
		return("Record not found");
	case DB_END_OF_INDEX:
		return("End of index");
	case DB_SCHEMA_ERROR:
		return("Error while validating a table or index schema");
	case DB_DATA_MISMATCH:
		return("Type mismatch");
	case DB_SCHEMA_NOT_LOCKED:
		return("Schema not locked");
	case DB_NOT_FOUND:
		return("Not found");
	case DB_READONLY:
		return("Readonly");
	case DB_INVALID_INPUT:
		return("Invalid input");
	case DB_FATAL:
		return("InnoDB fatal error");
	case DB_INTERRUPTED:
		return("Operation interrupted");
	/* do not add default: in order to produce a warning if new code
	is added to the enum but not added here */
	}

	/* NOT REACHED */
	return("Unknown error");
}
/***********************************************************************
Copyright (c) 2008 Innobase Oy. All rights reserved.
Copyright (c) 2008 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/
#include <stdarg.h>

#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif

#include "univ.i"
#include "api0api.h"
#include "btr0sea.h"
#include "buf0buf.h" /* for buf_pool */
#include "buf0lru.h" /* for buf_LRU_* */
#include "db0err.h"
#include "log0recv.h"
#include "srv0srv.h"
#include "srv0start.h"
#include "trx0sys.h"	/* for trx_sys_file_format_name_to_id() */
#include "os0sync.h"

UNIV_STATIC	char*	srv_file_flush_method_str = NULL;

/* If set then we rollback the transaction on DB_LOCK_WAIT_TIMEOUT error. */
extern ibool	ses_rollback_on_timeout;

/* A point in the LRU list (expressed as a percent), all blocks from this
point onwards (inclusive) are considered "old" blocks. */
UNIV_STATIC ulint	lru_old_blocks_pct;

/** We copy the argument passed to ib_cfg_set_text("data_file_path")
because srv_parse_data_file_paths_and_sizes() parses it's input argument
destructively. The copy is done using ut_malloc(). */
UNIV_STATIC	char*	srv_data_file_paths_and_sizes = NULL;

/* enum ib_cfg_flag_t @{ */
typedef enum ib_cfg_flag {
	IB_CFG_FLAG_NONE = 0x1,
	IB_CFG_FLAG_READONLY_AFTER_STARTUP = 0x2,/* can be modified only
						 before innodb is started */
	IB_CFG_FLAG_READONLY = 0x4		/* cannot be modified */
} ib_cfg_flag_t;
/* @} */

/* struct ib_cfg_var_t @{ */
typedef struct ib_cfg_var {
	const char*	name;	/* config var name */
	ib_cfg_type_t	type;	/* config var type */
	ib_cfg_flag_t	flag;	/* config var flag */
	ib_uint64_t	min_val;/* minimum allowed value for numeric types,
				ignored for other types */
	ib_uint64_t	max_val;/* maximum allowed value for numeric types,
				ignored for other types */
	ib_err_t	(*validate)(const struct ib_cfg_var*, const void*); /*
				function used to validate a new variable's
				value when setting it */
	ib_err_t	(*set)(struct ib_cfg_var*, const void*); /* function
				used to set the variable's value */
	ib_err_t	(*get)(const struct ib_cfg_var*, void*); /* function
				used to get the variable's value */
	void*		tank;	/* opaque storage that may be used by the
				set() and get() functions */
} ib_cfg_var_t;
/* @} */

/*******************************************************************//**
@file api/api0cfg.c
Assign src to dst according to type. If this is a string variable (char*)
the string itself is not copied.
ib_cfg_assign() @{
@return	DB_SUCCESS if assigned (type is known) */
UNIV_STATIC
ib_err_t
ib_cfg_assign(
/*==========*/
	ib_cfg_type_t	type,	/*!< in: type of src and dst */
	void*		dst,	/*!< out: destination */
	const void*	src)	/*!< in: source */
{
	switch (type) {
	case IB_CFG_IBOOL: {

		*(ib_bool_t*) dst = *(const ib_bool_t*) src;
		return(DB_SUCCESS);
	}

	case IB_CFG_ULINT: {

		*(ulint*) dst = *(const ulint*) src;
		return(DB_SUCCESS);
	}

	case IB_CFG_ULONG: {

		*(ulong*) dst = *(const ulong*) src;
		return(DB_SUCCESS);
	}

	case IB_CFG_TEXT: {

		*(char**) dst = *(char**) src;
		return(DB_SUCCESS);
	}

	case IB_CFG_CB: {

		*(ib_cb_t*) dst = *(ib_cb_t*) src;
		return(DB_SUCCESS);
	}
	/* do not add default: in order to produce a compilation
	warning if new type is added which is not handled here */
	}

	/* NOT REACHED */
	return(DB_ERROR);
}
/* @} */

/*******************************************************************//**
A generic function used for ib_cfg_var_t::validate() to check a numeric
type for min/max allowed value overflow.
ib_cfg_var_validate_numeric() @{
@return	DB_SUCCESS if value is in range */
UNIV_STATIC
ib_err_t
ib_cfg_var_validate_numeric(
/*========================*/
	const struct ib_cfg_var* cfg_var,/*!< in/out: configuration variable to
					check */
	const void*		value)	/*!< in: value to check */
{
	switch (cfg_var->type) {

	case IB_CFG_ULINT: {
		ulint	v;

		v = *(ulint*) value;

		if ((ulint) cfg_var->min_val <= v
		    && v <= (ulint) cfg_var->max_val) {

			return(DB_SUCCESS);
		} else {

			return(DB_INVALID_INPUT);
		}
	}

	case IB_CFG_ULONG: {
		ulong	v;

		v = *(ulong*) value;

		if ((ulong) cfg_var->min_val <= v
		    && v <= (ulong) cfg_var->max_val) {

			return(DB_SUCCESS);
		} else {

			return(DB_INVALID_INPUT);
		}
	}

	default:
		ut_error;
	}

	/* NOT REACHED */
	return(DB_ERROR);
}
/* @} */

/* generic and specific ib_cfg_var_(set|get)_* functions @{ */

/*******************************************************************//**
A generic function used for ib_cfg_var_t::set() that stores the value
of the configuration parameter in the location pointed by
ib_cfg_var_t::tank. If this is a string variable (char*) then the string
is not copied and a reference to "value" is made. It should not be freed
or modified until InnoDB is running or a new value is set.
ib_cfg_var_set_generic() @{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_generic(
/*===================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate */
	const void*		value)	/*!< in: value to set */
{
	ib_err_t	ret;

	if (cfg_var->validate != NULL) {
		ret = cfg_var->validate(cfg_var, value);
		if (ret != DB_SUCCESS) {
			return(ret);
		}
	}

	ret = ib_cfg_assign(cfg_var->type, cfg_var->tank, value);

	return(ret);
}
/* @} */

/*******************************************************************//**
A generic function used for ib_cfg_var_t::get() that retrieves the value
of the configuration parameter from the location pointed by
ib_cfg_var_t::tank and stores it in "value". The variable is not copied
to "value" even if it is a string variable (char*). Only a pointer to the
storage is written in "value". It should not be freed unless it was
allocated by the user and set with ib_cfg_set().
ib_cfg_var_get_generic() @{
@return	DB_SUCCESS if retrieved successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_get_generic(
/*===================*/
	const struct ib_cfg_var*	cfg_var,/*!< in: configuration
						variable whose value to
						retrieve */
	void*				value)	/*!< out: place to store
						the retrieved value */
{
	return(ib_cfg_assign(cfg_var->type, value, cfg_var->tank));
}
/* @} */

/*******************************************************************//**
Set the value of the config variable "adaptive_hash_index".
ib_cfg_var_set_adaptive_hash_index() @{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_adaptive_hash_index(
/*===============================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate, must be
					"adaptive_hash_index" */
	const void*		value)	/*!< in: value to set, must point to
					ib_bool_t variable */
{
	ut_a(strcasecmp(cfg_var->name, "adaptive_hash_index") == 0);
	ut_a(cfg_var->type == IB_CFG_IBOOL);

	btr_search_enabled = !(*(const ib_bool_t*) value);

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Retrieve the value of the config variable "adaptive_hash_index".
ib_cfg_var_get_adaptive_hash_index() @{
@return	DB_SUCCESS if retrieved successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_get_adaptive_hash_index(
/*===============================*/
	const struct ib_cfg_var*	cfg_var,/*!< in: configuration
						variable whose value to
						retrieve, must be
						"adaptive_hash_index" */
	void*				value)	/*!< out: place to store
						the retrieved value, must
						point to ib_bool_t variable */
{
	ut_a(strcasecmp(cfg_var->name, "adaptive_hash_index") == 0);
	ut_a(cfg_var->type == IB_CFG_IBOOL);

	*(ib_bool_t*) value = !btr_search_enabled;

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Set the value of the config variable "data_file_path".
ib_cfg_var_set_data_file_path() @{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_data_file_path(
/*==========================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate, must be
					"data_file_path" */
	const void*		value)	/*!< in: value to set, must point to
					char* variable */
{
	const char*	value_str;

	ut_a(strcasecmp(cfg_var->name, "data_file_path") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	value_str = *(char**) value;

	if (srv_parse_data_file_paths_and_sizes(value_str)) {
		return(DB_SUCCESS);
	} else {
		return(DB_INVALID_INPUT);
	}
}
/* @} */

/*******************************************************************//**
Retrieve the value of the config variable "data_file_path".
ib_cfg_var_get_data_file_path() @{
@return	DB_SUCCESS if retrieved successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_get_data_file_path(
/*==========================*/
	const struct ib_cfg_var*	cfg_var,/*!< in: configuration
						variable whose value to
						retrieve, must be
						"data_file_path" */
	void*				value)	/*!< out: place to store
						the retrieved value, must
						point to char* variable */
{
	ut_a(strcasecmp(cfg_var->name, "data_file_path") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	*(char**) value = srv_data_file_paths_and_sizes;

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Set the value of the config variable "file_format".
ib_cfg_var_set_file_format() @{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_file_format(
/*=======================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate, must be "file_format" */
	const void*		value)	/*!< in: value to set, must point to
					char* variable */
{
	ulint		format_id;

	ut_a(strcasecmp(cfg_var->name, "file_format") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	format_id = trx_sys_file_format_name_to_id(*(char**) value);

	if (format_id > DICT_TF_FORMAT_MAX) {
		return(DB_INVALID_INPUT);
	}

	srv_file_format = format_id;

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Retrieve the value of the config variable "file_format".
ib_cfg_var_get_file_format @{
@return	DB_SUCCESS if retrieved successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_get_file_format(
/*=======================*/
	const struct ib_cfg_var*	cfg_var,/*!< in: configuration
						variable whose value to
						retrieve, must be
						"file_format" */
	void*				value)	/*!< out: place to store
						the retrieved value, must
						point to char* variable */
{
	ut_a(strcasecmp(cfg_var->name, "file_format") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	*(const char**) value = trx_sys_file_format_id_to_name(
		srv_file_format);

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Check the value of the config variable "data_home_dir". We need to ensure
that the value ends with a path separator.
ib_cfg_var_validate_data_home_dir() @{
@return	DB_SUCCESS if value is valid */
UNIV_STATIC
ib_err_t
ib_cfg_var_validate_data_home_dir(
/*==============================*/
	const struct ib_cfg_var*cfg_var,/*!< in/out: configuration variable to
					check, must be "data_home_dir" */
	const void*		value)	/*!< in: value to check, must point to
					char* variable */
{
	ulint		len;
	char*		value_str;

	ut_a(strcasecmp(cfg_var->name, "data_home_dir") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	value_str = *(char**) value;

	len = ut_strlen(value_str);

	/* We simply require that this variable end in a path separator.
	We will normalize it before use internally. */
	if (len == 0
	    || (value_str[len - 1] != '/' && value_str[len - 1] != '\\')) {

		return(DB_INVALID_INPUT);
	}

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Set the value of the config variable "log_group_home_dir".
ib_cfg_var_set_log_group_home_dir @{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_log_group_home_dir(
/*==============================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate, must be
					"log_group_home_dir" */
	const void*		value)	/*!< in: value to set, must point to
					char* variable */
{
	const char*	value_str;

	ut_a(strcasecmp(cfg_var->name, "log_group_home_dir") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	ut_a(srv_log_group_home_dir == NULL);

	value_str = *(char**) value;

	if (srv_parse_log_group_home_dirs(value_str)) {
		return(DB_SUCCESS);
	} else {
		return(DB_INVALID_INPUT);
	}
}
/* @} */

/*******************************************************************//**
Set the value of the config variable "flush_method".
ib_cfg_var_set_flush_method@{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_flush_method(
/*========================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate, must be
					"log_group_home_dir" */
	const void*		value)	/*!< in: value to set, must point to
					char* variable */
{
	const char*	value_str;
	ib_err_t	err = DB_SUCCESS;

	ut_a(strcasecmp(cfg_var->name, "flush_method") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	value_str = *(const char**) value;

	os_aio_use_native_aio = FALSE;

#ifndef __WIN__
	if (0 == ut_strcmp(value_str, "fsync")) {
		srv_unix_file_flush_method = SRV_UNIX_FSYNC;
	} else if (0 == ut_strcmp(value_str, "O_DSYNC")) {
		srv_unix_file_flush_method = SRV_UNIX_O_DSYNC;
	} else if (0 == ut_strcmp(value_str, "O_DIRECT")) {
		srv_unix_file_flush_method = SRV_UNIX_O_DIRECT;
	} else if (0 == ut_strcmp(value_str, "littlesync")) {
		srv_unix_file_flush_method = SRV_UNIX_LITTLESYNC;
	} else if (0 == ut_strcmp(value_str, "nosync")) {
		srv_unix_file_flush_method = SRV_UNIX_NOSYNC;
	} else {
		err = DB_INVALID_INPUT;
	}
#else
	if (0 == ut_strcmp(value_str, "normal")) {
		srv_win_file_flush_method = SRV_WIN_IO_NORMAL;
	} else if (0 == ut_strcmp(value_str, "unbuffered")) {
		srv_win_file_flush_method = SRV_WIN_IO_UNBUFFERED;
	} else if (0 == ut_strcmp(value_str, "async_unbuffered")) {
		srv_win_file_flush_method = SRV_WIN_IO_UNBUFFERED;
	} else {
		err = DB_INVALID_INPUT;
	}

	if (err == DB_SUCCESS) {
		switch (os_get_os_version()) {
		case OS_WIN95:
		case OS_WIN31:
		case OS_WINNT:
			/* On Win 95, 98, ME, Win32 subsystem for Windows
			3.1, and NT use simulated aio. In NT Windows provides
		       	async i/o, but when run in conjunction with InnoDB
		       	Hot Backup, it seemed to corrupt the data files. */
	
			os_aio_use_native_aio = FALSE;
			break;
		default:
			/* On Win 2000 and XP use async i/o */
			os_aio_use_native_aio = TRUE;
			break;
		}
	}
#endif

	if (err == DB_SUCCESS) {
		*(const char**) cfg_var->tank = value_str;
	} else {
		*(const char**) cfg_var->tank = NULL;
	}

	return(err);
}
/* @} */
/*******************************************************************//**
Retrieve the value of the config variable "log_group_home_dir".
ib_cfg_var_get_log_group_home_dir() @{
@return	DB_SUCCESS if retrieved successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_get_log_group_home_dir(
/*==============================*/
	const struct ib_cfg_var*	cfg_var,/*!< in: configuration
						variable whose value to
						retrieve, must be
						"log_group_home_dir" */
	void*				value)	/*!< out: place to store
						the retrieved value, must
						point to char* variable */
{
	ut_a(strcasecmp(cfg_var->name, "log_group_home_dir") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	*(const char**) value = NULL;

	return(DB_SUCCESS);
}
/* @} */

/*******************************************************************//**
Set the value of the config variable "lru_old_blocks_pct".
ib_cfg_var_set_lru_old_blocks_pct() @{
@return	DB_SUCCESS if set successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_set_lru_old_blocks_pct(
/*==============================*/
	struct ib_cfg_var*	cfg_var,/*!< in/out: configuration variable to
					manipulate, must be
					"lru_old_blocks_pct" */
	const void*		value)	/*!< in: value to set, must point to
					ulint variable */
{
	ibool	adjust_buf_pool;

	ut_a(strcasecmp(cfg_var->name, "lru_old_blocks_pct") == 0);
	ut_a(cfg_var->type == IB_CFG_ULINT);

	if (cfg_var->validate != NULL) {
		ib_err_t	ret;

		ret = cfg_var->validate(cfg_var, value);

		if (ret != DB_SUCCESS) {
			return(ret);
		}
	}

	if (buf_pool != NULL) {
		/* buffer pool has been created */
		adjust_buf_pool = TRUE;
	} else {
		/* buffer pool not yet created, do not attempt to modify it */
		adjust_buf_pool = FALSE;
	}

	lru_old_blocks_pct = buf_LRU_old_ratio_update(
		*(ulint*) value, adjust_buf_pool);

	return(DB_SUCCESS);
}
/* @} */

/* ib_cfg_var_get_generic() is used to get the value of lru_old_blocks_pct */

/* There is no ib_cfg_var_set_version() */

/*******************************************************************//**
Retrieve the value of the config variable "version".
ib_cfg_var_get_version() @{
@return	DB_SUCCESS if retrieved successfully */
UNIV_STATIC
ib_err_t
ib_cfg_var_get_version(
/*===================*/
	const struct ib_cfg_var*	cfg_var,/*!< in: configuration
						variable whose value to
						retrieve, must be
						"version" */
	void*				value)	/*!< out: place to store
						the retrieved value, must
						point to char* variable */
{
	ut_a(strcasecmp(cfg_var->name, "version") == 0);
	ut_a(cfg_var->type == IB_CFG_TEXT);

	*(const char**) value = INNODB_VERSION_STR;

	return(DB_SUCCESS);
}
/* @} */

/* @} */

/* cfg_vars_defaults[] @{ */
UNIV_STATIC const ib_cfg_var_t cfg_vars_defaults[] = {
	{STRUCT_FLD(name,	"adaptive_hash_index"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_adaptive_hash_index),
	 STRUCT_FLD(get,	ib_cfg_var_get_adaptive_hash_index),
	 STRUCT_FLD(tank,	NULL)},

	{STRUCT_FLD(name,	"adaptive_flushing"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_adaptive_flushing)},

	{STRUCT_FLD(name,	"additional_mem_pool_size"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	512 * 1024),
	 STRUCT_FLD(max_val,	IB_UINT64_T_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_mem_pool_size)},

	{STRUCT_FLD(name,	"autoextend_increment"),
	 STRUCT_FLD(type,	IB_CFG_ULONG),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	1),
	 STRUCT_FLD(max_val,	1000),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_auto_extend_increment)},

	{STRUCT_FLD(name,	"buffer_pool_size"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	5 * 1024 * 1024),
	 STRUCT_FLD(max_val,	ULINT_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_buf_pool_size)},

	{STRUCT_FLD(name,	"checksums"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_use_checksums)},

	{STRUCT_FLD(name,	"data_file_path"),
	 STRUCT_FLD(type,	IB_CFG_TEXT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_data_file_path),
	 STRUCT_FLD(get,	ib_cfg_var_get_data_file_path),
	 STRUCT_FLD(tank,	NULL)},

	{STRUCT_FLD(name,	"data_home_dir"),
	 STRUCT_FLD(type,	IB_CFG_TEXT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_data_home_dir),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_data_home)},

	{STRUCT_FLD(name,	"doublewrite"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_use_doublewrite_buf)},

	{STRUCT_FLD(name,	"file_format"),
	 STRUCT_FLD(type,	IB_CFG_TEXT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL /* validation is done inside
				     ib_cfg_var_set_file_format */),
	 STRUCT_FLD(set,	ib_cfg_var_set_file_format),
	 STRUCT_FLD(get,	ib_cfg_var_get_file_format),
	 STRUCT_FLD(tank,	NULL)},

	{STRUCT_FLD(name,	"file_io_threads"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	4),
	 STRUCT_FLD(max_val,	64),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_n_file_io_threads)},

	{STRUCT_FLD(name,	"file_per_table"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_file_per_table)},

	{STRUCT_FLD(name,	"flush_log_at_trx_commit"),
	 STRUCT_FLD(type,	IB_CFG_ULONG),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	2),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_flush_log_at_trx_commit)},

	{STRUCT_FLD(name,	"flush_method"),
	 STRUCT_FLD(type,	IB_CFG_TEXT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_flush_method),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_file_flush_method_str)},

	{STRUCT_FLD(name,	"force_recovery"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	IB_RECOVERY_DEFAULT),
	 STRUCT_FLD(max_val,	IB_RECOVERY_NO_LOG_REDO),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_force_recovery)},

	{STRUCT_FLD(name,	"io_capacity"),
	 STRUCT_FLD(type,	IB_CFG_ULONG),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	100),
	 STRUCT_FLD(max_val,	1000000),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_io_capacity)},

	{STRUCT_FLD(name,	"lock_wait_timeout"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	1),
	 STRUCT_FLD(max_val,	1024 * 1024 * 1024),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&ses_lock_wait_timeout)},

	{STRUCT_FLD(name,	"log_buffer_size"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	256 * 1024),
	 STRUCT_FLD(max_val,	IB_UINT64_T_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_log_buffer_size)},

	{STRUCT_FLD(name,	"log_file_size"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	1024 * 1024),
	 STRUCT_FLD(max_val,	ULINT_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_log_file_size)},

	{STRUCT_FLD(name,	"log_files_in_group"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	2),
	 STRUCT_FLD(max_val,	100),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_n_log_files)},

	{STRUCT_FLD(name,	"log_group_home_dir"),
	 STRUCT_FLD(type,	IB_CFG_TEXT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_log_group_home_dir),
	 STRUCT_FLD(get,	ib_cfg_var_get_log_group_home_dir),
	 STRUCT_FLD(tank,	NULL)},

	{STRUCT_FLD(name,	"max_dirty_pages_pct"),
	 STRUCT_FLD(type,	IB_CFG_ULONG),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	100),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_max_buf_pool_modified_pct)},

	{STRUCT_FLD(name,	"max_purge_lag"),
	 STRUCT_FLD(type,	IB_CFG_ULONG),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	IB_UINT64_T_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_max_purge_lag)},

	{STRUCT_FLD(name,	"lru_old_blocks_pct"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	5),
	 STRUCT_FLD(max_val,	95),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_lru_old_blocks_pct),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&lru_old_blocks_pct)},

	{STRUCT_FLD(name,	"lru_block_access_recency"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0xFFFFFFFFUL),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&buf_LRU_old_threshold_ms)},

	{STRUCT_FLD(name,	"open_files"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	10),
	 STRUCT_FLD(max_val,	IB_UINT64_T_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_max_n_open_files)},

	{STRUCT_FLD(name,	"read_io_threads"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	1),
	 STRUCT_FLD(max_val,	64),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_n_read_io_threads)},

	{STRUCT_FLD(name,	"write_io_threads"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY_AFTER_STARTUP),
	 STRUCT_FLD(min_val,	1),
	 STRUCT_FLD(max_val,	64),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_n_write_io_threads)},

	/* New, not present in InnoDB/MySQL */
	{STRUCT_FLD(name,	"pre_rollback_hook"),
	 STRUCT_FLD(type,	IB_CFG_CB),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&recv_pre_rollback_hook)},

	/* New, not present in InnoDB/MySQL */
	{STRUCT_FLD(name,	"print_verbose_log"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_print_verbose_log)},

	/* New, not present in InnoDB/MySQL */
	{STRUCT_FLD(name,	"rollback_on_timeout"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&ses_rollback_on_timeout)},

	{STRUCT_FLD(name,	"stats_sample_pages"),
	 STRUCT_FLD(type,	IB_CFG_ULINT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	1),
	 STRUCT_FLD(max_val,	ULINT_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_stats_sample_pages)},

	{STRUCT_FLD(name,	"status_file"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_innodb_status)},

	{STRUCT_FLD(name,	"sync_spin_loops"),
	 STRUCT_FLD(type,	IB_CFG_ULONG),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	IB_UINT64_T_MAX),
	 STRUCT_FLD(validate,	ib_cfg_var_validate_numeric),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_n_spin_wait_rounds)},

	{STRUCT_FLD(name,	"use_sys_malloc"),
	 STRUCT_FLD(type,	IB_CFG_IBOOL),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_NONE),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	ib_cfg_var_set_generic),
	 STRUCT_FLD(get,	ib_cfg_var_get_generic),
	 STRUCT_FLD(tank,	&srv_use_sys_malloc)},

	{STRUCT_FLD(name,	"version"),
	 STRUCT_FLD(type,	IB_CFG_TEXT),
	 STRUCT_FLD(flag,	IB_CFG_FLAG_READONLY),
	 STRUCT_FLD(min_val,	0),
	 STRUCT_FLD(max_val,	0),
	 STRUCT_FLD(validate,	NULL),
	 STRUCT_FLD(set,	NULL /* The ::set() function should never
				     be called because this variable is
				     flagged as IB_CFG_FLAG_READONLY */),
	 STRUCT_FLD(get,	ib_cfg_var_get_version),
	 STRUCT_FLD(tank,	NULL)},
};
/* @} */

/** This mutex has to work even if the InnoDB latching infrastructure
hasn't been initialized. */
UNIV_STATIC os_fast_mutex_t	cfg_vars_mutex;
UNIV_STATIC ib_cfg_var_t	cfg_vars[UT_ARR_SIZE(cfg_vars_defaults)];

/* public API functions and some auxiliary ones @{ */

/*********************************************************************//**
Lookup a variable name.
ib_cfg_lookup_var() @{
@return	config variable instance if found else NULL */
UNIV_STATIC
ib_cfg_var_t*
ib_cfg_lookup_var(
/*==============*/
	const char*	var)		/*!< in: variable name */
{
	ulint		i;

	for (i = 0; i < UT_ARR_SIZE(cfg_vars); ++i) {
		ib_cfg_var_t*	cfg_var;

		cfg_var = &cfg_vars[i];

		if (strcasecmp(var, cfg_var->name) == 0) {
			return(cfg_var);
		}
	}

	return(NULL);
}
/* @} */

/*********************************************************************//**
Get the type of a configuration variable. Returns DB_SUCCESS if the
variable with name "name" was found and "type" was set.
ib_cfg_var_get_type() @{
@return	DB_SUCCESS if successful */

ib_err_t
ib_cfg_var_get_type(
/*================*/
	const char*	name,		/*!< in: variable name */
	ib_cfg_type_t*	type)		/*!< out: variable type */
{
	ib_cfg_var_t*	cfg_var;
	ib_err_t	ret;

	os_fast_mutex_lock(&cfg_vars_mutex);

	cfg_var = ib_cfg_lookup_var(name);

	if (cfg_var != NULL) {
		*type = cfg_var->type;
		ret = DB_SUCCESS;
	} else {
		ret = DB_NOT_FOUND;
	}

	os_fast_mutex_unlock(&cfg_vars_mutex);

	return(ret);
}
/* @} */

/*********************************************************************//**
Set a configuration variable. "ap" must contain one argument whose type
depends on the type of the variable with the given "name". Returns
DB_SUCCESS if the variable with name "name" was found and if its value
was set.
ib_cfg_set_ap() @{
@return	DB_SUCCESS if set */
UNIV_STATIC
ib_err_t
ib_cfg_set_ap(
/*==========*/
	const char*	name,		/*!< in: variable name */
	va_list		ap)		/*!< in: variable value */
{
	ib_cfg_var_t*	cfg_var;
	ib_err_t	ret = DB_NOT_FOUND;

	os_fast_mutex_lock(&cfg_vars_mutex);

	cfg_var = ib_cfg_lookup_var(name);

	if (cfg_var != NULL) {

		/* check whether setting the variable is appropriate,
		according to its flag */
		if (cfg_var->flag & IB_CFG_FLAG_READONLY
		    || (cfg_var->flag & IB_CFG_FLAG_READONLY_AFTER_STARTUP
			&& srv_was_started)) {

			ret = DB_READONLY;
		} else {

			/* Get the parameter according to its type and
			call ::set() */
			switch (cfg_var->type) {
			case IB_CFG_IBOOL: {
				ib_bool_t	value;

				value = va_arg(ap, ib_bool_t);

				ret = cfg_var->set(cfg_var, &value);

				break;
			}

			case IB_CFG_ULINT: {
				ulint	value;

				value = va_arg(ap, ulint);

				ret = cfg_var->set(cfg_var, &value);

				break;
			}

			case IB_CFG_ULONG: {
				ulong	value;

				value = va_arg(ap, ulong);

				ret = cfg_var->set(cfg_var, &value);

				break;
			}

			case IB_CFG_TEXT: {
				const char*	value;

				value = va_arg(ap, const char*);

				ret = cfg_var->set(cfg_var, &value);

				break;
			}

			case IB_CFG_CB: {
				ib_cb_t	value;

				value = va_arg(ap, ib_cb_t);

				ret = cfg_var->set(cfg_var, &value);

				break;
			}
			/* do not add default: in order to produce a
			compilation warning if new type is added which is
			not handled here */
			}
		}
	}
	
	os_fast_mutex_unlock(&cfg_vars_mutex);

	return(ret);
}
/* @} */

/*********************************************************************//**
Set a configuration variable. The second argument's type depends on the
type of the variable with the given "name". Returns DB_SUCCESS if the
variable with name "name" was found and if its value was set. Strings
are not copied, be sure not to destroy or modify your string after it
has been given to this function. Memory management is left to the caller.
E.g. if you malloc() a string and give it to this function and then
malloc() another string and give it again to this function for the same
config variable, then you are responsible to free the first string.
ib_cfg_set() @{
@return	DB_SUCCESS if set */

ib_err_t
ib_cfg_set(
/*=======*/
	const char*	name,		/*!< in: variable name */
	...)				/*!< in: variable value */
{
	va_list		ap;
	ib_bool_t	ret;

	va_start(ap, name);

	ret = ib_cfg_set_ap(name, ap);

	va_end(ap);

	return(ret);
}
/* @} */

/*********************************************************************//**
Get the value of a configuration variable. The type of the returned value
depends on the type of the configuration variable. DB_SUCCESS is returned
if the variable with name "name" was found and "value" was set. Strings
are not copied and a reference to the internal storage is returned. Be
sure not to modify the returned value or you may confuse InnoDB or cause
a crash.
ib_cfg_get() @{
@return	DB_SUCCESS if retrieved successfully */

ib_err_t
ib_cfg_get(
/*=======*/
	const char*	name,		/*!< in: variable name */
	void*		value)		/*!< out: pointer to the place to
					store the retrieved value */
{
	ib_cfg_var_t*	cfg_var;
	ib_err_t	ret;

	os_fast_mutex_lock(&cfg_vars_mutex);

	cfg_var = ib_cfg_lookup_var(name);

	if (cfg_var != NULL) {
		ret = cfg_var->get(cfg_var, value);
	} else {
		ret = DB_NOT_FOUND;
	}

	os_fast_mutex_unlock(&cfg_vars_mutex);

	return(ret);
}
/* @} */

/*********************************************************************//**
Get a list of the names of all configuration variables.
The caller is responsible for free(3)ing the returned array of strings
when it is not needed anymore and for not modifying the individual strings.
ib_cfg_get_all() @{
@return	DB_SUCCESS or error code */

ib_err_t
ib_cfg_get_all(
/*===========*/
	const char***	names,		/*!< out: pointer to array of strings */
	ib_u32_t*	names_num)	/*!< out: number of strings returned */
{
	ib_u32_t	i;

	*names_num = UT_ARR_SIZE(cfg_vars_defaults);

	*names = (const char**) malloc(*names_num * sizeof(const char*));
	if (*names == NULL) {
		return(DB_OUT_OF_MEMORY);
	}

	for (i = 0; i < *names_num; i++) {
		(*names)[i] = cfg_vars_defaults[i].name;
	}

	return(DB_SUCCESS);
}
/* @} */

/*********************************************************************//**
Initialize the config system.
ib_cfg_init() @{
@return	DB_SUCCESS or error code */

ib_err_t
ib_cfg_init(void)
/*=============*/
{
       fprintf(stderr, "ib_cfg_init: start\n");
       /* Initialize the mutex that protects cfg_vars[]. */
       os_fast_mutex_init(&cfg_vars_mutex);

	ut_memcpy(cfg_vars, cfg_vars_defaults, sizeof(cfg_vars));

	/* Set the default options. */
	srv_file_flush_method_str = NULL;
	srv_unix_file_flush_method = SRV_UNIX_FSYNC;
	srv_win_file_flush_method = SRV_WIN_IO_UNBUFFERED;

	os_aio_print_debug = FALSE;
	os_aio_use_native_aio = FALSE;

#define IB_CFG_SET(name, var)	\
	if (ib_cfg_set(name, var) != DB_SUCCESS) ut_error

	IB_CFG_SET("additional_mem_pool_size", 4 * 1024 * 1024);
	IB_CFG_SET("buffer_pool_size", 8 * 1024 * 1024);
	IB_CFG_SET("data_file_path", "ibdata1:32M:autoextend");
	IB_CFG_SET("data_home_dir", "./");
	IB_CFG_SET("file_io_threads", 4);
	IB_CFG_SET("file_per_table", IB_TRUE);
#ifndef __WIN__
	IB_CFG_SET("flush_method", "fsync");
#endif
	IB_CFG_SET("lock_wait_timeout", 60);
	IB_CFG_SET("log_buffer_size", 384 * 1024);
	IB_CFG_SET("log_file_size", 16 * 1024 * 1024);
	IB_CFG_SET("log_files_in_group", 2);
	IB_CFG_SET("log_group_home_dir", ".");
	IB_CFG_SET("lru_old_blocks_pct", 3 * 100 / 8);
	IB_CFG_SET("lru_block_access_recency", 0);
	IB_CFG_SET("rollback_on_timeout", IB_TRUE);
	IB_CFG_SET("read_io_threads", 4);
       IB_CFG_SET("write_io_threads", 4);
#undef IB_CFG_SET

       fprintf(stderr, "ib_cfg_init: configuration defaults set\n");

       return(DB_SUCCESS);
}
/* @} */

/*********************************************************************//**
Shutdown the config system.
ib_cfg_shutdown() @{
@return	DB_SUCCESS or error code */

ib_err_t
ib_cfg_shutdown(void)
/*=================*/
{
	os_fast_mutex_lock(&cfg_vars_mutex);

	/* TODO: Check for NULL values of allocated config variables. */
	memset(cfg_vars, 0x0, sizeof(cfg_vars));

	os_fast_mutex_unlock(&cfg_vars_mutex);

	os_fast_mutex_free(&cfg_vars_mutex);

	return(DB_SUCCESS);
}
/* @} */

/* @} */

/* vim: set foldmethod=marker foldmarker=@{,@}: */
/***********************************************************************
Copyright (c) 2008 Innobase Oy. All rights reserved.
Copyright (c) 2008 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/
#include "ib0config.h"

#include <errno.h>

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* HAVE_UNISTD_H */

#include "univ.i"
#include "api0misc.h"
#include "trx0roll.h"
#include "srv0srv.h"
#include "dict0mem.h"
#include "dict0dict.h"
#include "pars0pars.h"
#include "row0sel.h"
#include "lock0lock.h"

/* If set then we rollback the transaction on DB_LOCK_WAIT_TIMEOUT error. */
 ibool	ses_rollback_on_timeout	= FALSE;

#ifdef __WIN__

#include <io.h>

/* Required for mapping file system errors */
void __cdecl _dosmaperr(unsigned long);

/* The length was chosen arbitrarily and should be generous. */
#define WIN_MAX_PATH	512

/******************************************************************//**
@file api/api0misc.c
Create a temporary file in Windows.
@return	file descriptor, or -1 */
UNIV_STATIC
int
ib_win_create_tempfile(
/*===================*/
	const char*	prefix)		/*!< in: temp file prefix */
{
	ulint		ret;
	HANDLE		handle;
	TCHAR		path[WIN_MAX_PATH];
	TCHAR		tempname[WIN_MAX_PATH];

	int		fh = -1;

	ret = GetTempPath(sizeof(path), path);

	if (ret > sizeof(path) || ret == 0) {
		_dosmaperr(GetLastError());
	} else if (!GetTempFileName(path, prefix, 0, tempname)) {
		_dosmaperr(GetLastError());
	} else {
		/* Create the actual file with the relevant attributes. */
		handle = CreateFile(
			tempname,
			GENERIC_READ | GENERIC_WRITE | DELETE,
			FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			NULL,
			CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL
			| FILE_FLAG_DELETE_ON_CLOSE
			| FILE_ATTRIBUTE_TEMPORARY
			| FILE_FLAG_SEQUENTIAL_SCAN,
			NULL);

		if (handle == INVALID_HANDLE_VALUE) {
			_dosmaperr(GetLastError());
		} else {
			do {
				DWORD	oserr;

				fh = _open_osfhandle((intptr_t) handle, 0);

				/* We need to map the Windows OS error
				number (if any) to errno. */
				oserr = GetLastError();
				if (oserr) {
					_dosmaperr(oserr);
				}
			} while (fh == -1 && errno == EINTR);

			if (fh == -1) {
				_dosmaperr(GetLastError());
				CloseHandle(handle);
			}
		}
	}

	return(fh);
}
#endif

/******************************************************************//**
Create a temporary file. FIXME: This is a Q&D solution. */

int
ib_create_tempfile(
/*===============*/
	const char*	prefix)		/*!< in: temp filename prefix */
{
	int		fh = -1;

#ifdef __WIN__
	fh = ib_win_create_tempfile(prefix);
#else
	FILE*		file;

	file = tmpfile();

	if (file != NULL) {
		fh = dup(fileno(file));
		fclose(file);
	}
#endif

	return(fh);
}

/**********************************************************************//**
Determines if the currently running transaction has been interrupted.
@return	TRUE if interrupted */

ibool
trx_is_interrupted(
/*===============*/
	const trx_t*	trx)		/*!< in: transaction */
{
	/* FIXME: Call the appropriate user function. */
	return(FALSE);
}

/****************************************************************//**
Handles user errors and lock waits detected by the database engine.
@return	TRUE if it was a lock wait and we should continue running the query thread */

ibool
ib_handle_errors(
/*=============*/
	enum db_err*	new_err,/*!< out: possible new error encountered in
				lock wait, or if no new error, the value
				of trx->error_state at the entry of this
				function */
	trx_t*		trx,	/*!< in: transaction */
	que_thr_t*	thr,	/*!< in: query thread */
	trx_savept_t*	savept)	/*!< in: savepoint or NULL */
{
	enum db_err	err;

handle_new_error:
	err = trx->error_state;

	ut_a(err != DB_SUCCESS);

	trx->error_state = DB_SUCCESS;

	switch (err) {
	case DB_LOCK_WAIT_TIMEOUT:
		if (ses_rollback_on_timeout) {
			trx_general_rollback(trx, FALSE, NULL);
			break;
		}
		/* fall through */
	case DB_DUPLICATE_KEY:
	case DB_FOREIGN_DUPLICATE_KEY:
	case DB_TOO_BIG_RECORD:
	case DB_ROW_IS_REFERENCED:
	case DB_NO_REFERENCED_ROW:
	case DB_CANNOT_ADD_CONSTRAINT:
	case DB_TOO_MANY_CONCURRENT_TRXS:
	case DB_OUT_OF_FILE_SPACE:
		if (savept) {
			/* Roll back the latest, possibly incomplete
			insertion or update */

			trx_general_rollback(trx, TRUE, savept);
		}
		break;
	case DB_LOCK_WAIT:
		srv_suspend_user_thread(thr);

		if (trx->error_state != DB_SUCCESS) {
			que_thr_stop_client(thr);

			goto handle_new_error;
		}

		*new_err = err;

		return(TRUE); /* Operation needs to be retried. */

	case DB_DEADLOCK:
	case DB_LOCK_TABLE_FULL:
		/* Roll back the whole transaction; this resolution was added
		to version 3.23.43 */

		trx_general_rollback(trx, FALSE, NULL);
		break;

	case DB_MUST_GET_MORE_FILE_SPACE:
		ib_logger(ib_stream,
		      "InnoDB: The database cannot continue"
		      " operation because of\n"
		      "InnoDB: lack of space. You must add"
		      " a new data file\n"
		      "InnoDB: and restart the database.\n");

		exit(1);

	case DB_CORRUPTION:
		ib_logger(ib_stream,
		      "InnoDB: We detected index corruption"
		      " in an InnoDB type table.\n"
		      "InnoDB: You have to dump + drop + reimport"
		      " the table or, in\n"
		      "InnoDB: a case of widespread corruption,"
		      " dump all InnoDB\n"
		      "InnoDB: tables and recreate the"
		      " whole InnoDB tablespace.\n"
		      "InnoDB: If the server crashes"
		      " after the startup or when\n"
		      "InnoDB: you dump the tables, check the \n"
		      "InnoDB: InnoDB website for help.\n");
		break;
	default:
		ib_logger(ib_stream, "InnoDB: unknown error code %lu\n",
			(ulong) err);
		ut_error;
	}

	if (trx->error_state != DB_SUCCESS) {
		*new_err = trx->error_state;
	} else {
		*new_err = err;
	}

	trx->error_state = DB_SUCCESS;

	return(FALSE);
}

/*********************************************************************//**
Sets a lock on a table.
@return	error code or DB_SUCCESS */

enum db_err
ib_trx_lock_table_with_retry(
/*=========================*/
	trx_t*		trx,		/*!< in/out: transaction */
	dict_table_t*	table,		/*!< in: table to lock */
	enum lock_mode	mode)		/*!< in: LOCK_X or LOCK_S */
{
	que_thr_t*	thr;
	enum db_err	err;
	mem_heap_t*	heap;
	sel_node_t*	node;

	ut_ad(trx->client_thread_id == os_thread_get_curr_id());

	heap = mem_heap_create(512);

	trx->op_info = "setting table lock";

	node = sel_node_create(heap);
	thr = pars_complete_graph_for_exec(node, trx, heap);
	thr->graph->state = QUE_FORK_ACTIVE;

	/* We use the select query graph as the dummy graph needed
	in the lock module call */

	thr = que_fork_get_first_thr(que_node_get_parent(thr));
	que_thr_move_to_run_state(thr);

run_again:
	thr->run_node = thr;
	thr->prev_node = thr->common.parent;

	err = lock_table(0, table, mode, thr);

	trx->error_state = err;

	if (UNIV_LIKELY(err == DB_SUCCESS)) {
		que_thr_stop_for_client_no_error(thr, trx);
	} else {
		que_thr_stop_client(thr);

		if (err != DB_QUE_THR_SUSPENDED) {
			ibool	was_lock_wait;

			was_lock_wait = ib_handle_errors(&err, trx, thr, NULL);

			if (was_lock_wait) {
				goto run_again;
			}
		} else {
			que_thr_t*	run_thr;
			que_node_t*	parent;

			parent = que_node_get_parent(thr);
			run_thr = que_fork_start_command(parent);

			ut_a(run_thr == thr);

			/* There was a lock wait but the thread was not
			in a ready to run or running state. */
			trx->error_state = DB_LOCK_WAIT;

			goto run_again;
		}
	}

	que_graph_free(thr->graph);
	trx->op_info = "";

	return(err);
}

/*********************************************************************//**
Updates the table modification counter and calculates new estimates
for table and index statistics if necessary. */

void
ib_update_statistics_if_needed(
/*===========================*/
	dict_table_t*	table)	/*!< in/out: table */
{
	ulint	counter;

	counter = table->stat_modified_counter++;

	/* Calculate new statistics if 1 / 16 of table has been modified
	since the last time a statistics batch was run, or if
	stat_modified_counter > 2 000 000 000 (to avoid wrap-around).
	We calculate statistics at most every 16th round, since we may have
	a counter table which is very small and updated very often. */

	if (counter > 2000000000
	    || ((ib_int64_t)counter > 16 + table->stat_n_rows / 16)) {

		dict_update_statistics(table);
	}
}
/***********************************************************************
Copyright (c) 2009 Innobase Oy. All rights reserved.
Copyright (c) 2009 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "ib0config.h"

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#include "dict0dict.h"
#include "pars0pars.h"
#include "que0que.h"
#include "trx0roll.h"
#include "api0api.h"

UNIV_STATIC int				api_sql_enter_func_enabled = 0;
#define UT_DBG_ENTER_FUNC_ENABLED	api_sql_enter_func_enabled

/*********************************************************************//**
Function to parse ib_exec_sql() and ib_exec_ddl_sql() args.
@return	own: info struct */
UNIV_STATIC
pars_info_t*
ib_exec_vsql(
/*=========*/
	const char*	sql,		/*!< in: sql to execute */
	int		n_args,		/*!< in: no. of args */
	va_list		ap)		/*!< in: arg list */
{
	int		i;
	pars_info_t*    info;

	UT_DBG_ENTER_FUNC;

	info = pars_info_create();

	for (i = 0; i < n_args; ++i) {
		ib_col_type_t   type;

		type = va_arg(ap, ib_col_type_t);

		switch (type) {
		case IB_CHAR:
		case IB_VARCHAR: {
			const char*     n;
			const char*     v;
			char		prefix;

			n = va_arg(ap, const char *);
			v = va_arg(ap, const char *);

			prefix = *n;
			ut_a(prefix == ':' || prefix == '$');
			++n;

			if (prefix == '$') {
				pars_info_add_id(info, n, v);
			} else {
				pars_info_add_str_literal(info, n, v);
			}
			break;
		}
		case IB_INT: {
			byte*		p;	/* dest buffer */
			ulint		l;	/* length */
			ulint		s;	/* TRUE if signed integer */
			const char*     n;	/* literal name */
			ulint		prtype;

			l = va_arg(ap, ib_ulint_t);
			s = va_arg(ap, ib_ulint_t);
			n = va_arg(ap, const char *);

			prtype = s ? 0 : DATA_UNSIGNED;
			p = mem_heap_alloc(info->heap, l);

			switch (l) {
			case 1: {
				byte	v;

				v = va_arg(ap, int);
				mach_write_int_type(p, (byte*)&v, l, s);
				break;
			}
			case 2: {
				ib_uint16_t     v;

				v = va_arg(ap, int);
				mach_write_int_type(p, (byte*)&v, l, s);
				break;
			}
			case 4: {
				ib_uint32_t     v;

				v = va_arg(ap, ib_uint32_t);
				mach_write_int_type(p, (byte*)&v, l, s);
				break;
			}
			case 8: {
				ib_uint64_t     v;

				v = va_arg(ap, ib_uint64_t);
				mach_write_int_type(p, (byte*)&v, l, s);
				break;
			}
			default:
				ut_error;
			}
			pars_info_add_literal(info, n, p, l, DATA_INT, prtype);
			break;
		}
		case IB_SYS: {
			const char*             n;
			pars_user_func_cb_t     f;
			void*                   a;

			n = va_arg(ap, const char *);
			f = va_arg(ap, pars_user_func_cb_t);
			a = va_arg(ap, void*);
			pars_info_add_function(info, n, f, a);
			break;
		}
		default:
			/* FIXME: Do the other types too */
			ut_error;
		}
	}

	return(info);
}

/*********************************************************************//**
Execute arbitrary SQL using InnoDB's internal parser. The statement
is executed in a new transaction. Table name parameters must be prefixed
with a '$' symbol and variables with ':'
@return	DB_SUCCESS or error code */

ib_err_t
ib_exec_sql(
/*========*/
	const char*     sql,            /*!< in: sql to execute */
	ib_ulint_t	n_args,         /*!< in: no. of args */
	...)
{
	va_list         ap;
	trx_t*          trx;
	ib_err_t	err;
	pars_info_t*    info;

	UT_DBG_ENTER_FUNC;

	va_start(ap, n_args);

	info = ib_exec_vsql(sql, n_args, ap);

	va_end(ap);

	/* We use the private SQL parser of Innobase to generate
	the query graphs needed to execute the SQL statement. */

	trx = trx_allocate_for_client(NULL);
	err = trx_start(trx, ULINT_UNDEFINED);
	ut_a(err == DB_SUCCESS);
	trx->op_info = "exec client sql";

	dict_mutex_enter();
	/* Note that we've already acquired the dictionary mutex. */
	err = que_eval_sql(info, sql, FALSE, trx);
	ut_a(err == DB_SUCCESS);
	dict_mutex_exit();

	if (err != DB_SUCCESS) {
		trx_rollback(trx, FALSE, NULL);
	} else {
		trx_commit(trx);
	}

	trx->op_info = "";
	trx_free_for_client(trx);

	return(err);
}

/*********************************************************************//**
Execute arbitrary SQL using InnoDB's internal parser. The statement
is executed in a background transaction. It will lock the data
dictionary lock for the duration of the query.
@return	DB_SUCCESS or error code */

ib_err_t
ib_exec_ddl_sql(
/*============*/
	const char*	sql,		/*!< in: sql to execute */
	ib_ulint_t	n_args,		/*!< in: no. of args */
	...)
{
	va_list         ap;
	trx_t*          trx;
	ib_err_t	err;
	pars_info_t*    info;
	int		started;

	UT_DBG_ENTER_FUNC;

	va_start(ap, n_args);

	info = ib_exec_vsql(sql, n_args, ap);

	va_end(ap);

	/* We use the private SQL parser of Innobase to generate
	the query graphs needed to execute the SQL statement. */

	trx = trx_allocate_for_background();
	started = trx_start(trx, ULINT_UNDEFINED);
	ut_a(started);
	trx->op_info = "exec client ddl sql";

	err = ib_schema_lock_exclusive((ib_trx_t) trx);
	ut_a(err == DB_SUCCESS);

	/* Note that we've already acquired the dictionary mutex by
	setting reserve_dict_mutex to FALSE. */
	err = que_eval_sql(info, sql, FALSE, trx);
	ut_a(err == DB_SUCCESS);

	ib_schema_unlock((ib_trx_t) trx);

	if (err != DB_SUCCESS) {
		trx_rollback(trx, FALSE, NULL);
	} else {
		trx_commit(trx);
	}

	trx->op_info = "";
	trx_free_for_background(trx);

	return(err);
}

/***********************************************************************
Copyright (c) 2009 Innobase Oy. All rights reserved.
Copyright (c) 2009 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/

#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif

#include "univ.i"
#include "srv0srv.h"
#include "api0api.h"
#include "api0ucode.h"

/** InnoDB status variables types. */
typedef enum {
	IB_STATUS_IBOOL,		/*!< Boolean status variable, ibool */
	IB_STATUS_I64,			/*!< ib_int64_t status variable */
	IB_STATUS_ULINT			/*!< uling status variable */
} ib_status_type_t;

/** InnoDB status variables */
typedef struct {
	const char*		name;	/*!< Status variable name */

	ib_status_type_t	type;	/*!< Status varable type */

	const void*		val;	/*!< Pointer to status value */
} ib_status_t;

/* All status variables that a user can query. */
UNIV_STATIC const ib_status_t status_vars[] = {
	/* IO system related */
	{"read_req_pending",		IB_STATUS_ULINT,
		&export_vars.innodb_data_pending_reads},

	{"write_req_pending",		IB_STATUS_ULINT,
		&export_vars.innodb_data_pending_writes},

	{"fsync_req_pending",		IB_STATUS_ULINT,
		&export_vars.innodb_data_pending_fsyncs},

	{"write_req_done",		IB_STATUS_ULINT,
		&export_vars.innodb_data_writes},

	{"read_req_done",		IB_STATUS_ULINT,
		&export_vars.innodb_data_reads},

	{"fsync_req_done",		IB_STATUS_ULINT,
		&export_vars.innodb_data_fsyncs},

	{"bytes_total_written",		IB_STATUS_ULINT,
		&export_vars.innodb_data_written},

	{"bytes_total_read",		IB_STATUS_ULINT,
		&export_vars.innodb_data_read},


	/* Buffer pool related */
	{"buffer_pool_current_size",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_pages_total},

	{"buffer_pool_data_pages",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_pages_data},

	{"buffer_pool_dirty_pages",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_pages_dirty},

	{"buffer_pool_misc_pages",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_pages_misc},

	{"buffer_pool_free_pages",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_pages_free},

	{"buffer_pool_read_reqs",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_read_requests},

	{"buffer_pool_reads",		IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_reads},

	{"buffer_pool_waited_for_free",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_wait_free},

	{"buffer_pool_pages_flushed",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_pages_flushed},

	{"buffer_pool_write_reqs",	IB_STATUS_ULINT,
		&export_vars.innodb_buffer_pool_write_requests},

	{"buffer_pool_total_pages",	IB_STATUS_ULINT,
		&export_vars.innodb_pages_created},

	{"buffer_pool_pages_read",	IB_STATUS_ULINT,
		&export_vars.innodb_pages_read},

	{"buffer_pool_pages_written",	IB_STATUS_ULINT,
		&export_vars.innodb_pages_written},


	/* Double write buffer related */
	{"double_write_pages_written",	IB_STATUS_ULINT,
		&export_vars.innodb_dblwr_pages_written},

	{"double_write_invoked",	IB_STATUS_ULINT,
		&export_vars.innodb_dblwr_writes},


	/* Log related */
	{"log_buffer_slot_waits",	IB_STATUS_ULINT,
		&export_vars.innodb_log_waits},

	{"log_write_reqs",		IB_STATUS_ULINT,
		&export_vars.innodb_log_write_requests},

	{"log_write_flush_count",	IB_STATUS_ULINT,
		&export_vars.innodb_log_writes},

	{"log_bytes_written",		IB_STATUS_ULINT,
		&export_vars.innodb_os_log_written},

	{"log_fsync_req_done",		IB_STATUS_ULINT,
		&export_vars.innodb_os_log_fsyncs},

	{"log_write_req_pending",	IB_STATUS_ULINT,
		&export_vars.innodb_os_log_pending_writes},

	{"log_fsync_req_pending",	IB_STATUS_ULINT,
		&export_vars.innodb_os_log_pending_fsyncs},


	/* Lock related */
	{"lock_row_waits",		IB_STATUS_ULINT,
		&export_vars.innodb_row_lock_waits},

	{"lock_row_waiting",		IB_STATUS_ULINT,
		&export_vars.innodb_row_lock_current_waits},

	{"lock_total_wait_time_in_secs",IB_STATUS_ULINT,
		&export_vars.innodb_row_lock_time},

	{"lock_wait_time_avg_in_secs",	IB_STATUS_ULINT,
		&export_vars.innodb_row_lock_time_avg},

	{"lock_max_wait_time_in_secs",IB_STATUS_ULINT,
		&export_vars.innodb_row_lock_time_max},


	/* Row operations */
	{"row_total_read",		IB_STATUS_ULINT,
		&export_vars.innodb_rows_read},
	{"row_total_inserted",		IB_STATUS_ULINT,
		&export_vars.innodb_rows_inserted},
	{"row_total_updated",		IB_STATUS_ULINT,
		&export_vars.innodb_rows_updated},
	{"row_total_deleted",		IB_STATUS_ULINT,
		&export_vars.innodb_rows_deleted},

	/* Miscellaneous */
	{"page_size",			IB_STATUS_ULINT,
		&export_vars.innodb_page_size},

	{"have_atomic_builtins",	IB_STATUS_IBOOL,
		&export_vars.innodb_have_atomic_builtins},

	{ NULL, 0, 0}};

/*******************************************************************//*
Get the status variable that matches name.

@return DB_SUCCESS if found else DB_NOT_FOUND */
UNIV_STATIC
ib_err_t
ib_status_lookup(
/*=============*/
	const char*	name,		/*!< in: Variable to lookup */
	const ib_status_t** var)	/*!< out: pointer to entry */
{
	const ib_status_t*	ptr;

	*var = NULL;

	for (ptr = status_vars; ptr && ptr->name != NULL; ++ptr) {
		if (ib_utf8_strcasecmp(name, ptr->name) == 0) {
			*var = ptr;
			return(DB_SUCCESS);
		}
	}

	return(DB_NOT_FOUND);
}

/*******************************************************************//**
Get the value of an INT status variable.
@file api/api0status.c

@return	DB_SUCCESS if found and type is INT,
	DB_DATA_MISMATCH if found but type is not INT,
	DB_NOT_FOUND otherwise. */

ib_err_t
ib_status_get_i64(
/*==============*/
	const char*	name,		/*!< in: Status variable name */
	ib_i64_t*	dst)		/*!< out: Variable value */
{
	ib_err_t	err;
	const ib_status_t*	var;

	err = ib_status_lookup(name, &var);

	if (err == DB_SUCCESS) {

		/* Read the latest values into export_vars. */
		srv_export_innodb_status();

		switch (var->type) {
		case IB_STATUS_ULINT:
			*dst = *(ulint*) var->val;
			break;

		case IB_STATUS_IBOOL:
			*dst = *(ibool*) var->val;
			break;

		case IB_STATUS_I64:
			*dst = *(ib_int64_t*) var->val;
			break;

		default:
			/* Currently the status variables are all INTs. If
			we add other types then this will signal to the user
			that the variable type is different. */	
			err = DB_DATA_MISMATCH;
			break;
		}
	}

	return(err);
}

/***********************************************************************
Copyright (c) 2008 Innobase Oy. All rights reserved.
Copyright (c) 2008 Oracle. All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

************************************************************************/
#include <ctype.h>
#ifdef HAVE_STRINGS_H
#include <strings.h>
#endif

#include "univ.i"
#include "ut0mem.h"
#include "api0ucode.h"

/**********************************************************************//**
@file api/api0ucode.c
Determines the connection character set.
@return	connection character set */
UNIV_INTERN
const charset_t*
ib_ucode_get_connection_charset(void)
/*========-========================*/
{
	return(NULL);
}

/**********************************************************************//**
Determines the character set based on id.
FIXME: If the id can't be found then what do we do, return some default ?
@return	character set or NULL */
UNIV_INTERN
const charset_t*
ib_ucode_get_charset(
/*=================*/
	ulint		id)		/*!< in: Charset-collation code */
{
	return(NULL);
}

/******************************************************************//**
Get the variable length bounds of the given (multibyte) character set. */
UNIV_INTERN
void
ib_ucode_get_charset_width(
/*=======================*/
	const charset_t*cs,		/*!< in: Charset */
	ulint*		mbminlen,	/*!< out: min len of a char (in bytes) */
	ulint*		mbmaxlen)	/*!< out: max len of a char (in bytes) */
{
        *mbminlen = *mbmaxlen = 0;

        if (cs) {
		//FIXME
                //*mbminlen = charset_get_minlen(cs);
                //*mbmaxlen = charset_get_maxlen(cs);
	}
}

/******************************************************************//**
Compare two strings ignoring case.
@return	0 if equal */

int
ib_utf8_strcasecmp(
/*================*/
	const char*	p1,		/*!< in: string to compare */
	const char*	p2)		/*!< in: string to compare */
{
	/* FIXME: Call the UTF-8 comparison function. */
	/* FIXME: This should take cs as the parameter. */
	return(strcasecmp(p1, p2));
}

/******************************************************************//**
Compare two strings ignoring case.
@return	0 if equal */

int
ib_utf8_strncasecmp(
/*=================*/
	const char*	p1,		/*!< in: string to compare */
	const char*	p2,		/*!< in: string to compare */
	ulint		len)		/*!< in: length of string */
{
	/* FIXME: Call the UTF-8 comparison function. */
	/* FIXME: This should take cs as the parameter. */
	/* FIXME: Which function?  Note that this is locale-dependent.
	For example, there is a capital dotted i and a lower-case
	dotless I (U+0130 and U+0131, respectively).  In many other
	locales, I=i but not in Turkish. */
	return(strncasecmp(p1, p2, len));
}

/******************************************************************//**
Makes all characters in a NUL-terminated UTF-8 string lower case. */
UNIV_INTERN
void
ib_utf8_casedown(
/*=============*/
	char*		a)		/*!< in/out: str to put in lower case */
{
	/* FIXME: Call the UTF-8 tolower() equivalent. */
	/* FIXME: Is this function really needed?  The proper
	implementation is locale-dependent.  In Turkish, the
	lower-case counterpart of the upper-case I (U+0049, one byte)
	is the dotless i (U+0131, two bytes in UTF-8).  That cannot
	even be converted in place. */
	while (*a) {
		*a = tolower(*a);
		++a;
	}
}

/******************************************************************//**
Converts an identifier to a table name. */
UNIV_INTERN
void
ib_utf8_convert_from_table_id(
/*==========================*/
	const charset_t*cs,		/*!< in: the 'from' character set */
	char*		to,		/*!< out: converted identifier */
	const char*	from,		/*!< in: identifier to convert */
	ulint		len)		/*!< in: length of 'to', in bytes;
					should be at least
					5 * strlen(to) + 1 */
{
	/* FIXME: why 5*strlen(to)+1?  That is a relic from the MySQL
	5.1 filename safe encoding that encodes some chars in
	four-digit hexadecimal notation, such as @0023.  Do we even
	need this function?  Could the files be named by table id or
	something? */
	/* FIXME: Call the UTF-8 equivalent */
	strncpy(to, from, len);
}


/******************************************************************//**
Converts an identifier to UTF-8. */
UNIV_INTERN
void
ib_utf8_convert_from_id(
/*=====================*/
	const charset_t*cs,		/*!< in: the 'from' character set */
	char*		to,		/*!< out: converted identifier */
	const char*	from,		/*!< in: identifier to convert */
	ulint		len)		/*!< in: length of 'to', in bytes;
					should be at least
					3 * strlen(to) + 1 */
{
	/* FIXME: why 3*strlen(to)+1?  I suppose that it comes from
	MySQL, where the connection charset can be 8-bit, such as
	the "latin1" (really Windows Code Page 1252).  Converting
	that to UTF-8 can take 1..3 characters per byte. */
	/* FIXME: Do we even need this function?  Can't we just assume
	that the connection character encoding always is UTF-8?  (We
	may still want to support different collations for UTF-8.) */
	/* FIXME: Call the UTF-8 equivalent */
	strncpy(to, from, len);
}

/**********************************************************************//**
Test whether a UTF-8 character is a space or not.
@return	TRUE if isspace(c) */
UNIV_INTERN
int
ib_utf8_isspace(
/*============*/
	const charset_t*cs,		/*!< in: charset */
	char		c)		/*!< in: character to test */
{
	/* FIXME: Call the equivalent UTF-8 function. */
	/* FIXME: Do we really need this function?  This is needed by
	the InnoDB foreign key parser in MySQL, because U+00A0 is a
	space in the MySQL connection charset latin1 but not in
	utf8. */
	return(isspace(c));
}

/******************************************************************//**
This function is used to find the storage length in bytes of the
characters that will fit into prefix_len bytes.
@return	number of bytes required to copy the characters that will fit into prefix_len bytes. */
UNIV_INTERN
ulint
ib_ucode_get_storage_size(
/*======================*/
	const charset_t*cs,		/*!< in: character set */
	ulint		prefix_len,	/*!< in: prefix length in bytes */
	ulint		str_len,	/*!< in: length of the string in bytes */
	const char*	str)		/*!< in: character string */
{
	/* FIXME: Do we really need this function?  Can't we assume
	that all strings are UTF-8?  (We still may want to support
	different collations.) */
	return(ut_min(prefix_len, str_len));
}
/******************************************************
Implemention of Innobase DDL operations.

(c) 2008 Oracle Corpn/Innobase Oy

Created 12 Oct 2008.
*******************************************************/

#include "srv0srv.h"
#include "api0misc.h"
#include "trx0roll.h"
#include "dict0crea.h"
#include "dict0boot.h"
#include "dict0load.h"
#include "log0log.h"
#include "lock0lock.h"
#include "btr0pcur.h"
#include "ddl0ddl.h"
#include "pars0pars.h"
#include "ut0lst.h"

/* List of tables we should drop in background. ALTER TABLE requires
that the table handler can drop the table in background when there are no
queries to it any more. Protected by the kernel mutex. */
typedef struct ddl_drop_struct	ddl_drop_t;
struct ddl_drop_struct{
	char*				table_name;
	UT_LIST_NODE_T(ddl_drop_t)	ddl_drop_list;
};

UNIV_STATIC UT_LIST_BASE_NODE_T(ddl_drop_t)	ddl_drop_list;
UNIV_STATIC ibool	ddl_drop_list_inited	= FALSE;

/* Magic table names for invoking various monitor threads */
UNIV_STATIC const char S_innodb_monitor[] = "innodb_monitor";
UNIV_STATIC const char S_innodb_lock_monitor[] = "innodb_lock_monitor";
UNIV_STATIC const char S_innodb_tablespace_monitor[] = "innodb_tablespace_monitor";
UNIV_STATIC const char S_innodb_table_monitor[] = "innodb_table_monitor";
UNIV_STATIC const char S_innodb_mem_validate[] = "innodb_mem_validate";

/*************************************************************************
Drops a table as a background operation.  On Unix in ALTER TABLE the table
handler does not remove the table before all handles to it has been removed.
Furhermore, the call to the drop table must be non-blocking. Therefore
we do the drop table as a background operation, which is taken care of by
the master thread in srv0srv.c.
@return	error code or DB_SUCCESS */
UNIV_STATIC
ulint
ddl_drop_table_in_background(
/*=========================*/
	const char*	name)	/*!< in: table name */
{
	trx_t*	trx;
	ulint	error;
	ibool	started;

	trx = trx_allocate_for_background();

	started = trx_start(trx, ULINT_UNDEFINED);
	ut_a(started);

	/* If the original transaction was dropping a table referenced by
	foreign keys, we must set the following to be able to drop the
	table: */

	trx->check_foreigns = FALSE;

#if 0
	ib_logger(ib_stream, "InnoDB: Info: Dropping table ");
	ut_print_name(ib_stream, trx, TRUE, name);
	ib_logger(ib_stream, " from background drop list\n"); 
#endif

	/* Try to drop the table in InnoDB */

	dict_lock_data_dictionary(trx);

	error = ddl_drop_table(name, trx, FALSE);

	trx_commit(trx);

	dict_unlock_data_dictionary(trx);

	log_buffer_flush_to_disk();

	trx_free_for_background(trx);

	return(error);
}

/*************************************************************************
The master thread in srv0srv.c calls this regularly to drop tables which
we must drop in background after queries to them have ended. Such lazy
dropping of tables is needed in ALTER TABLE on Unix.
@return	how many tables dropped + remaining tables in list */
UNIV_INTERN
ulint
ddl_drop_tables_in_background(void)
/*===============================*/
{
	ddl_drop_t*		drop;
	dict_table_t*		table;
	ulint			n_tables;
	ulint			n_tables_dropped = 0;
loop:
	mutex_enter(&kernel_mutex);

	if (!ddl_drop_list_inited) {

		UT_LIST_INIT(ddl_drop_list);
		ddl_drop_list_inited = TRUE;
	}

	drop = UT_LIST_GET_FIRST(ddl_drop_list);

	n_tables = UT_LIST_GET_LEN(ddl_drop_list);

	mutex_exit(&kernel_mutex);

	if (drop == NULL) {
		/* All tables dropped */

		return(n_tables + n_tables_dropped);
	}

	mutex_enter(&(dict_sys->mutex));
	table = dict_table_get_low(drop->table_name);
	mutex_exit(&(dict_sys->mutex));

	if (table == NULL) {
		/* If for some reason the table has already been dropped
		through some other mechanism, do not try to drop it */

		goto already_dropped;
	}

	if (DB_SUCCESS != ddl_drop_table_in_background(drop->table_name)) {
		/* If the DROP fails for some table, we return, and let the
		main thread retry later */

		return(n_tables + n_tables_dropped);
	}

	n_tables_dropped++;

already_dropped:
	mutex_enter(&kernel_mutex);

	UT_LIST_REMOVE(ddl_drop_list, ddl_drop_list, drop);

	ut_print_timestamp(ib_stream);
	ib_logger(ib_stream, "  InnoDB: Dropped table ");
	ut_print_name(ib_stream, NULL, TRUE, drop->table_name);
	ib_logger(ib_stream, " in background drop queue.\n");

	mem_free(drop->table_name);

	mem_free(drop);

	mutex_exit(&kernel_mutex);

	goto loop;
}

/*************************************************************************
Get the background drop list length. NOTE: the caller must own the kernel
mutex!
@return	how many tables in list */
UNIV_INTERN
ulint
ddl_get_background_drop_list_len_low(void)
/*======================================*/
{
	ut_ad(mutex_own(&kernel_mutex));

	if (!ddl_drop_list_inited) {

		UT_LIST_INIT(ddl_drop_list);
		ddl_drop_list_inited = TRUE;
	}

	return(UT_LIST_GET_LEN(ddl_drop_list));
}

/*************************************************************************
If a table is not yet in the drop list, adds the table to the list of tables
which the master thread drops in background. We need this on Unix because in
ALTER TABLE may call drop table even if the table has running queries on
it. Also, if there are running foreign key checks on the table, we drop the
table lazily.
@return	TRUE if the table was not yet in the drop list, and was added there */
UNIV_STATIC
ibool
ddl_add_table_to_background_drop_list(
/*==================================*/
	const char*	name)	/*!< in: table name */
{
	ddl_drop_t*	drop;

	mutex_enter(&kernel_mutex);

	if (!ddl_drop_list_inited) {

		UT_LIST_INIT(ddl_drop_list);
		ddl_drop_list_inited = TRUE;
	}

	/* Look if the table already is in the drop list */
	drop = UT_LIST_GET_FIRST(ddl_drop_list);

	while (drop != NULL) {
		if (strcmp(drop->table_name, name) == 0) {
			/* Already in the list */

			mutex_exit(&kernel_mutex);

			return(FALSE);
		}

		drop = UT_LIST_GET_NEXT(ddl_drop_list, drop);
	}

	drop = mem_alloc(sizeof(ddl_drop_t));

	drop->table_name = mem_strdup(name);

	UT_LIST_ADD_LAST(ddl_drop_list, ddl_drop_list, drop);

	/*	ib_logger(ib_stream, "InnoDB: Adding table ");
	ut_print_name(ib_stream, trx, TRUE, drop->table_name);
	ib_logger(ib_stream, " to background drop list\n"); */

	mutex_exit(&kernel_mutex);

	return(TRUE);
}

/*************************************************************************
Drops a table but does not commit the transaction.  If the
name of the dropped table ends in one of "innodb_monitor",
"innodb_lock_monitor", "innodb_tablespace_monitor",
"innodb_table_monitor", then this will also stop the printing of
monitor output by the master thread.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_drop_table(
/*===========*/
	const char*	name,	/*!< in: table name */
	trx_t*		trx,	/*!< in: transaction handle */
	ibool		drop_db)/*!< in: TRUE=dropping whole database */
{
	dict_foreign_t*	foreign;
	dict_table_t*	table;
	ulint		space_id;
	enum db_err	err;
	const char*	table_name;
	ulint		namelen;
	pars_info_t*    info			= NULL;

	ut_a(name != NULL);

	if (srv_created_new_raw) {
		ib_logger(ib_stream,
		      "InnoDB: A new raw disk partition was initialized:\n"
		      "InnoDB: we do not allow database modifications"
		      " by the user.\n"
		      "InnoDB: Shut down the server and edit your config file "
		      "so that newraw is replaced with raw.\n");

		return(DB_ERROR);
	}

	trx->op_info = "dropping table";

	/* The table name is prefixed with the database name and a '/'.
	Certain table names starting with 'innodb_' have their special
	meaning regardless of the database name.  Thus, we need to
	ignore the database name prefix in the comparisons. */
	table_name = strchr(name, '/');
	ut_a(table_name);
	table_name++;
	namelen = strlen(table_name) + 1;

	if (namelen == sizeof S_innodb_monitor
	    && !memcmp(table_name, S_innodb_monitor,
		       sizeof S_innodb_monitor)) {

		/* Table name equals "innodb_monitor":
		stop monitor prints */

		srv_print_innodb_monitor = FALSE;
		srv_print_innodb_lock_monitor = FALSE;
	} else if (namelen == sizeof S_innodb_lock_monitor
		   && !memcmp(table_name, S_innodb_lock_monitor,
			      sizeof S_innodb_lock_monitor)) {
		srv_print_innodb_monitor = FALSE;
		srv_print_innodb_lock_monitor = FALSE;
	} else if (namelen == sizeof S_innodb_tablespace_monitor
		   && !memcmp(table_name, S_innodb_tablespace_monitor,
			      sizeof S_innodb_tablespace_monitor)) {

		srv_print_innodb_tablespace_monitor = FALSE;
	} else if (namelen == sizeof S_innodb_table_monitor
		   && !memcmp(table_name, S_innodb_table_monitor,
			      sizeof S_innodb_table_monitor)) {

		srv_print_innodb_table_monitor = FALSE;
	}

	/* Serialize data dictionary operations with dictionary mutex:
	no deadlocks can occur then in these operations */

	if (trx->dict_operation_lock_mode != RW_X_LATCH) {
		return(DB_SCHEMA_NOT_LOCKED);
	}

	ut_ad(mutex_own(&(dict_sys->mutex)));
#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&dict_operation_lock, RW_LOCK_EX));
#endif /* UNIV_SYNC_DEBUG */

	table = dict_table_get_low(name);

	if (!table) {
		err = DB_TABLE_NOT_FOUND;
		ut_print_timestamp(ib_stream);

		ib_logger(ib_stream,
		      "  InnoDB: Error: table ");
		ut_print_name(ib_stream, trx, TRUE, name);
		ib_logger(ib_stream,
		      " does not exist in the InnoDB internal\n"
		      "InnoDB: data dictionary though the client is"
		      " trying to drop it.\n"
		      "InnoDB: You can look for further help on the\n"
		      "InnoDB: InnoDB website. Check the site for details\n");
		goto func_exit;
	}

	/* Check if the table is referenced by foreign key constraints from
	some other table (not the table itself) */

	foreign = UT_LIST_GET_FIRST(table->referenced_list);

	while (foreign && foreign->foreign_table == table) {
check_next_foreign:
		foreign = UT_LIST_GET_NEXT(referenced_list, foreign);
	}

	if (foreign && trx->check_foreigns
	    && !(drop_db && dict_tables_have_same_db(
			 name, foreign->foreign_table_name))) {
		/* We only allow dropping a referenced table if
		FOREIGN_KEY_CHECKS is set to 0 */

		err = DB_CANNOT_DROP_CONSTRAINT;

		mutex_enter(&dict_foreign_err_mutex);
		ut_print_timestamp(ib_stream);

		ib_logger(ib_stream, "  Cannot drop table ");
		ut_print_name(ib_stream, trx, TRUE, name);
		ib_logger(ib_stream, "\nbecause it is referenced by ");
		ut_print_name(ib_stream,
			trx, TRUE, foreign->foreign_table_name);
		ib_logger(ib_stream, "\n");
		mutex_exit(&dict_foreign_err_mutex);

		goto func_exit;
	}

	if (foreign && trx->check_foreigns) {
		goto check_next_foreign;
	}

	if (table->n_handles_opened > 0) {
		ibool	added;

		added = ddl_add_table_to_background_drop_list(table->name);

		if (added) {
			ut_print_timestamp(ib_stream);
			ib_logger(ib_stream,
				"  InnoDB: Warning: Client is"
				" trying to drop table (%lu) ",
				(ulint) table->id.low);
			ut_print_name(ib_stream, trx, TRUE, table->name);
			ib_logger(ib_stream, "\n"
			      "InnoDB: though there are still"
			      " open handles to it.\n"
			      "InnoDB: Adding the table to the"
			      " background drop queue.\n");

			/* We return DB_SUCCESS though the drop will
			happen lazily later */
			err = DB_SUCCESS;
		} else {
			/* The table is already in the background drop list */
			err = DB_TABLESPACE_DELETED;
		}

		goto func_exit;
	}

	/* TODO: could we replace the counter n_foreign_key_checks_running
	with lock checks on the table? Acquire here an exclusive lock on the
	table, and rewrite lock0lock.c and the lock wait in srv0srv.c so that
	they can cope with the table having been dropped here? Foreign key
	checks take an IS or IX lock on the table. */

	if (table->n_foreign_key_checks_running > 0) {

		const char*	table_name = table->name;
		ibool		added;

		added = ddl_add_table_to_background_drop_list(table_name);

		if (added) {
			ut_print_timestamp(ib_stream);
			ib_logger(ib_stream,
				"  InnoDB: You are trying to drop table ");
			ut_print_name(ib_stream, trx, TRUE, table_name);
			ib_logger(ib_stream, "\n"
			      "InnoDB: though there is a"
			      " foreign key check running on it.\n"
			      "InnoDB: Adding the table to"
			      " the background drop queue.\n");

			/* We return DB_SUCCESS though the drop will
			happen lazily later */

			err = DB_SUCCESS;
		} else {
			/* The table is already in the background drop list */
			err = DB_TABLESPACE_DELETED;
		}

		goto func_exit;
	}

	/* Remove any locks there are on the table or its records */

	lock_remove_all_on_table(table, TRUE);

	trx_set_dict_operation(trx, TRX_DICT_OP_TABLE);
	trx->table_id = table->id;

#if 0
	ib_logger(ib_stream, "Dropping: %ld\n", (long) table->id.low);
#endif

	/* We use the private SQL parser of Innobase to generate the
	query graphs needed in deleting the dictionary data from system
	tables in Innobase. Deleting a row from SYS_INDEXES table also
	frees the file segments of the B-tree associated with the index. */

	info = pars_info_create();

	pars_info_add_str_literal(info, "table_name", name);

	err = que_eval_sql(info,
			   "PROCEDURE DROP_TABLE_PROC () IS\n"
			   "sys_foreign_id CHAR;\n"
			   "table_id CHAR;\n"
			   "index_id CHAR;\n"
			   "foreign_id CHAR;\n"
			   "found INT;\n"
			   "BEGIN\n"
			   "SELECT ID INTO table_id\n"
			   "FROM SYS_TABLES\n"
			   "WHERE NAME = :table_name\n"
			   "LOCK IN SHARE MODE;\n"
			   "IF (SQL % NOTFOUND) THEN\n"
			   "       RETURN;\n"
			   "END IF;\n"
			   "found := 1;\n"
			   "SELECT ID INTO sys_foreign_id\n"
			   "FROM SYS_TABLES\n"
			   "WHERE NAME = 'SYS_FOREIGN'\n"
			   "LOCK IN SHARE MODE;\n"
			   "IF (SQL % NOTFOUND) THEN\n"
			   "       found := 0;\n"
			   "END IF;\n"
			   "IF (:table_name = 'SYS_FOREIGN') THEN\n"
			   "       found := 0;\n"
			   "END IF;\n"
			   "IF (:table_name = 'SYS_FOREIGN_COLS') THEN\n"
			   "       found := 0;\n"
			   "END IF;\n"
			   "WHILE found = 1 LOOP\n"
			   "       SELECT ID INTO foreign_id\n"
			   "       FROM SYS_FOREIGN\n"
			   "       WHERE FOR_NAME = :table_name\n"
			   "               AND TO_BINARY(FOR_NAME)\n"
			   "                 = TO_BINARY(:table_name)\n"
			   "               LOCK IN SHARE MODE;\n"
			   "       IF (SQL % NOTFOUND) THEN\n"
			   "               found := 0;\n"
			   "       ELSE\n"
			   "               DELETE FROM SYS_FOREIGN_COLS\n"
			   "               WHERE ID = foreign_id;\n"
			   "               DELETE FROM SYS_FOREIGN\n"
			   "               WHERE ID = foreign_id;\n"
			   "       END IF;\n"
			   "END LOOP;\n"
			   "found := 1;\n"
			   "WHILE found = 1 LOOP\n"
			   "       SELECT ID INTO index_id\n"
			   "       FROM SYS_INDEXES\n"
			   "       WHERE TABLE_ID = table_id\n"
			   "       LOCK IN SHARE MODE;\n"
			   "       IF (SQL % NOTFOUND) THEN\n"
			   "               found := 0;\n"
			   "       ELSE\n"
			   "               DELETE FROM SYS_FIELDS\n"
			   "               WHERE INDEX_ID = index_id;\n"
			   "               DELETE FROM SYS_INDEXES\n"
			   "               WHERE ID = index_id\n"
			   "               AND TABLE_ID = table_id;\n"
			   "       END IF;\n"
			   "END LOOP;\n"
			   "DELETE FROM SYS_COLUMNS\n"
			   "WHERE TABLE_ID = table_id;\n"
			   "DELETE FROM SYS_TABLES\n"
			   "WHERE ID = table_id;\n"
			   "END;\n"
			   , FALSE, trx);

	if (err != DB_SUCCESS) {

		if (err != DB_OUT_OF_FILE_SPACE) {
			ib_logger(ib_stream,
				"InnoDB: Error: unexpected err: %d", err);
			ut_error;
		}

		err = DB_MUST_GET_MORE_FILE_SPACE;

		ib_handle_errors(&err, trx, NULL, NULL);

		ut_error;
	} else {
		ibool		is_path;
		const char*	name_or_path;
		mem_heap_t*	heap;

		heap = mem_heap_create(200);

		/* Clone the name, in case it has been allocated
		from table->heap, which will be freed by
		dict_table_remove_from_cache(table) below. */
		name = mem_heap_strdup(heap, name);
		space_id = table->space;

		if (table->dir_path_of_temp_table != NULL) {
			is_path = TRUE;
			name_or_path = mem_heap_strdup(
				heap, table->dir_path_of_temp_table);
		} else {
			is_path = FALSE;
			name_or_path = name;
		}

		dict_table_remove_from_cache(table);

		// FIXME: srv_force_recovery should be passed in as an arg
		if (dict_load_table(srv_force_recovery, name) != NULL) {
			ut_print_timestamp(ib_stream);
			ib_logger(ib_stream,
				"  InnoDB: Error: not able to remove table ");
			ut_print_name(ib_stream, trx, TRUE, name);
			ib_logger(ib_stream,
				" from the dictionary cache!\n");
			err = DB_ERROR;
		}

		/* Do not drop possible .ibd tablespace if something went
		wrong: we do not want to delete valuable data of the user */

		if (err == DB_SUCCESS && space_id > 0) {
			if (!fil_space_for_table_exists_in_mem(space_id,
							       name_or_path,
							       is_path,
							       FALSE, TRUE)) {
				err = DB_SUCCESS;

				ib_logger(ib_stream,
					"InnoDB: We removed now the InnoDB"
					" internal data dictionary entry\n"
					"InnoDB: of table ");
				ut_print_name(ib_stream, trx, TRUE, name);
				ib_logger(ib_stream, ".\n");
			} else if (!fil_delete_tablespace(space_id)) {
				ib_logger(ib_stream,
					"InnoDB: We removed now the InnoDB"
					" internal data dictionary entry\n"
					"InnoDB: of table ");
				ut_print_name(ib_stream, trx, TRUE, name);
				ib_logger(ib_stream, ".\n");

				ut_print_timestamp(ib_stream);
				ib_logger(ib_stream,
					"  InnoDB: Error: not able to"
					" delete tablespace %lu of table ",
					(ulong) space_id);
				ut_print_name(ib_stream, trx, TRUE, name);
				ib_logger(ib_stream, "!\n");
				err = DB_ERROR;
			}
		}

		mem_heap_free(heap);
	}

func_exit:

	trx->op_info = "";

#ifndef UNIV_HOTBACKUP
	srv_wake_master_thread();
#endif /* !UNIV_HOTBACKUP */

	return((int) err);
}

/* Evaluates to true if str1 equals str2_onstack, used for comparing
the above strings. */
#define STR_EQ(str1, str1_len, str2_onstack) \
	((str1_len) == sizeof(str2_onstack) \
	 && memcmp(str1, str2_onstack, sizeof(str2_onstack)) == 0)

/*************************************************************************
Creates a table, if the name of the table ends in one of "innodb_monitor",
"innodb_lock_monitor", "innodb_tablespace_monitor", "innodb_table_monitor",
then this will also start the printing of monitor output by the master
thread. If the table name ends in "innodb_mem_validate", InnoDB will
try to invoke mem_validate().
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_create_table(
/*=============*/
	dict_table_t*	table,	/*!< in: table definition */
	trx_t*		trx)	/*!< in: transaction handle */
{
	tab_node_t*	node;
	mem_heap_t*	heap;
	que_thr_t*	thr;
	const char*	table_name;
	ulint		table_name_len;
	ulint		err;
	ulint		i;

	ut_ad(trx->client_thread_id == os_thread_get_curr_id());
#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&dict_operation_lock, RW_LOCK_EX));
#endif /* UNIV_SYNC_DEBUG */
	ut_ad(mutex_own(&(dict_sys->mutex)));
	ut_ad(trx->dict_operation_lock_mode == RW_X_LATCH);

	if (srv_created_new_raw) {
		ib_logger(ib_stream,
		      "InnoDB: A new raw disk partition was initialized:\n"
		      "InnoDB: we do not allow database modifications"
		      " by the user.\n"
		      "InnoDB: Shut down the database and edit your config "
		      "file so that newraw is replaced with raw.\n");
err_exit:
		dict_mem_table_free(table);

		return(DB_ERROR);

	/* The table name is prefixed with the database name and a '/'.
	Certain table names starting with 'innodb_' have their special
	meaning regardless of the database name.  Thus, we need to
	ignore the database name prefix in the comparisons. */
	} else if (strchr(table->name, '/') == NULL) {
		ib_logger(ib_stream, "  InnoDB: Error: table ");
		ut_print_name(ib_stream, trx, TRUE, table->name);
		ib_logger(ib_stream,
			"not prefixed with a database name and '/'\n");
		goto err_exit;
	}

	trx->op_info = "creating table";

	/* Check that no reserved column names are used. */
	for (i = 0; i < dict_table_get_n_user_cols(table); i++) {
		if (dict_col_name_is_reserved(
			    dict_table_get_col_name(table, i))) {

			goto err_exit;
		}
	}

	table_name = strchr(table->name, '/');
	table_name++;
	table_name_len = strlen(table_name) + 1;

	if (STR_EQ(table_name, table_name_len, S_innodb_monitor)) {

		/* Table equals "innodb_monitor":
		start monitor prints */

		srv_print_innodb_monitor = TRUE;

		/* The lock timeout monitor thread also takes care
		of InnoDB monitor prints */

		os_event_set(srv_lock_timeout_thread_event);
	} else if (STR_EQ(table_name, table_name_len,
			  S_innodb_lock_monitor)) {

		srv_print_innodb_monitor = TRUE;
		srv_print_innodb_lock_monitor = TRUE;
		os_event_set(srv_lock_timeout_thread_event);
	} else if (STR_EQ(table_name, table_name_len,
			  S_innodb_tablespace_monitor)) {

		srv_print_innodb_tablespace_monitor = TRUE;
		os_event_set(srv_lock_timeout_thread_event);
	} else if (STR_EQ(table_name, table_name_len,
			  S_innodb_table_monitor)) {

		srv_print_innodb_table_monitor = TRUE;
		os_event_set(srv_lock_timeout_thread_event);
	} else if (STR_EQ(table_name, table_name_len,
			  S_innodb_mem_validate)) {
		/* We define here a debugging feature intended for
		developers */

		ib_logger(ib_stream,
		      "Validating InnoDB memory:\n"
		      "to use this feature you must compile InnoDB with\n"
		      "UNIV_MEM_DEBUG defined in univ.i and"
		      " the server must be\n"
		      "quiet because allocation from a mem heap"
		      " is not protected\n"
		      "by any semaphore.\n");
#ifdef UNIV_MEM_DEBUG
		ut_a(mem_validate());
		ib_logger(ib_stream, "Memory validated\n");
#else /* UNIV_MEM_DEBUG */
		ib_logger(ib_stream,
			"Memory NOT validated (recompile with "
			"UNIV_MEM_DEBUG)\n");
#endif /* UNIV_MEM_DEBUG */
	}

	heap = mem_heap_create(512);

	trx_set_dict_operation(trx, TRX_DICT_OP_TABLE);

	node = tab_create_graph_create(table, heap, FALSE);

	thr = pars_complete_graph_for_exec(node, trx, heap);

	ut_a(thr == que_fork_start_command(que_node_get_parent(thr)));
	que_run_threads(thr);

	err = trx->error_state;

	if (UNIV_UNLIKELY(err != DB_SUCCESS)) {
		trx->error_state = DB_SUCCESS;
	}

	switch (err) {
	case DB_OUT_OF_FILE_SPACE:
		ut_print_timestamp(ib_stream);
		ib_logger(ib_stream, "  InnoDB: Warning: cannot create table ");
		ut_print_name(ib_stream, trx, TRUE, table->name);
		ib_logger(ib_stream, " because tablespace full\n");

		if (dict_table_get_low(table->name)) {

			ddl_drop_table(table->name, trx, FALSE);
		}
		break;

	case DB_DUPLICATE_KEY:
		ut_print_timestamp(ib_stream);
		ib_logger(ib_stream, "  InnoDB: Error: table ");
		ut_print_name(ib_stream, trx, TRUE, table->name);
		ib_logger(ib_stream,
		      " already exists in InnoDB internal\n"
		      "InnoDB: data dictionary.\n"
		      "InnoDB: You can look for further help on\n"
		      "InnoDB: the InnoDB website\n");

		/* We may also get err == DB_ERROR if the .ibd file for the
		table already exists */

		break;
	}

	que_graph_free((que_t*) que_node_get_parent(thr));

	trx->op_info = "";

	return((int) err);
}

/*************************************************************************
Does an index creation operation.
@return	error number or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_create_index(
/*=============*/
	dict_index_t*	index,		/*!< in: index definition */
	trx_t*		trx)		/*!< in: transaction handle */
{
	ulint		err;
	que_thr_t*	thr;		/* Query thread */
	ind_node_t*	node;		/* Index creation node */
	mem_heap_t*	heap;		/* Memory heap */

#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&dict_operation_lock, RW_LOCK_EX));
#endif /* UNIV_SYNC_DEBUG */
	ut_ad(mutex_own(&(dict_sys->mutex)));

	/* This heap is destroyed when the query graph is freed. */
	heap = mem_heap_create(512);

	node = ind_create_graph_create(index, heap, FALSE);
	thr = pars_complete_graph_for_exec(node, trx, heap);

	ut_a(thr == que_fork_start_command(que_node_get_parent(thr)));

	que_run_threads(thr);

	err = trx->error_state;

	que_graph_free((que_t*) que_node_get_parent(thr));

	return(err);
}

/*************************************************************************
Truncates a table
@return	error code or DB_SUCCESS */
UNIV_INTERN
enum db_err
ddl_truncate_table(
/*===============*/
	dict_table_t*	table,	/*!< in: table handle */
	trx_t*		trx)	/*!< in: transaction handle */
{
	dict_foreign_t*	foreign;
	enum db_err	err;
	mem_heap_t*	heap;
	byte*		buf;
	dtuple_t*	tuple;
	dfield_t*	dfield;
	dict_index_t*	sys_index;
	btr_pcur_t	pcur;
	mtr_t		mtr;
	dulint		new_id;
	ulint		recreate_space = 0;
	pars_info_t*	info = NULL;

	/* How do we prevent crashes caused by ongoing operations on
	the table? Old operations could try to access non-existent
	pages.

	1) SQL queries, INSERT, SELECT, ...: we must get an exclusive
	table lock on the table before we can do TRUNCATE TABLE. Ensure
	there are no running queries on the table. This guarantee has
	to be provided by the SQL layer.

	2) Purge and rollback: we assign a new table id for the
	table. Since purge and rollback look for the table based on
	the table id, they see the table as 'dropped' and discard
	their operations.

	3) Insert buffer: TRUNCATE TABLE is analogous to DROP TABLE,
	so we do not have to remove insert buffer records, as the
	insert buffer works at a low level. If a freed page is later
	reallocated, the allocator will remove the ibuf entries for
	it.

	When we truncate *.ibd files by recreating them (analogous to
	DISCARD TABLESPACE), we remove all entries for the table in the
	insert buffer tree.  This is not strictly necessary, because
	in 6) we will assign a new tablespace identifier, but we can
	free up some space in the system tablespace.

	4) Linear readahead and random readahead: we use the same
	method as in 3) to discard ongoing operations. (This is only
	relevant for TRUNCATE TABLE by DISCARD TABLESPACE.)

	5) FOREIGN KEY operations: if
	table->n_foreign_key_checks_running > 0, we do not allow the
	TRUNCATE. We also reserve the data dictionary latch.

	6) Crash recovery: To prevent the application of pre-truncation
	redo log records on the truncated tablespace, we will assign
	a new tablespace identifier to the truncated tablespace. */

	if (srv_created_new_raw) {
		ib_logger(ib_stream,
		      "InnoDB: A new raw disk partition was initialized:\n"
		      "InnoDB: we do not allow database modifications"
		      " by the user.\n"
		      "InnoDB: Shut down server and edit config file so "
		      "that newraw is replaced with raw.\n");

		return(DB_ERROR);
	}

	trx->op_info = "truncating table";

	/* Serialize data dictionary operations with dictionary mutex:
	no deadlocks can occur then in these operations */
	ut_a(trx->dict_operation_lock_mode != 0);

	/* Prevent foreign key checks etc. while we are truncating the
	table */
	ut_ad(mutex_own(&(dict_sys->mutex)));

#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&dict_operation_lock, RW_LOCK_EX));
#endif /* UNIV_SYNC_DEBUG */

	/* Check if the table is referenced by foreign key constraints from
	some other table (not the table itself) */

	foreign = UT_LIST_GET_FIRST(table->referenced_list);

	while (foreign && foreign->foreign_table == table) {
		foreign = UT_LIST_GET_NEXT(referenced_list, foreign);
	}

	if (foreign && trx->check_foreigns) {
		/* We only allow truncating a referenced table if
		FOREIGN_KEY_CHECKS is set to 0 */

		mutex_enter(&dict_foreign_err_mutex);
		ut_print_timestamp(ib_stream);

		ib_logger(ib_stream, "  Cannot truncate table ");
		ut_print_name(ib_stream, trx, TRUE, table->name);
		ib_logger(ib_stream, " by DROP+CREATE\n"
		      "InnoDB: because it is referenced by ");
		ut_print_name(ib_stream,
			trx, TRUE, foreign->foreign_table_name);
		ib_logger(ib_stream, "\n");
		mutex_exit(&dict_foreign_err_mutex);

		err = DB_ERROR;
		goto func_exit;
	}

	/* TODO: could we replace the counter n_foreign_key_checks_running
	with lock checks on the table? Acquire here an exclusive lock on the
	table, and rewrite lock0lock.c and the lock wait in srv0srv.c so that
	they can cope with the table having been truncated here? Foreign key
	checks take an IS or IX lock on the table. */

	if (table->n_foreign_key_checks_running > 0) {
		ut_print_timestamp(ib_stream);
		ib_logger(ib_stream, "  InnoDB: Cannot truncate table ");
		ut_print_name(ib_stream, trx, TRUE, table->name);
		ib_logger(ib_stream, " by DROP+CREATE\n"
		      "InnoDB: because there is a foreign key check"
		      " running on it.\n");
		err = DB_ERROR;

		goto func_exit;
	}

	/* Remove all locks except the table-level S and X locks. */
	lock_remove_all_on_table(table, FALSE);

	trx->table_id = table->id;

	if (table->space && !table->dir_path_of_temp_table) {
		/* Discard and create the single-table tablespace. */
		ulint	space	= table->space;
		ulint	flags	= fil_space_get_flags(space);

		if (flags != ULINT_UNDEFINED
		    && fil_discard_tablespace(space)) {

			dict_index_t*	index;

			space = 0;

			if (fil_create_new_single_table_tablespace(
				    &space, table->name, FALSE, flags,
				    FIL_IBD_FILE_INITIAL_SIZE) != DB_SUCCESS) {
				ut_print_timestamp(ib_stream);
				ib_logger(ib_stream,
					"  InnoDB: TRUNCATE TABLE %s failed to"
					" create a new tablespace\n",
					table->name);
				table->ibd_file_missing = 1;
				err = DB_ERROR;
				goto func_exit;
			}

			recreate_space = space;

			/* Replace the space_id in the data dictionary cache.
			The persisent data dictionary (SYS_TABLES.SPACE
			and SYS_INDEXES.SPACE) are updated later in this
			function. */
			table->space = space;
			index = dict_table_get_first_index(table);
			do {
				index->space = space;
				index = dict_table_get_next_index(index);
			} while (index);

			mtr_start(&mtr);
			fsp_header_init(space,
					FIL_IBD_FILE_INITIAL_SIZE, &mtr);
			mtr_commit(&mtr);
		}
	}

	/* scan SYS_INDEXES for all indexes of the table */
	heap = mem_heap_create(800);

	tuple = dtuple_create(heap, 1);
	dfield = dtuple_get_nth_field(tuple, 0);

	buf = mem_heap_alloc(heap, 8);
	mach_write_to_8(buf, table->id);

	dfield_set_data(dfield, buf, 8);
	sys_index = dict_table_get_first_index(dict_sys->sys_indexes);
	dict_index_copy_types(tuple, sys_index, 1);

	mtr_start(&mtr);
	btr_pcur_open_on_user_rec(sys_index, tuple, PAGE_CUR_GE,
				  BTR_MODIFY_LEAF, &pcur, &mtr);
	for (;;) {
		rec_t*		rec;
		const byte*	field;
		ulint		len;
		ulint		root_page_no;

		if (!btr_pcur_is_on_user_rec(&pcur)) {
			/* The end of SYS_INDEXES has been reached. */
			break;
		}

		rec = btr_pcur_get_rec(&pcur);

		field = rec_get_nth_field_old(rec, 0, &len);
		ut_ad(len == 8);

		if (memcmp(buf, field, len) != 0) {
			/* End of indexes for the table (TABLE_ID mismatch). */
			break;
		}

		if (rec_get_deleted_flag(rec, FALSE)) {
			/* The index has been dropped. */
			goto next_rec;
		}

		/* This call may commit and restart mtr
		and reposition pcur. */
		root_page_no = dict_truncate_index_tree(table, recreate_space,
							&pcur, &mtr);

		rec = btr_pcur_get_rec(&pcur);

		if (root_page_no != FIL_NULL) {
			page_rec_write_index_page_no(
				rec, DICT_SYS_INDEXES_PAGE_NO_FIELD,
				root_page_no, &mtr);
			/* We will need to commit and restart the
			mini-transaction in order to avoid deadlocks.
			The dict_truncate_index_tree() call has allocated
			a page in this mini-transaction, and the rest of
			this loop could latch another index page. */
			mtr_commit(&mtr);
			mtr_start(&mtr);
			btr_pcur_restore_position(BTR_MODIFY_LEAF,
						  &pcur, &mtr);
		}

next_rec:
		btr_pcur_move_to_next_user_rec(&pcur, &mtr);
	}

	btr_pcur_close(&pcur);
	mtr_commit(&mtr);

	mem_heap_free(heap);

	new_id = dict_hdr_get_new_id(DICT_HDR_TABLE_ID);

	info = pars_info_create();

	pars_info_add_int4_literal(info, "space", (lint) table->space);
	pars_info_add_dulint_literal(info, "old_id", table->id);
	pars_info_add_dulint_literal(info, "new_id", new_id);

	err = que_eval_sql(info,
			   "PROCEDURE RENUMBER_TABLESPACE_PROC () IS\n"
			   "BEGIN\n"
			   "UPDATE SYS_TABLES"
			   " SET ID = :new_id, SPACE = :space\n"
			   " WHERE ID = :old_id;\n"
			   "UPDATE SYS_COLUMNS SET TABLE_ID = :new_id\n"
			   " WHERE TABLE_ID = :old_id;\n"
			   "UPDATE SYS_INDEXES"
			   " SET TABLE_ID = :new_id, SPACE = :space\n"
			   " WHERE TABLE_ID = :old_id;\n"
			   "COMMIT WORK;\n"
			   "END;\n"
			   , FALSE, trx);

	if (err != DB_SUCCESS) {
		trx->error_state = DB_SUCCESS;
		trx_rollback(trx, FALSE, NULL);
		trx->error_state = DB_SUCCESS;
		ut_print_timestamp(ib_stream);
		ib_logger(ib_stream,
		      "  InnoDB: Unable to assign a new identifier to table ");
		ut_print_name(ib_stream, trx, TRUE, table->name);
		ib_logger(ib_stream, "\n"
		      "InnoDB: after truncating it.  Background processes"
		      " may corrupt the table!\n");
		err = DB_ERROR;
	} else {
		dict_table_change_id_in_cache(table, new_id);
	}

	dict_update_statistics(table);

func_exit:

	trx->op_info = "";

	srv_wake_master_thread();

	return(err);
}

/*************************************************************************
Drops an index.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_drop_index(
/*===========*/
	dict_table_t*	table,		/*!< in: table instance */
	dict_index_t*	index,		/*!< in: index to drop */
	trx_t*		trx)		/*!< in: transaction handle */
{
	ulint		err = DB_SUCCESS;
	pars_info_t*	info = pars_info_create();

	/* We use the private SQL parser of Innobase to generate the
	query graphs needed in deleting the dictionary data from system
	tables in Innobase. Deleting a row from SYS_INDEXES table also
	frees the file segments of the B-tree associated with the index. */

	static const char str1[] =
		"PROCEDURE DROP_INDEX_PROC () IS\n"
		"BEGIN\n"
		/* Rename the index, so that it will be dropped by
		row_merge_drop_temp_indexes() at crash recovery
		if the server crashes before this trx is committed. */
		"UPDATE SYS_INDEXES SET NAME=CONCAT('"
		TEMP_INDEX_PREFIX_STR "', NAME) WHERE ID = :indexid;\n"
		"COMMIT WORK;\n"
		/* Drop the field definitions of the index. */
		"DELETE FROM SYS_FIELDS WHERE INDEX_ID = :indexid;\n"
		/* Drop the index definition and the B-tree. */
		"DELETE FROM SYS_INDEXES WHERE ID = :indexid;\n"
		"END;\n";

	ut_ad(index && table && trx);

	pars_info_add_dulint_literal(info, "indexid", index->id);

	trx_start_if_not_started(trx);
	trx->op_info = "dropping index";

	ut_a(trx->dict_operation_lock_mode == RW_X_LATCH);

	err = que_eval_sql(info, str1, FALSE, trx);

	ut_a(err == DB_SUCCESS);

	/* Replace this index with another equivalent index for all
	foreign key constraints on this table where this index is used */

	dict_table_replace_index_in_foreign_list(table, index);
	dict_index_remove_from_cache(table, index);

	trx->op_info = "";
	return(err);
}

/********************************************************************
Delete a single constraint.
@return	error code or DB_SUCCESS */
UNIV_STATIC
int
ddl_delete_constraint_low(
/*======================*/
	const char*	id,		/*!< in: constraint id */
	trx_t*		trx)		/*!< in: transaction handle */
{
	pars_info_t*	info = pars_info_create();

	pars_info_add_str_literal(info, "id", id);

	return((int) que_eval_sql(
		info,
		"PROCEDURE DELETE_CONSTRAINT () IS\n"
		"BEGIN\n"
		"DELETE FROM SYS_FOREIGN_COLS WHERE ID = :id;\n"
		"DELETE FROM SYS_FOREIGN WHERE ID = :id;\n"
		"END;\n"
		, FALSE, trx));
}

/********************************************************************
Delete a single constraint.
@return	error code or DB_SUCCESS */
UNIV_STATIC
int
ddl_delete_constraint(
/*==================*/
	const char*	id,		/*!< in: constraint id */
	const char*	database_name,	/*!< in: database name, with the
					trailing '/' */
	mem_heap_t*	heap,		/*!< in: memory heap */
	trx_t*		trx)		/*!< in: transaction handle */
{
	ulint		err;

	/* New format constraints have ids <databasename>/<constraintname>. */
	err = ddl_delete_constraint_low(
		mem_heap_strcat(heap, database_name, id), trx);

	if (err == DB_SUCCESS && !strchr(id, '/')) {
		/* Old format < 4.0.18 constraints have constraint ids
		<number>_<number>. We only try deleting them if the
		constraint name does not contain a '/' character, otherwise
		deleting a new format constraint named 'foo/bar' from
		database 'baz' would remove constraint 'bar' from database
		'foo', if it existed. */

		err = ddl_delete_constraint_low(id, trx);
	}

	return((int) err);
}

/*************************************************************************
Renames a table.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_rename_table(
/*=============*/
	const char*	old_name,	/*!< in: old table name */
	const char*	new_name,	/*!< in: new table name */
	trx_t*		trx)		/*!< in: transaction handle */
{
	dict_table_t*	table;
	ulint		err			= DB_ERROR;
	mem_heap_t*	heap			= NULL;
	const char**	constraints_to_drop	= NULL;
	ulint		n_constraints_to_drop	= 0;
	pars_info_t*	info			= NULL;

	ut_a(old_name != NULL);
	ut_a(new_name != NULL);
	ut_ad(trx->client_thread_id == os_thread_get_curr_id());

	if (srv_created_new_raw || srv_force_recovery != IB_RECOVERY_DEFAULT) {
		ib_logger(ib_stream,
		      "InnoDB: A new raw disk partition was initialized or\n"
		      "InnoDB: innodb_force_recovery is on: we do not allow\n"
		      "InnoDB: database modifications by the user. Shut down\n"
		      "InnoDB: the server and ensure that newraw is replaced\n"
		      "InnoDB: with raw, and innodb_force_... is removed.\n");

		goto func_exit;
	}

	trx->op_info = "renaming table";

	table = dict_table_get_low(old_name);

	if (!table) {
		err = DB_TABLE_NOT_FOUND;
		goto func_exit;
	} else if (table->ibd_file_missing) {
		err = DB_TABLE_NOT_FOUND;
		goto func_exit;
	}

	/* We use the private SQL parser of Innobase to generate the query
	graphs needed in updating the dictionary data from system tables. */

	info = pars_info_create();

	pars_info_add_str_literal(info, "new_table_name", new_name);
	pars_info_add_str_literal(info, "old_table_name", old_name);

	err = que_eval_sql(
		info,
		"PROCEDURE RENAME_TABLE () IS\n"
		"BEGIN\n"
		"UPDATE SYS_TABLES SET NAME = :new_table_name\n"
		" WHERE NAME = :old_table_name;\n"
		"END;\n"
		, FALSE, trx);

	if (err == DB_SUCCESS) {
		/* Rename all constraints. */

		info = pars_info_create();

		pars_info_add_str_literal(info, "new_table_name", new_name);
		pars_info_add_str_literal(info, "old_table_name", old_name);

		err = que_eval_sql(
			info,
			"PROCEDURE RENAME_CONSTRAINT_IDS () IS\n"
			"gen_constr_prefix CHAR;\n"
			"new_db_name CHAR;\n"
			"foreign_id CHAR;\n"
			"new_foreign_id CHAR;\n"
			"old_db_name_len INT;\n"
			"old_t_name_len INT;\n"
			"new_db_name_len INT;\n"
			"id_len INT;\n"
			"found INT;\n"
			"BEGIN\n"
			"found := 1;\n"
			"old_db_name_len := INSTR(:old_table_name, '/')-1;\n"
			"new_db_name_len := INSTR(:new_table_name, '/')-1;\n"
			"new_db_name := SUBSTR(:new_table_name, 0,\n"
			"                      new_db_name_len);\n"
			"old_t_name_len := LENGTH(:old_table_name);\n"
			"gen_constr_prefix := CONCAT(:old_table_name,\n"
			"                            '_ibfk_');\n"
			"WHILE found = 1 LOOP\n"
			"       SELECT ID INTO foreign_id\n"
			"        FROM SYS_FOREIGN\n"
			"        WHERE FOR_NAME = :old_table_name\n"
			"         AND TO_BINARY(FOR_NAME)\n"
			"           = TO_BINARY(:old_table_name)\n"
			"         LOCK IN SHARE MODE;\n"
			"       IF (SQL % NOTFOUND) THEN\n"
			"        found := 0;\n"
			"       ELSE\n"
			"        UPDATE SYS_FOREIGN\n"
			"        SET FOR_NAME = :new_table_name\n"
			"         WHERE ID = foreign_id;\n"
			"        id_len := LENGTH(foreign_id);\n"
			"        IF (INSTR(foreign_id, '/') > 0) THEN\n"
			"               IF (INSTR(foreign_id,\n"
			"                         gen_constr_prefix) > 0)\n"
			"               THEN\n"
			"                new_foreign_id :=\n"
			"                CONCAT(:new_table_name,\n"
			"                SUBSTR(foreign_id, old_t_name_len,\n"
			"                       id_len - old_t_name_len));\n"
			"               ELSE\n"
			"                new_foreign_id :=\n"
			"                CONCAT(new_db_name,\n"
			"                SUBSTR(foreign_id,\n"
			"                       old_db_name_len,\n"
			"                       id_len - old_db_name_len));\n"
			"               END IF;\n"
			"               UPDATE SYS_FOREIGN\n"
			"                SET ID = new_foreign_id\n"
			"                WHERE ID = foreign_id;\n"
			"               UPDATE SYS_FOREIGN_COLS\n"
			"                SET ID = new_foreign_id\n"
			"                WHERE ID = foreign_id;\n"
			"        END IF;\n"
			"       END IF;\n"
			"END LOOP;\n"
			"UPDATE SYS_FOREIGN SET REF_NAME = :new_table_name\n"
			"WHERE REF_NAME = :old_table_name\n"
			"  AND TO_BINARY(REF_NAME)\n"
			"    = TO_BINARY(:old_table_name);\n"
			"END;\n"
			, FALSE, trx);

	} else if (n_constraints_to_drop > 0) {
		/* Drop some constraints of tmp tables. */

		ulint	i;
		char*	db_name;
		ulint	db_name_len;

		db_name_len = dict_get_db_name_len(old_name) + 1;
		db_name = mem_heap_strdupl(heap, old_name, db_name_len);

		for (i = 0; i < n_constraints_to_drop; i++) {
			err = ddl_delete_constraint(
				constraints_to_drop[i], db_name, heap, trx);

			if (err != DB_SUCCESS) {
				break;
			}
		}
	}

	if (err != DB_SUCCESS) {
		if (err == DB_DUPLICATE_KEY) {
			ut_print_timestamp(ib_stream);
			ib_logger(ib_stream,
			      "  InnoDB: Error; possible reasons:\n"
			      "InnoDB: 1) Table rename would cause"
			      " two FOREIGN KEY constraints\n"
			      "InnoDB: to have the same internal name"
			      " in case-insensitive comparison.\n"
			      " trying to rename table.\n" 
			      "InnoDB: If table ");
			ut_print_name(ib_stream, trx, TRUE, new_name);
			ib_logger(ib_stream,
			      " is a temporary table, then it can be that\n"
			      "InnoDB: there are still queries running"
			      " on the table, and it will be\n"
			      "InnoDB: dropped automatically when"
			      " the queries end.\n");
		}
		trx->error_state = DB_SUCCESS;
		trx_rollback(trx, FALSE, NULL);
		trx->error_state = DB_SUCCESS;
	} else {
		/* The following call will also rename the .ibd data file if
		the table is stored in a single-table tablespace */

		if (!dict_table_rename_in_cache(table, new_name, TRUE)) {
			trx->error_state = DB_SUCCESS;
			trx_rollback(trx, FALSE, NULL);
			trx->error_state = DB_SUCCESS;
			goto func_exit;
		}

		/* We only want to switch off some of the type checking in
		an ALTER, not in a RENAME. */

		err = dict_load_foreigns(new_name, trx->check_foreigns);

		if (err != DB_SUCCESS) {
			ibool	ret;

			ut_print_timestamp(ib_stream);

			ib_logger(ib_stream,
				"  InnoDB: Error: in RENAME TABLE"
				" table ");
			ut_print_name(ib_stream, trx, TRUE, new_name);
			ib_logger(ib_stream, "\n"
				"InnoDB: is referenced in"
				" foreign key constraints\n"
				"InnoDB: which are not compatible"
				" with the new table definition.\n");

			ret = dict_table_rename_in_cache(table,old_name, FALSE);
			ut_a(ret);

			trx->error_state = DB_SUCCESS;
			trx_rollback(trx, FALSE, NULL);
			trx->error_state = DB_SUCCESS;
		}
	}

func_exit:

	if (UNIV_LIKELY_NULL(heap)) {
		mem_heap_free(heap);
	}

	trx->op_info = "";

	return(err);
}

/*************************************************************************
Renames an index.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
ddl_rename_index(
/*=============*/
	const char*	table_name,	/*!< in: table that owns the index */
	const char*	old_name,	/*!< in: old table name */
	const char*	new_name,	/*!< in: new table name */
	trx_t*		trx)		/*!< in: transaction handle */
{
	dict_table_t*	table;
	pars_info_t*	info = NULL;
	ulint		err = DB_ERROR;

	ut_a(old_name != NULL);
	ut_a(old_name != NULL);
	ut_a(table_name != NULL);
	ut_ad(trx->client_thread_id == os_thread_get_curr_id());

	if (srv_created_new_raw || srv_force_recovery != IB_RECOVERY_DEFAULT) {
		ib_logger(ib_stream,
		      "InnoDB: A new raw disk partition was initialized or\n"
		      "InnoDB: innodb_force_recovery is on: we do not allow\n"
		      "InnoDB: database modifications by the user. Shut down\n"
		      "InnoDB: the server and ensure that newraw is replaced\n"
		      "InnoDB: with raw, and innodb_force_... is removed.\n");

		goto func_exit;
	}

	trx->op_info = "renaming index";

	table = dict_table_get_low(table_name);

	if (!table || table->ibd_file_missing) {
		err = DB_TABLE_NOT_FOUND;
		goto func_exit;
	}

	/* We use the private SQL parser of Innobase to generate the query
	graphs needed in updating the dictionary data from system tables. */

	info = pars_info_create();

	pars_info_add_str_literal(info, "table_name", table_name);
	pars_info_add_str_literal(info, "new_index_name", new_name);
	pars_info_add_str_literal(info, "old_index_name", old_name);

	err = que_eval_sql(
		info,
		"PROCEDURE RENAME_TABLE () IS\n"
		"table_id CHAR;\n"
		"BEGIN\n"
		"SELECT ID INTO table_id\n"
		" FROM SYS_TABLES\n"
		" WHERE NAME = :table_name\n"
		"LOCK IN SHARE MODE;\n"
		"IF (SQL % NOTFOUND) THEN\n"
		" RETURN;\n"
		"END IF;\n"
		"UPDATE SYS_INDEXES SET NAME = :new_index_name\n"
		" WHERE NAME = :old_index_name\n"
		"  AND table_id = table_id;\n"
		"END;\n"
		, FALSE, trx);

	if (err == DB_SUCCESS) {
		dict_index_t*	index;

		index = dict_table_get_first_index(table);

		do {
			/* FIXME: We are leaking memory here, well sort
			of, since the previous name allocation will not
			be freed till the index instance is destroyed. */
			if (strcasecmp(index->name, old_name) == 0) {
				index->name = mem_heap_strdup(
					index->heap, new_name);

				break;
			}

			index = dict_table_get_next_index(index);
		} while (index);

	} else {
		trx->error_state = DB_SUCCESS;
		trx_rollback(trx, FALSE, NULL);
	}

func_exit:

	trx->op_info = "";

	return(err);
}

/***********************************************************************
Drop all foreign keys in a database, see Bug#18942.
@return	error code or DB_SUCCESS */
UNIV_STATIC
enum db_err
ddl_drop_all_foreign_keys_in_db(
/*============================*/
	const char*	name,	/*!< in: database name which ends to '/' */
	trx_t*		trx)	/*!< in: transaction handle */
{
	enum db_err	err;
	pars_info_t*	pinfo;

	ut_a(name[strlen(name) - 1] == '/');

	pinfo = pars_info_create();

	pars_info_add_str_literal(pinfo, "dbname", name);

/* true if for_name is not prefixed with dbname */
#define TABLE_NOT_IN_THIS_DB \
"SUBSTR(for_name, 0, LENGTH(:dbname)) <> :dbname"

	err = que_eval_sql(pinfo,
			   "PROCEDURE DROP_ALL_FOREIGN_KEYS_PROC () IS\n"
			   "foreign_id CHAR;\n"
			   "for_name CHAR;\n"
			   "found INT;\n"
			   "DECLARE CURSOR cur IS\n"
			   "SELECT ID, FOR_NAME FROM SYS_FOREIGN\n"
			   "WHERE FOR_NAME >= :dbname\n"
			   "LOCK IN SHARE MODE\n"
			   "ORDER BY FOR_NAME;\n"
			   "BEGIN\n"
			   "found := 1;\n"
			   "OPEN cur;\n"
			   "WHILE found = 1 LOOP\n"
			   "        FETCH cur INTO foreign_id, for_name;\n"
			   "        IF (SQL % NOTFOUND) THEN\n"
			   "                found := 0;\n"
			   "        ELSIF (" TABLE_NOT_IN_THIS_DB ") THEN\n"
			   "                found := 0;\n"
			   "        ELSIF (1=1) THEN\n"
			   "                DELETE FROM SYS_FOREIGN_COLS\n"
			   "                WHERE ID = foreign_id;\n"
			   "                DELETE FROM SYS_FOREIGN\n"
			   "                WHERE ID = foreign_id;\n"
			   "        END IF;\n"
			   "END LOOP;\n"
			   "CLOSE cur;\n"
			   "END;\n",
			   FALSE, /* do not reserve dict mutex,
				  we are already holding it */
			   trx);

	return(err);
}

/*************************************************************************
Drops a database.
@return	error code or DB_SUCCESS */
UNIV_INTERN
enum db_err
ddl_drop_database(
/*==============*/
	const char*	name,	/*!< in: database name which ends in '/' */
	trx_t*		trx)	/*!< in: transaction handle */
{
	char*		table_name;
	enum db_err	err = DB_SUCCESS;
	ulint		namelen	= ut_strlen(name);

	ut_a(name[namelen - 1] == '/');
	ut_ad(trx->client_thread_id == os_thread_get_curr_id());

	trx->op_info = "dropping database";

loop:
	dict_lock_data_dictionary(trx);

	while ((table_name = dict_get_first_table_name_in_db(name))) {
		dict_table_t*	table;

		ut_a(memcmp(table_name, name, namelen) == 0);

		table = dict_table_get_low(table_name);

		ut_a(table);

		/* Wait until the user does not have any queries running on
		the table */

		if (table->n_handles_opened > 0) {
			dict_unlock_data_dictionary(trx);

			ut_print_timestamp(ib_stream);
			ib_logger(ib_stream,
				"  InnoDB: Warning: The client is trying to"
			      	" drop database ");
			ut_print_name(ib_stream, trx, TRUE, name);
			ib_logger(ib_stream, "\n"
			      "InnoDB: though there are still"
			      " open handles to table ");
			ut_print_name(ib_stream, trx, TRUE, table_name);
			ib_logger(ib_stream, ".\n");

			os_thread_sleep(1000000);

			mem_free(table_name);

			goto loop;
		}

		err = ddl_drop_table(table_name, trx, TRUE);

		if (err != DB_SUCCESS) {
			ib_logger(ib_stream, "InnoDB: DROP DATABASE ");
			ut_print_name(ib_stream, trx, TRUE, name);
			ib_logger(ib_stream,
				" failed with error %lu for table ",
				(ulint) err);
			ut_print_name(ib_stream, trx, TRUE, table_name);
			ib_logger(ib_stream, "\n");
			mem_free(table_name);
			break;
		}

		mem_free(table_name);
	}

	if (err == DB_SUCCESS) {
		/* After dropping all tables try to drop all leftover
		foreign keys in case orphaned ones exist */
		err = ddl_drop_all_foreign_keys_in_db(name, trx);

		if (err != DB_SUCCESS) {
			ib_logger(ib_stream, "InnoDB: DROP DATABASE ");
			ut_print_name(ib_stream, trx, TRUE, name);
			ib_logger(ib_stream, " failed with error %d while "
				"dropping all foreign keys", err);
		}
	}

	dict_unlock_data_dictionary(trx);

	trx->op_info = "";

	return(err);
}

/*********************************************************************//**
Drop all partially created indexes. */
UNIV_INTERN
void
ddl_drop_all_temp_indexes(
/*======================*/
	ib_recovery_t	recovery)	/*!< in: recovery level setting */
{
	trx_t*		trx;
	btr_pcur_t	pcur;
	mtr_t		mtr;
	ibool		started;

	/* Load the table definitions that contain partially defined
	indexes, so that the data dictionary information can be checked
	when accessing the tablename.ibd files. */
	trx = trx_allocate_for_background();
	started = trx_start(trx, ULINT_UNDEFINED);
	ut_a(started);
	trx->op_info = "dropping partially created indexes";
	dict_lock_data_dictionary(trx);

	mtr_start(&mtr);

	btr_pcur_open_at_index_side(
		TRUE,
		dict_table_get_first_index(dict_sys->sys_indexes),
		BTR_SEARCH_LEAF, &pcur, TRUE, &mtr);

	for (;;) {
		const rec_t*	rec;
		ulint		len;
		const byte*	field;
		dict_table_t*	table;
		dulint		table_id;

		btr_pcur_move_to_next_user_rec(&pcur, &mtr);

		if (!btr_pcur_is_on_user_rec(&pcur)) {
			break;
		}

		rec = btr_pcur_get_rec(&pcur);
		field = rec_get_nth_field_old(rec, DICT_SYS_INDEXES_NAME_FIELD,
					      &len);
		if (len == UNIV_SQL_NULL || len == 0
		    || mach_read_from_1(field) != (ulint) TEMP_INDEX_PREFIX) {
			continue;
		}

		/* This is a temporary index. */

		field = rec_get_nth_field_old(rec, 0/*TABLE_ID*/, &len);
		if (len != 8) {
			/* Corrupted TABLE_ID */
			continue;
		}

		table_id = mach_read_from_8(field);

		btr_pcur_store_position(&pcur, &mtr);
		btr_pcur_commit_specify_mtr(&pcur, &mtr);

		table = dict_load_table_on_id(recovery, table_id);

		if (table) {
			dict_index_t*	index;

			for (index = dict_table_get_first_index(table);
			     index; index = dict_table_get_next_index(index)) {

				if (*index->name == TEMP_INDEX_PREFIX) {
					ddl_drop_index(table, index, trx);
					trx_commit(trx);
				}
			}
		}

		mtr_start(&mtr);
		btr_pcur_restore_position(BTR_SEARCH_LEAF, &pcur, &mtr);
	}

	btr_pcur_close(&pcur);
	mtr_commit(&mtr);

	dict_unlock_data_dictionary(trx);

	trx_commit(trx);
	trx_free_for_background(trx);
}

/*********************************************************************//**
Drop all temporary tables. */
UNIV_INTERN
void
ddl_drop_all_temp_tables(
/*=====================*/
	ib_recovery_t	recovery)	/*!< in: recovery level setting*/
{
	trx_t*		trx;
	btr_pcur_t	pcur;
	mtr_t		mtr;
	mem_heap_t*	heap;
	ibool		started;

	trx = trx_allocate_for_background();
	started = trx_start(trx, ULINT_UNDEFINED);
	trx->op_info = "dropping temporary tables";
	dict_lock_data_dictionary(trx);

	heap = mem_heap_create(200);

	mtr_start(&mtr);

	btr_pcur_open_at_index_side(
		TRUE,
		dict_table_get_first_index(dict_sys->sys_tables),
		BTR_SEARCH_LEAF, &pcur, TRUE, &mtr);

	for (;;) {
		const rec_t*	rec;
		ulint		len;
		const byte*	field;
		dict_table_t*	table;
		const char*	table_name;

		btr_pcur_move_to_next_user_rec(&pcur, &mtr);

		if (!btr_pcur_is_on_user_rec(&pcur)) {
			break;
		}

		rec = btr_pcur_get_rec(&pcur);
		field = rec_get_nth_field_old(rec, 4/*N_COLS*/, &len);
		if (len != 4 || !(mach_read_from_4(field) & 0x80000000UL)) {
			continue;
		}

		/* Because this is not a ROW_FORMAT=REDUNDANT table,
		the is_temp flag is valid.  Examine it. */

		field = rec_get_nth_field_old(rec, 7/*MIX_LEN*/, &len);
		if (len != 4
		    || !(mach_read_from_4(field) & DICT_TF2_TEMPORARY)) {
			continue;
		}

		/* This is a temporary table. */
		field = rec_get_nth_field_old(rec, 0/*NAME*/, &len);
		if (len == UNIV_SQL_NULL || len == 0) {
			/* Corrupted SYS_TABLES.NAME */
			continue;
		}

		table_name = mem_heap_strdupl(heap, (const char*) field, len);

		btr_pcur_store_position(&pcur, &mtr);
		btr_pcur_commit_specify_mtr(&pcur, &mtr);

		table = dict_load_table(recovery, table_name);

		if (table) {
			ddl_drop_table(table_name, trx, FALSE);
			trx_commit(trx);
		}

		mtr_start(&mtr);
		btr_pcur_restore_position(BTR_SEARCH_LEAF, &pcur, &mtr);
	}

	btr_pcur_close(&pcur);
	mtr_commit(&mtr);
	mem_heap_free(heap);

	dict_unlock_data_dictionary(trx);

	trx_commit(trx);
	trx_free_for_background(trx);
}

