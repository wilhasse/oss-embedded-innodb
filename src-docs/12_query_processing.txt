==================================================================
COMPONENT: QUERY PROCESSING
==================================================================
The query processing layer includes parsing, optimization,
and execution of SQL-like commands.

Key concepts:
- SQL parser (Bison/Yacc based)
- Query graphs and execution plans
- Query optimization
- Stored procedures
- Query execution engine

Files included:
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.
Copyright (c) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004 Free Software
Foundation, Inc.

As a special exception, when this file is copied by Bison into a
Bison output file, you may use that output file without restriction.
This special exception was added by the Free Software Foundation
in version 1.24 of Bison.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/* A Bison parser, made by GNU Bison 1.875d.  */

/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     PARS_INT_LIT = 258,
     PARS_FLOAT_LIT = 259,
     PARS_STR_LIT = 260,
     PARS_FIXBINARY_LIT = 261,
     PARS_BLOB_LIT = 262,
     PARS_NULL_LIT = 263,
     PARS_ID_TOKEN = 264,
     PARS_AND_TOKEN = 265,
     PARS_OR_TOKEN = 266,
     PARS_NOT_TOKEN = 267,
     PARS_GE_TOKEN = 268,
     PARS_LE_TOKEN = 269,
     PARS_NE_TOKEN = 270,
     PARS_PROCEDURE_TOKEN = 271,
     PARS_IN_TOKEN = 272,
     PARS_OUT_TOKEN = 273,
     PARS_BINARY_TOKEN = 274,
     PARS_BLOB_TOKEN = 275,
     PARS_INT_TOKEN = 276,
     PARS_INTEGER_TOKEN = 277,
     PARS_FLOAT_TOKEN = 278,
     PARS_CHAR_TOKEN = 279,
     PARS_IS_TOKEN = 280,
     PARS_BEGIN_TOKEN = 281,
     PARS_END_TOKEN = 282,
     PARS_IF_TOKEN = 283,
     PARS_THEN_TOKEN = 284,
     PARS_ELSE_TOKEN = 285,
     PARS_ELSIF_TOKEN = 286,
     PARS_LOOP_TOKEN = 287,
     PARS_WHILE_TOKEN = 288,
     PARS_RETURN_TOKEN = 289,
     PARS_SELECT_TOKEN = 290,
     PARS_SUM_TOKEN = 291,
     PARS_COUNT_TOKEN = 292,
     PARS_DISTINCT_TOKEN = 293,
     PARS_FROM_TOKEN = 294,
     PARS_WHERE_TOKEN = 295,
     PARS_FOR_TOKEN = 296,
     PARS_DDOT_TOKEN = 297,
     PARS_READ_TOKEN = 298,
     PARS_ORDER_TOKEN = 299,
     PARS_BY_TOKEN = 300,
     PARS_ASC_TOKEN = 301,
     PARS_DESC_TOKEN = 302,
     PARS_INSERT_TOKEN = 303,
     PARS_INTO_TOKEN = 304,
     PARS_VALUES_TOKEN = 305,
     PARS_UPDATE_TOKEN = 306,
     PARS_SET_TOKEN = 307,
     PARS_DELETE_TOKEN = 308,
     PARS_CURRENT_TOKEN = 309,
     PARS_OF_TOKEN = 310,
     PARS_CREATE_TOKEN = 311,
     PARS_TABLE_TOKEN = 312,
     PARS_INDEX_TOKEN = 313,
     PARS_UNIQUE_TOKEN = 314,
     PARS_CLUSTERED_TOKEN = 315,
     PARS_DOES_NOT_FIT_IN_MEM_TOKEN = 316,
     PARS_ON_TOKEN = 317,
     PARS_ASSIGN_TOKEN = 318,
     PARS_DECLARE_TOKEN = 319,
     PARS_CURSOR_TOKEN = 320,
     PARS_SQL_TOKEN = 321,
     PARS_OPEN_TOKEN = 322,
     PARS_FETCH_TOKEN = 323,
     PARS_CLOSE_TOKEN = 324,
     PARS_NOTFOUND_TOKEN = 325,
     PARS_TO_CHAR_TOKEN = 326,
     PARS_TO_NUMBER_TOKEN = 327,
     PARS_TO_BINARY_TOKEN = 328,
     PARS_BINARY_TO_NUMBER_TOKEN = 329,
     PARS_SUBSTR_TOKEN = 330,
     PARS_REPLSTR_TOKEN = 331,
     PARS_CONCAT_TOKEN = 332,
     PARS_INSTR_TOKEN = 333,
     PARS_LENGTH_TOKEN = 334,
     PARS_SYSDATE_TOKEN = 335,
     PARS_PRINTF_TOKEN = 336,
     PARS_ASSERT_TOKEN = 337,
     PARS_RND_TOKEN = 338,
     PARS_RND_STR_TOKEN = 339,
     PARS_ROW_PRINTF_TOKEN = 340,
     PARS_COMMIT_TOKEN = 341,
     PARS_ROLLBACK_TOKEN = 342,
     PARS_WORK_TOKEN = 343,
     PARS_UNSIGNED_TOKEN = 344,
     PARS_EXIT_TOKEN = 345,
     PARS_FUNCTION_TOKEN = 346,
     PARS_LOCK_TOKEN = 347,
     PARS_SHARE_TOKEN = 348,
     PARS_MODE_TOKEN = 349,
     NEG = 350
   };
#endif
/* Tokens.  */
#define PARS_INT_LIT 258
#define PARS_FLOAT_LIT 259
#define PARS_STR_LIT 260
#define PARS_FIXBINARY_LIT 261
#define PARS_BLOB_LIT 262
#define PARS_NULL_LIT 263
#define PARS_ID_TOKEN 264
#define PARS_AND_TOKEN 265
#define PARS_OR_TOKEN 266
#define PARS_NOT_TOKEN 267
#define PARS_GE_TOKEN 268
#define PARS_LE_TOKEN 269
#define PARS_NE_TOKEN 270
#define PARS_PROCEDURE_TOKEN 271
#define PARS_IN_TOKEN 272
#define PARS_OUT_TOKEN 273
#define PARS_BINARY_TOKEN 274
#define PARS_BLOB_TOKEN 275
#define PARS_INT_TOKEN 276
#define PARS_INTEGER_TOKEN 277
#define PARS_FLOAT_TOKEN 278
#define PARS_CHAR_TOKEN 279
#define PARS_IS_TOKEN 280
#define PARS_BEGIN_TOKEN 281
#define PARS_END_TOKEN 282
#define PARS_IF_TOKEN 283
#define PARS_THEN_TOKEN 284
#define PARS_ELSE_TOKEN 285
#define PARS_ELSIF_TOKEN 286
#define PARS_LOOP_TOKEN 287
#define PARS_WHILE_TOKEN 288
#define PARS_RETURN_TOKEN 289
#define PARS_SELECT_TOKEN 290
#define PARS_SUM_TOKEN 291
#define PARS_COUNT_TOKEN 292
#define PARS_DISTINCT_TOKEN 293
#define PARS_FROM_TOKEN 294
#define PARS_WHERE_TOKEN 295
#define PARS_FOR_TOKEN 296
#define PARS_DDOT_TOKEN 297
#define PARS_READ_TOKEN 298
#define PARS_ORDER_TOKEN 299
#define PARS_BY_TOKEN 300
#define PARS_ASC_TOKEN 301
#define PARS_DESC_TOKEN 302
#define PARS_INSERT_TOKEN 303
#define PARS_INTO_TOKEN 304
#define PARS_VALUES_TOKEN 305
#define PARS_UPDATE_TOKEN 306
#define PARS_SET_TOKEN 307
#define PARS_DELETE_TOKEN 308
#define PARS_CURRENT_TOKEN 309
#define PARS_OF_TOKEN 310
#define PARS_CREATE_TOKEN 311
#define PARS_TABLE_TOKEN 312
#define PARS_INDEX_TOKEN 313
#define PARS_UNIQUE_TOKEN 314
#define PARS_CLUSTERED_TOKEN 315
#define PARS_DOES_NOT_FIT_IN_MEM_TOKEN 316
#define PARS_ON_TOKEN 317
#define PARS_ASSIGN_TOKEN 318
#define PARS_DECLARE_TOKEN 319
#define PARS_CURSOR_TOKEN 320
#define PARS_SQL_TOKEN 321
#define PARS_OPEN_TOKEN 322
#define PARS_FETCH_TOKEN 323
#define PARS_CLOSE_TOKEN 324
#define PARS_NOTFOUND_TOKEN 325
#define PARS_TO_CHAR_TOKEN 326
#define PARS_TO_NUMBER_TOKEN 327
#define PARS_TO_BINARY_TOKEN 328
#define PARS_BINARY_TO_NUMBER_TOKEN 329
#define PARS_SUBSTR_TOKEN 330
#define PARS_REPLSTR_TOKEN 331
#define PARS_CONCAT_TOKEN 332
#define PARS_INSTR_TOKEN 333
#define PARS_LENGTH_TOKEN 334
#define PARS_SYSDATE_TOKEN 335
#define PARS_PRINTF_TOKEN 336
#define PARS_ASSERT_TOKEN 337
#define PARS_RND_TOKEN 338
#define PARS_RND_STR_TOKEN 339
#define PARS_ROW_PRINTF_TOKEN 340
#define PARS_COMMIT_TOKEN 341
#define PARS_ROLLBACK_TOKEN 342
#define PARS_WORK_TOKEN 343
#define PARS_UNSIGNED_TOKEN 344
#define PARS_EXIT_TOKEN 345
#define PARS_FUNCTION_TOKEN 346
#define PARS_LOCK_TOKEN 347
#define PARS_SHARE_TOKEN 348
#define PARS_MODE_TOKEN 349
#define NEG 350




#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
# define YYSTYPE_IS_TRIVIAL 1
#endif

extern YYSTYPE yylval;

/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0opt.h
Simple SQL optimizer

Created 12/21/1997 Heikki Tuuri
*******************************************************/

#ifndef pars0opt_h
#define pars0opt_h

#include "univ.i"
#include "que0types.h"
#include "usr0types.h"
#include "pars0sym.h"
#include "dict0types.h"
#include "row0sel.h"

/*******************************************************************//**
Optimizes a select. Decides which indexes to tables to use. The tables
are accessed in the order that they were written to the FROM part in the
select statement. */
UNIV_INTERN
void
opt_search_plan(
/*============*/
	sel_node_t*	sel_node);	/*!< in: parsed select node */
/*******************************************************************//**
Looks for occurrences of the columns of the table in the query subgraph and
adds them to the list of columns if an occurrence of the same column does not
already exist in the list. If the column is already in the list, puts a value
indirection to point to the occurrence in the column list, except if the
column occurrence we are looking at is in the column list, in which case
nothing is done. */
UNIV_INTERN
void
opt_find_all_cols(
/*==============*/
	ibool		copy_val,	/*!< in: if TRUE, new found columns are
					added as columns to copy */
	dict_index_t*	index,		/*!< in: index to use */
	sym_node_list_t* col_list,	/*!< in: base node of a list where
					to add new found columns */
	plan_t*		plan,		/*!< in: plan or NULL */
	que_node_t*	exp);		/*!< in: expression or condition */
/********************************************************************//**
Prints info of a query plan. */
UNIV_INTERN
void
opt_print_query_plan(
/*=================*/
	sel_node_t*	sel_node);	/*!< in: select node */

#ifndef UNIV_NONINL
#include "pars0opt.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0pars.h
SQL parser

Created 11/19/1996 Heikki Tuuri
*******************************************************/

#ifndef pars0pars_h
#define pars0pars_h

#include "univ.i"
#include "que0types.h"
#include "usr0types.h"
#include "pars0types.h"
#include "row0types.h"
#include "trx0types.h"
#include "ut0vec.h"

/** Type of the user functions. The first argument is always InnoDB-supplied
and varies in type, while 'user_arg' is a user-supplied argument. The
meaning of the return type also varies. See the individual use cases, e.g.
the FETCH statement, for details on them. */
typedef void* (*pars_user_func_cb_t)(void* arg, void* user_arg);

/** If the following is set TRUE, the parser will emit debugging
information */
extern int	yydebug;

#ifdef UNIV_SQL_DEBUG
/** If the following is set TRUE, the lexer will print the SQL string
as it tokenizes it */
extern ibool	pars_print_lexed;
#endif /* UNIV_SQL_DEBUG */

/* Global variable used while parsing a single procedure or query : the code is
NOT re-entrant */
extern sym_tab_t*	pars_sym_tab_global;

extern pars_res_word_t	pars_to_char_token;
extern pars_res_word_t	pars_to_number_token;
extern pars_res_word_t	pars_to_binary_token;
extern pars_res_word_t	pars_binary_to_number_token;
extern pars_res_word_t	pars_substr_token;
extern pars_res_word_t	pars_replstr_token;
extern pars_res_word_t	pars_concat_token;
extern pars_res_word_t	pars_length_token;
extern pars_res_word_t	pars_instr_token;
extern pars_res_word_t	pars_sysdate_token;
extern pars_res_word_t	pars_printf_token;
extern pars_res_word_t	pars_assert_token;
extern pars_res_word_t	pars_rnd_token;
extern pars_res_word_t	pars_rnd_str_token;
extern pars_res_word_t	pars_count_token;
extern pars_res_word_t	pars_sum_token;
extern pars_res_word_t	pars_distinct_token;
extern pars_res_word_t	pars_binary_token;
extern pars_res_word_t	pars_blob_token;
extern pars_res_word_t	pars_int_token;
extern pars_res_word_t	pars_char_token;
extern pars_res_word_t	pars_float_token;
extern pars_res_word_t	pars_update_token;
extern pars_res_word_t	pars_asc_token;
extern pars_res_word_t	pars_desc_token;
extern pars_res_word_t	pars_open_token;
extern pars_res_word_t	pars_close_token;
extern pars_res_word_t	pars_share_token;
extern pars_res_word_t	pars_unique_token;
extern pars_res_word_t	pars_clustered_token;

extern ulint		pars_star_denoter;

/* Procedure parameter types */
#define PARS_INPUT	0
#define PARS_OUTPUT	1
#define PARS_NOT_PARAM	2

int
yyparse(void);

/*************************************************************//**
Parses an SQL string returning the query graph.
@return	own: the query graph */
UNIV_INTERN
que_t*
pars_sql(
/*=====*/
	pars_info_t*	info,	/*!< in: extra information, or NULL */
	const char*	str);	/*!< in: SQL string */
/*************************************************************//**
Retrieves characters to the lexical analyzer. */
UNIV_INTERN
void
pars_get_lex_chars(
/*===============*/
	char*	buf,		/*!< in/out: buffer where to copy */
	int*	result,		/*!< out: number of characters copied or EOF */
	int	max_size);	/*!< in: maximum number of characters which fit
				in the buffer */
/*************************************************************//**
Called by yyparse on error. */
UNIV_INTERN
void
yyerror(
/*====*/
	const char*	s);	/*!< in: error message string */
/*********************************************************************//**
Parses a variable declaration.
@return	own: symbol table node of type SYM_VAR */
UNIV_INTERN
sym_node_t*
pars_variable_declaration(
/*======================*/
	sym_node_t*	node,	/*!< in: symbol table node allocated for the
				id of the variable */
	pars_res_word_t* type);	/*!< in: pointer to a type token */
/*********************************************************************//**
Parses a function expression.
@return	own: function node in a query tree */
UNIV_INTERN
func_node_t*
pars_func(
/*======*/
	que_node_t*	res_word,/*!< in: function name reserved word */
	que_node_t*	arg);	/*!< in: first argument in the argument list */
/*********************************************************************//**
Parses an operator expression.
@return	own: function node in a query tree */
UNIV_INTERN
func_node_t*
pars_op(
/*====*/
	int		func,	/*!< in: operator token code */
	que_node_t*	arg1,	/*!< in: first argument */
	que_node_t*	arg2);	/*!< in: second argument or NULL for an unary
				operator */
/*********************************************************************//**
Parses an ORDER BY clause. Order by a single column only is supported.
@return	own: order-by node in a query tree */
UNIV_INTERN
order_node_t*
pars_order_by(
/*==========*/
	sym_node_t*	column,	/*!< in: column name */
	pars_res_word_t* asc);	/*!< in: &pars_asc_token or pars_desc_token */
/*********************************************************************//**
Parses a select list; creates a query graph node for the whole SELECT
statement.
@return	own: select node in a query tree */
UNIV_INTERN
sel_node_t*
pars_select_list(
/*=============*/
	que_node_t*	select_list,	/*!< in: select list */
	sym_node_t*	into_list);	/*!< in: variables list or NULL */
/*********************************************************************//**
Parses a cursor declaration.
@return	sym_node */
UNIV_INTERN
que_node_t*
pars_cursor_declaration(
/*====================*/
	sym_node_t*	sym_node,	/*!< in: cursor id node in the symbol
					table */
	sel_node_t*	select_node);	/*!< in: select node */
/*********************************************************************//**
Parses a function declaration.
@return	sym_node */
UNIV_INTERN
que_node_t*
pars_function_declaration(
/*======================*/
	sym_node_t*	sym_node);	/*!< in: function id node in the symbol
					table */
/*********************************************************************//**
Parses a select statement.
@return	own: select node in a query tree */
UNIV_INTERN
sel_node_t*
pars_select_statement(
/*==================*/
	sel_node_t*	select_node,	/*!< in: select node already containing
					the select list */
	sym_node_t*	table_list,	/*!< in: table list */
	que_node_t*	search_cond,	/*!< in: search condition or NULL */
	pars_res_word_t* for_update,	/*!< in: NULL or &pars_update_token */
	pars_res_word_t* consistent_read,/*!< in: NULL or
						&pars_consistent_token */
	order_node_t*	order_by);	/*!< in: NULL or an order-by node */
/*********************************************************************//**
Parses a column assignment in an update.
@return	column assignment node */
UNIV_INTERN
col_assign_node_t*
pars_column_assignment(
/*===================*/
	sym_node_t*	column,	/*!< in: column to assign */
	que_node_t*	exp);	/*!< in: value to assign */
/*********************************************************************//**
Parses a delete or update statement start.
@return	own: update node in a query tree */
UNIV_INTERN
upd_node_t*
pars_update_statement_start(
/*========================*/
	ibool		is_delete,	/*!< in: TRUE if delete */
	sym_node_t*	table_sym,	/*!< in: table name node */
	col_assign_node_t* col_assign_list);/*!< in: column assignment list, NULL
					if delete */
/*********************************************************************//**
Parses an update or delete statement.
@return	own: update node in a query tree */
UNIV_INTERN
upd_node_t*
pars_update_statement(
/*==================*/
	upd_node_t*	node,		/*!< in: update node */
	sym_node_t*	cursor_sym,	/*!< in: pointer to a cursor entry in
					the symbol table or NULL */
	que_node_t*	search_cond);	/*!< in: search condition or NULL */
/*********************************************************************//**
Parses an insert statement.
@return	own: update node in a query tree */
UNIV_INTERN
ins_node_t*
pars_insert_statement(
/*==================*/
	sym_node_t*	table_sym,	/*!< in: table name node */
	que_node_t*	values_list,	/*!< in: value expression list or NULL */
	sel_node_t*	select);	/*!< in: select condition or NULL */
/*********************************************************************//**
Parses a procedure parameter declaration.
@return	own: symbol table node of type SYM_VAR */
UNIV_INTERN
sym_node_t*
pars_parameter_declaration(
/*=======================*/
	sym_node_t*	node,	/*!< in: symbol table node allocated for the
				id of the parameter */
	ulint		param_type,
				/*!< in: PARS_INPUT or PARS_OUTPUT */
	pars_res_word_t* type);	/*!< in: pointer to a type token */
/*********************************************************************//**
Parses an elsif element.
@return	elsif node */
UNIV_INTERN
elsif_node_t*
pars_elsif_element(
/*===============*/
	que_node_t*	cond,		/*!< in: if-condition */
	que_node_t*	stat_list);	/*!< in: statement list */
/*********************************************************************//**
Parses an if-statement.
@return	if-statement node */
UNIV_INTERN
if_node_t*
pars_if_statement(
/*==============*/
	que_node_t*	cond,		/*!< in: if-condition */
	que_node_t*	stat_list,	/*!< in: statement list */
	que_node_t*	else_part);	/*!< in: else-part statement list */
/*********************************************************************//**
Parses a for-loop-statement.
@return	for-statement node */
UNIV_INTERN
for_node_t*
pars_for_statement(
/*===============*/
	sym_node_t*	loop_var,	/*!< in: loop variable */
	que_node_t*	loop_start_limit,/*!< in: loop start expression */
	que_node_t*	loop_end_limit,	/*!< in: loop end expression */
	que_node_t*	stat_list);	/*!< in: statement list */
/*********************************************************************//**
Parses a while-statement.
@return	while-statement node */
UNIV_INTERN
while_node_t*
pars_while_statement(
/*=================*/
	que_node_t*	cond,		/*!< in: while-condition */
	que_node_t*	stat_list);	/*!< in: statement list */
/*********************************************************************//**
Parses an exit statement.
@return	exit statement node */
UNIV_INTERN
exit_node_t*
pars_exit_statement(void);
/*=====================*/
/*********************************************************************//**
Parses a return-statement.
@return	return-statement node */
UNIV_INTERN
return_node_t*
pars_return_statement(void);
/*=======================*/
/*********************************************************************//**
Parses a procedure call.
@return	function node */
UNIV_INTERN
func_node_t*
pars_procedure_call(
/*================*/
	que_node_t*	res_word,/*!< in: procedure name reserved word */
	que_node_t*	args);	/*!< in: argument list */
/*********************************************************************//**
Parses an assignment statement.
@return	assignment statement node */
UNIV_INTERN
assign_node_t*
pars_assignment_statement(
/*======================*/
	sym_node_t*	var,	/*!< in: variable to assign */
	que_node_t*	val);	/*!< in: value to assign */
/*********************************************************************//**
Parses a fetch statement. into_list or user_func (but not both) must be
non-NULL.
@return	fetch statement node */
UNIV_INTERN
fetch_node_t*
pars_fetch_statement(
/*=================*/
	sym_node_t*	cursor,		/*!< in: cursor node */
	sym_node_t*	into_list,	/*!< in: variables to set, or NULL */
	sym_node_t*	user_func);	/*!< in: user function name, or NULL */
/*********************************************************************//**
Parses an open or close cursor statement.
@return	fetch statement node */
UNIV_INTERN
open_node_t*
pars_open_statement(
/*================*/
	ulint		type,	/*!< in: ROW_SEL_OPEN_CURSOR
				or ROW_SEL_CLOSE_CURSOR */
	sym_node_t*	cursor);	/*!< in: cursor node */
/*********************************************************************//**
Parses a row_printf-statement.
@return	row_printf-statement node */
UNIV_INTERN
row_printf_node_t*
pars_row_printf_statement(
/*======================*/
	sel_node_t*	sel_node);	/*!< in: select node */
/*********************************************************************//**
Parses a commit statement.
@return	own: commit node struct */
UNIV_INTERN
commit_node_t*
pars_commit_statement(void);
/*=======================*/
/*********************************************************************//**
Parses a rollback statement.
@return	own: rollback node struct */
UNIV_INTERN
roll_node_t*
pars_rollback_statement(void);
/*=========================*/
/*********************************************************************//**
Parses a column definition at a table creation.
@return	column sym table node */
UNIV_INTERN
sym_node_t*
pars_column_def(
/*============*/
	sym_node_t*		sym_node,	/*!< in: column node in the
						symbol table */
	pars_res_word_t*	type,		/*!< in: data type */
	sym_node_t*		len,		/*!< in: length of column, or
						NULL */
	void*			is_unsigned,	/*!< in: if not NULL, column
						is of type UNSIGNED. */
	void*			is_not_null);	/*!< in: if not NULL, column
						is of type NOT NULL. */
/*********************************************************************//**
Parses a table creation operation.
@return	table create subgraph */
UNIV_INTERN
tab_node_t*
pars_create_table(
/*==============*/
	sym_node_t*	table_sym,	/*!< in: table name node in the symbol
					table */
	sym_node_t*	column_defs,	/*!< in: list of column names */
	void*		not_fit_in_memory);/*!< in: a non-NULL pointer means that
					this is a table which in simulations
					should be simulated as not fitting
					in memory; thread is put to sleep
					to simulate disk accesses; NOTE that
					this flag is not stored to the data
					dictionary on disk, and the database
					will forget about non-NULL value if
					it has to reload the table definition
					from disk */
/*********************************************************************//**
Parses an index creation operation.
@return	index create subgraph */
UNIV_INTERN
ind_node_t*
pars_create_index(
/*==============*/
	pars_res_word_t* unique_def,	/*!< in: not NULL if a unique index */
	pars_res_word_t* clustered_def,	/*!< in: not NULL if a clustered index */
	sym_node_t*	index_sym,	/*!< in: index name node in the symbol
					table */
	sym_node_t*	table_sym,	/*!< in: table name node in the symbol
					table */
	sym_node_t*	column_list);	/*!< in: list of column names */
/*********************************************************************//**
Parses a procedure definition.
@return	query fork node */
UNIV_INTERN
que_fork_t*
pars_procedure_definition(
/*======================*/
	sym_node_t*	sym_node,	/*!< in: procedure id node in the symbol
					table */
	sym_node_t*	param_list,	/*!< in: parameter declaration list */
	que_node_t*	stat_list);	/*!< in: statement list */

/*************************************************************//**
Parses a stored procedure call, when this is not within another stored
procedure, that is, the client issues a procedure call directly.
In InnoDB, stored InnoDB procedures are invoked via the
parsed procedure tree, not via InnoDB SQL, so this function is not used.
@return	query graph */
UNIV_INTERN
que_fork_t*
pars_stored_procedure_call(
/*=======================*/
	sym_node_t*	sym_node);	/*!< in: stored procedure name */
/******************************************************************//**
Completes a query graph by adding query thread and fork nodes
above it and prepares the graph for running. The fork created is of
type QUE_FORK_USER_INTERFACE.
@return	query thread node to run */
UNIV_INTERN
que_thr_t*
pars_complete_graph_for_exec(
/*=========================*/
	que_node_t*	node,	/*!< in: root node for an incomplete
				query graph */
	trx_t*		trx,	/*!< in: transaction handle */
	mem_heap_t*	heap);	/*!< in: memory heap from which allocated */

/****************************************************************//**
Create parser info struct.
@return	own: info struct */
UNIV_INTERN
pars_info_t*
pars_info_create(void);
/*==================*/

/****************************************************************//**
Free info struct and everything it contains. */
UNIV_INTERN
void
pars_info_free(
/*===========*/
	pars_info_t*	info);	/*!< in, own: info struct */

/****************************************************************//**
Add bound literal. */
UNIV_INTERN
void
pars_info_add_literal(
/*==================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	const void*	address,	/*!< in: address */
	ulint		length,		/*!< in: length of data */
	ulint		type,		/*!< in: type, e.g. DATA_FIXBINARY */
	ulint		prtype);	/*!< in: precise type, e.g.
					DATA_UNSIGNED */

/****************************************************************//**
Equivalent to pars_info_add_literal(info, name, str, strlen(str),
DATA_VARCHAR, DATA_ENGLISH). */
UNIV_INTERN
void
pars_info_add_str_literal(
/*======================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	const char*	str);		/*!< in: string */

/****************************************************************//**
Equivalent to:

char buf[4];
mach_write_to_4(buf, val);
pars_info_add_literal(info, name, buf, 4, DATA_INT, 0);

except that the buffer is dynamically allocated from the info struct's
heap. */
UNIV_INTERN
void
pars_info_add_int4_literal(
/*=======================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	lint		val);		/*!< in: value */

/****************************************************************//**
Equivalent to:

char buf[8];
mach_write_ull(buf, val);
pars_info_add_literal(info, name, buf, 8, DATA_INT, 0);

except that the buffer is dynamically allocated from the info struct's
heap. */
UNIV_INTERN
void
pars_info_add_int8_literal(
/*=======================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	ib_uint64_t	val);		/*!< in: value */

/********************************************************************
Equivalent to:

char buf[8];
mach_write_to_8(buf, val);
pars_info_add_literal(info, name, buf, 8, DATA_BINARY, 0);

except that the buffer is dynamically allocated from the info struct's
heap. */
UNIV_INTERN
void
pars_info_add_dulint_literal(
/*=========================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	dulint		val);		/*!< in: value */
/****************************************************************//**
Add user function. */
UNIV_INTERN
void
pars_info_add_function(
/*===================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name,	/*!< in: function name */
	pars_user_func_cb_t	func,	/*!< in: function address */
	void*			arg);	/*!< in: user-supplied argument */

/****************************************************************//**
Add bound id. */
UNIV_INTERN
void
pars_info_add_id(
/*=============*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	const char*	id);		/*!< in: id */

/****************************************************************//**
Get user function with the given name.
@return	user func, or NULL if not found */
UNIV_INTERN
pars_user_func_t*
pars_info_get_user_func(
/*====================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name);	/*!< in: function name to find*/

/****************************************************************//**
Get bound literal with the given name.
@return	bound literal, or NULL if not found */
UNIV_INTERN
pars_bound_lit_t*
pars_info_get_bound_lit(
/*====================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name);	/*!< in: bound literal name to find */

/****************************************************************//**
Get bound id with the given name.
@return	bound id, or NULL if not found */
UNIV_INTERN
pars_bound_id_t*
pars_info_get_bound_id(
/*===================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name);	/*!< in: bound id name to find */

/**********************************************************************
Release any resources used by the parser and lexer. */
UNIV_INTERN
void
pars_close(void);
/*=============*/

/***********************************************************************//**
Reset and check parser variables. */
UNIV_INTERN
void
pars_var_init(void);
/*===============*/

/***********************************************************************//**
Reset the lexing variables. */
UNIV_INTERN
void
pars_lexer_var_init(void);
/*=====================*/

/********************************************************************//**
Release any resources used by the lexer. */
UNIV_INTERN
void
pars_lexer_close(void);
/*==================*/

/** Extra information supplied for pars_sql(). */
struct pars_info_struct {
	mem_heap_t*	heap;		/*!< our own memory heap */

	ib_vector_t*	funcs;		/*!< user functions, or NUll
					(pars_user_func_t*) */
	ib_vector_t*	bound_lits;	/*!< bound literals, or NULL
					(pars_bound_lit_t*) */
	ib_vector_t*	bound_ids;	/*!< bound ids, or NULL
					(pars_bound_id_t*) */

	ibool		graph_owns_us;	/*!< if TRUE (which is the default),
					que_graph_free() will free us */
};

/** User-supplied function and argument. */
struct pars_user_func_struct {
	const char*		name;	/*!< function name */
	pars_user_func_cb_t	func;	/*!< function address */
	void*			arg;	/*!< user-supplied argument */
};

/** Bound literal. */
struct pars_bound_lit_struct {
	const char*	name;		/*!< name */
	const void*	address;	/*!< address */
	ulint		length;		/*!< length of data */
	ulint		type;		/*!< type, e.g. DATA_FIXBINARY */
	ulint		prtype;		/*!< precise type, e.g. DATA_UNSIGNED */
};

/** Bound identifier. */
struct pars_bound_id_struct {
	const char*	name;		/*!< name */
	const char*	id;		/*!< identifier */
};

/** Struct used to denote a reserved word in a parsing tree */
struct pars_res_word_struct{
	int	code;	/*!< the token code for the reserved word from
			pars0grm.h */
};

/** A predefined function or operator node in a parsing tree; this construct
is also used for some non-functions like the assignment ':=' */
struct func_node_struct{
	que_common_t	common;	/*!< type: QUE_NODE_FUNC */
	int		func;	/*!< token code of the function name */
	ulint		class;	/*!< class of the function */
	que_node_t*	args;	/*!< argument(s) of the function */
	UT_LIST_NODE_T(func_node_t) cond_list;
				/*!< list of comparison conditions; defined
				only for comparison operator nodes except,
				presently, for OPT_SCROLL_TYPE ones */
	UT_LIST_NODE_T(func_node_t) func_node_list;
				/*!< list of function nodes in a parsed
				query graph */
};

/** An order-by node in a select */
struct order_node_struct{
	que_common_t	common;	/*!< type: QUE_NODE_ORDER */
	sym_node_t*	column;	/*!< order-by column */
	ibool		asc;	/*!< TRUE if ascending, FALSE if descending */
};

/** Procedure definition node */
struct proc_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_PROC */
	sym_node_t*	proc_id;	/*!< procedure name symbol in the symbol
					table of this same procedure */
	sym_node_t*	param_list;	/*!< input and output parameters */
	que_node_t*	stat_list;	/*!< statement list */
	sym_tab_t*	sym_tab;	/*!< symbol table of this procedure */
};

/** elsif-element node */
struct elsif_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_ELSIF */
	que_node_t*	cond;		/*!< if condition */
	que_node_t*	stat_list;	/*!< statement list */
};

/** if-statement node */
struct if_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_IF */
	que_node_t*	cond;		/*!< if condition */
	que_node_t*	stat_list;	/*!< statement list */
	que_node_t*	else_part;	/*!< else-part statement list */
	elsif_node_t*	elsif_list;	/*!< elsif element list */
};

/** while-statement node */
struct while_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_WHILE */
	que_node_t*	cond;		/*!< while condition */
	que_node_t*	stat_list;	/*!< statement list */
};

/** for-loop-statement node */
struct for_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_FOR */
	sym_node_t*	loop_var;	/*!< loop variable: this is the
					dereferenced symbol from the
					variable declarations, not the
					symbol occurrence in the for loop
					definition */
	que_node_t*	loop_start_limit;/*!< initial value of loop variable */
	que_node_t*	loop_end_limit;	/*!< end value of loop variable */
	lint		loop_end_value;	/*!< evaluated value for the end value:
					it is calculated only when the loop
					is entered, and will not change within
					the loop */
	que_node_t*	stat_list;	/*!< statement list */
};

/** exit statement node */
struct exit_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_EXIT */
};

/** return-statement node */
struct return_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_RETURN */
};

/** Assignment statement node */
struct assign_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_ASSIGNMENT */
	sym_node_t*	var;		/*!< variable to set */
	que_node_t*	val;		/*!< value to assign */
};

/** Column assignment node */
struct col_assign_node_struct{
	que_common_t	common;		/*!< type: QUE_NODE_COL_ASSIGN */
	sym_node_t*	col;		/*!< column to set */
	que_node_t*	val;		/*!< value to assign */
};

/** Classes of functions */
/* @{ */
#define PARS_FUNC_ARITH		1	/*!< +, -, *, / */
#define	PARS_FUNC_LOGICAL	2	/*!< AND, OR, NOT */
#define PARS_FUNC_CMP		3	/*!< comparison operators */
#define	PARS_FUNC_PREDEFINED	4	/*!< TO_NUMBER, SUBSTR, ... */
#define	PARS_FUNC_AGGREGATE	5	/*!< COUNT, DISTINCT, SUM */
#define	PARS_FUNC_OTHER		6	/*!< these are not real functions,
					e.g., := */
/* @} */

#ifndef UNIV_NONINL
#include "pars0pars.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0sym.h
SQL parser symbol table

Created 12/15/1997 Heikki Tuuri
*******************************************************/

#ifndef pars0sym_h
#define pars0sym_h

#include "univ.i"
#include "que0types.h"
#include "usr0types.h"
#include "dict0types.h"
#include "pars0types.h"
#include "row0types.h"

/******************************************************************//**
Creates a symbol table for a single stored procedure or query.
@return	own: symbol table */
UNIV_INTERN
sym_tab_t*
sym_tab_create(
/*===========*/
	mem_heap_t*	heap);	/*!< in: memory heap where to create */
/******************************************************************//**
Frees the memory allocated dynamically AFTER parsing phase for variables
etc. in the symbol table. Does not free the mem heap where the table was
originally created. Frees also SQL explicit cursor definitions. */
UNIV_INTERN
void
sym_tab_free_private(
/*=================*/
	sym_tab_t*	sym_tab);	/*!< in, own: symbol table */
/******************************************************************//**
Adds an integer literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_int_lit(
/*================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	ulint		val);		/*!< in: integer value */
/******************************************************************//**
Adds an string literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_str_lit(
/*================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	byte*		str,		/*!< in: string with no quotes around
					it */
	ulint		len);		/*!< in: string length */
/******************************************************************//**
Add a bound literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_bound_lit(
/*==================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	const char*	name,		/*!< in: name of bound literal */
	ulint*		lit_type);	/*!< out: type of literal (PARS_*_LIT) */
/******************************************************************//**
Adds an SQL null literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_null_lit(
/*=================*/
	sym_tab_t*	sym_tab);	/*!< in: symbol table */
/******************************************************************//**
Adds an identifier to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_id(
/*===========*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	byte*		name,		/*!< in: identifier name */
	ulint		len);		/*!< in: identifier length */

/******************************************************************//**
Add a bound identifier to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_bound_id(
/*===========*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	const char*	name);		/*!< in: name of bound id */

/** Index of sym_node_struct::field_nos corresponding to the clustered index */
#define	SYM_CLUST_FIELD_NO	0
/** Index of sym_node_struct::field_nos corresponding to a secondary index */
#define	SYM_SEC_FIELD_NO	1

/** Types of a symbol table node */
enum sym_tab_entry {
	SYM_VAR = 91,		/*!< declared parameter or local
				variable of a procedure */
	SYM_IMPLICIT_VAR,	/*!< storage for a intermediate result
				of a calculation */
	SYM_LIT,		/*!< literal */
	SYM_TABLE,		/*!< database table name */
	SYM_COLUMN,		/*!< database table name */
	SYM_CURSOR,		/*!< named cursor */
	SYM_PROCEDURE_NAME,	/*!< stored procedure name */
	SYM_INDEX,		/*!< database index name */
	SYM_FUNCTION		/*!< user function name */
};

/** Symbol table node */
struct sym_node_struct{
	que_common_t			common;		/*!< node type:
							QUE_NODE_SYMBOL */
	/* NOTE: if the data field in 'common.val' is not NULL and the symbol
	table node is not for a temporary column, the memory for the value has
	been allocated from dynamic memory and it should be freed when the
	symbol table is discarded */

	/* 'alias' and 'indirection' are almost the same, but not quite.
	'alias' always points to the primary instance of the variable, while
	'indirection' does the same only if we should use the primary
	instance's values for the node's data. This is usually the case, but
	when initializing a cursor (e.g., "DECLARE CURSOR c IS SELECT * FROM
	t WHERE id = x;"), we copy the values from the primary instance to
	the cursor's instance so that they are fixed for the duration of the
	cursor, and set 'indirection' to NULL. If we did not, the value of
	'x' could change between fetches and things would break horribly.

	TODO: It would be cleaner to make 'indirection' a boolean field and
	always use 'alias' to refer to the primary node. */

	sym_node_t*			indirection;	/*!< pointer to
							another symbol table
							node which contains
							the value for this
							node, NULL otherwise */
	sym_node_t*			alias;		/*!< pointer to
							another symbol table
							node for which this
							node is an alias,
							NULL otherwise */
	UT_LIST_NODE_T(sym_node_t)	col_var_list;	/*!< list of table
							columns or a list of
							input variables for an
							explicit cursor */
	ibool				copy_val;	/*!< TRUE if a column
							and its value should
							be copied to dynamic
							memory when fetched */
	ulint				field_nos[2];	/*!< if a column, in
							the position
							SYM_CLUST_FIELD_NO is
							the field number in the
							clustered index; in
							the position
							SYM_SEC_FIELD_NO
							the field number in the
							non-clustered index to
							use first; if not found
							from the index, then
							ULINT_UNDEFINED */
	ibool				resolved;	/*!< TRUE if the
							meaning of a variable
							or a column has been
							resolved; for literals
							this is always TRUE */
	enum sym_tab_entry		token_type;	/*!< type of the
							parsed token */
	const char*			name;		/*!< name of an id */
	ulint				name_len;	/*!< id name length */
	dict_table_t*			table;		/*!< table definition
							if a table id or a
							column id */
	ulint				col_no;		/*!< column number if a
							column */
	sel_buf_t*			prefetch_buf;	/*!< NULL, or a buffer
							for cached column
							values for prefetched
							rows */
	sel_node_t*			cursor_def;	/*!< cursor definition
							select node if a
							named cursor */
	ulint				param_type;	/*!< PARS_INPUT,
							PARS_OUTPUT, or
							PARS_NOT_PARAM if not a
							procedure parameter */
	sym_tab_t*			sym_table;	/*!< back pointer to
							the symbol table */
	UT_LIST_NODE_T(sym_node_t)	sym_list;	/*!< list of symbol
							nodes */
};

/** Symbol table */
struct sym_tab_struct{
	que_t*			query_graph;
					/*!< query graph generated by the
					parser */
	const char*		sql_string;
					/*!< SQL string to parse */
	size_t			string_len;
					/*!< SQL string length */
	int			next_char_pos;
					/*!< position of the next character in
					sql_string to give to the lexical
					analyzer */
	pars_info_t*		info;	/*!< extra information, or NULL */
	sym_node_list_t		sym_list;
					/*!< list of symbol nodes in the symbol
					table */
	UT_LIST_BASE_NODE_T(func_node_t)
				func_node_list;
					/*!< list of function nodes in the
					parsed query graph */
	mem_heap_t*		heap;	/*!< memory heap from which we can
					allocate space */
};

#ifndef UNIV_NONINL
#include "pars0sym.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1998, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0types.h
SQL parser global types

Created 1/11/1998 Heikki Tuuri
*******************************************************/

#ifndef pars0types_h
#define pars0types_h

typedef struct pars_info_struct		pars_info_t;
typedef struct pars_user_func_struct	pars_user_func_t;
typedef struct pars_bound_lit_struct	pars_bound_lit_t;
typedef struct pars_bound_id_struct	pars_bound_id_t;
typedef struct sym_node_struct		sym_node_t;
typedef struct sym_tab_struct		sym_tab_t;
typedef struct pars_res_word_struct	pars_res_word_t;
typedef struct func_node_struct		func_node_t;
typedef struct order_node_struct	order_node_t;
typedef struct proc_node_struct		proc_node_t;
typedef struct elsif_node_struct	elsif_node_t;
typedef struct if_node_struct		if_node_t;
typedef struct while_node_struct	while_node_t;
typedef struct for_node_struct		for_node_t;
typedef struct exit_node_struct		exit_node_t;
typedef struct return_node_struct	return_node_t;
typedef struct assign_node_struct	assign_node_t;
typedef struct col_assign_node_struct	col_assign_node_t;

typedef UT_LIST_BASE_NODE_T(sym_node_t)	sym_node_list_t;

#endif
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0opt.ic
Simple SQL optimizer

Created 12/21/1997 Heikki Tuuri
*******************************************************/
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0pars.ic
SQL parser

Created 11/19/1996 Heikki Tuuri
*******************************************************/
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/pars0sym.ic
SQL parser symbol table

Created 12/15/1997 Heikki Tuuri
*******************************************************/
/*****************************************************************************

Copyright (c) 1996, 2010, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/que0que.h
Query graph

Created 5/27/1996 Heikki Tuuri
*******************************************************/

#ifndef que0que_h
#define que0que_h

#include "univ.i"
#include "data0data.h"
#include "dict0types.h"
#include "trx0trx.h"
#include "trx0roll.h"
#include "srv0srv.h"
#include "usr0types.h"
#include "que0types.h"
#include "row0types.h"
#include "pars0types.h"

/* If the following flag is set TRUE, the module will print trace info
of SQL execution in the UNIV_SQL_DEBUG version */
extern ibool	que_trace_on;

/***********************************************************************//**
Adds a query graph to the session's list of graphs. */
UNIV_INTERN
void
que_graph_publish(
/*==============*/
	que_t*	graph,	/*!< in: graph */
	sess_t*	sess);	/*!< in: session */
/***********************************************************************//**
Creates a query graph fork node.
@return	own: fork node */
UNIV_INTERN
que_fork_t*
que_fork_create(
/*============*/
	que_t*		graph,		/*!< in: graph, if NULL then this
					fork node is assumed to be the
					graph root */
	que_node_t*	parent,		/*!< in: parent node */
	ulint		fork_type,	/*!< in: fork type */
	mem_heap_t*	heap);		/*!< in: memory heap where created */
/***********************************************************************//**
Gets the first thr in a fork. */
UNIV_INLINE
que_thr_t*
que_fork_get_first_thr(
/*===================*/
	que_fork_t*	fork);	/*!< in: query fork */
/***********************************************************************//**
Gets the child node of the first thr in a fork. */
UNIV_INLINE
que_node_t*
que_fork_get_child(
/*===============*/
	que_fork_t*	fork);	/*!< in: query fork */
/***********************************************************************//**
Sets the parent of a graph node. */
UNIV_INLINE
void
que_node_set_parent(
/*================*/
	que_node_t*	node,	/*!< in: graph node */
	que_node_t*	parent);/*!< in: parent */
/***********************************************************************//**
Creates a query graph thread node.
@return	own: query thread node */
UNIV_INTERN
que_thr_t*
que_thr_create(
/*===========*/
	que_fork_t*	parent,	/*!< in: parent node, i.e., a fork node */
	mem_heap_t*	heap);	/*!< in: memory heap where created */
/**********************************************************************//**
Frees a query graph, but not the heap where it was created. Does not free
explicit cursor declarations, they are freed in que_graph_free. */
UNIV_INTERN
void
que_graph_free_recursive(
/*=====================*/
	que_node_t*	node);	/*!< in: query graph node */
/**********************************************************************//**
Frees a query graph. */
UNIV_INTERN
void
que_graph_free(
/*===========*/
	que_t*	graph);	/*!< in: query graph; we assume that the memory
			heap where this graph was created is private
			to this graph: if not, then use
			que_graph_free_recursive and free the heap
			afterwards! */
/**********************************************************************//**
Stops a query thread if graph or trx is in a state requiring it. The
conditions are tested in the order (1) graph, (2) trx. The kernel mutex has
to be reserved.
@return	TRUE if stopped */
UNIV_INTERN
ibool
que_thr_stop(
/*=========*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Moves a thread from another state to the QUE_THR_RUNNING state. Increments
the n_active_thrs counters of the query graph and transaction if thr was
not active. */
UNIV_INTERN
void
que_thr_move_to_run_state_for_client(
/*=================================*/
	que_thr_t*	thr,	/*!< in: an query thread */
	trx_t*		trx);	/*!< in: transaction */
/**********************************************************************//**
The query thread is stopped and made inactive, except in the case where
it was put to the lock wait state in lock0lock.c, but the lock has already
been granted or the transaction chosen as a victim in deadlock resolution. */
UNIV_INTERN
void
que_thr_stop_client(
/*================*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Run a query thread. Handles lock waits. */
UNIV_INTERN
void
que_run_threads(
/*============*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
After signal handling is finished, returns control to a query graph error
handling routine. (Currently, just returns the control to the root of the
graph so that the graph can communicate an error message to the client.) */
UNIV_INTERN
void
que_fork_error_handle(
/*==================*/
	trx_t*	trx,	/*!< in: trx */
	que_t*	fork);	/*!< in: query graph which was run before signal
			handling started, NULL not allowed */
/**********************************************************************//**
Moves a suspended query thread to the QUE_THR_RUNNING state and releases
a single worker thread to execute it. This function should be used to end
the wait state of a query thread waiting for a lock or a stored procedure
completion. */
UNIV_INTERN
void
que_thr_end_wait(
/*=============*/
	que_thr_t*	thr,		/*!< in: query thread in the
					QUE_THR_LOCK_WAIT,
					or QUE_THR_PROCEDURE_WAIT, or
					QUE_THR_SIG_REPLY_WAIT state */
	que_thr_t**	next_thr);	/*!< in/out: next query thread to run;
					if the value which is passed in is
					a pointer to a NULL pointer, then the
					calling function can start running
					a new query thread */
/**********************************************************************//**
Same as que_thr_end_wait, but no parameter next_thr available. */
UNIV_INTERN
void
que_thr_end_wait_no_next_thr(
/*=========================*/
	que_thr_t*	thr);		/*!< in: query thread in the
					QUE_THR_LOCK_WAIT,
					or QUE_THR_PROCEDURE_WAIT, or
					QUE_THR_SIG_REPLY_WAIT state */
/**********************************************************************//**
Starts execution of a command in a query fork. Picks a query thread which
is not in the QUE_THR_RUNNING state and moves it to that state. If none
can be chosen, a situation which may arise in parallelized fetches, NULL
is returned.
@return a query thread of the graph moved to QUE_THR_RUNNING state, or
NULL; the query thread should be executed by que_run_threads by the
caller */
UNIV_INTERN
que_thr_t*
que_fork_start_command(
/*===================*/
	que_fork_t*	fork);	/*!< in: a query fork */
/***********************************************************************//**
Gets the trx of a query thread. */
UNIV_INLINE
trx_t*
thr_get_trx(
/*========*/
	que_thr_t*	thr);	/*!< in: query thread */
/*******************************************************************//**
Determines if this thread is rolling back an incomplete transaction
in crash recovery.
@return TRUE if thr is rolling back an incomplete transaction in crash
recovery */
UNIV_INLINE
ibool
thr_is_recv(
/*========*/
	const que_thr_t*	thr);	/*!< in: query thread */
/***********************************************************************//**
Gets the type of a graph node. */
UNIV_INLINE
ulint
que_node_get_type(
/*==============*/
	que_node_t*	node);	/*!< in: graph node */
/***********************************************************************//**
Gets pointer to the value data type field of a graph node. */
UNIV_INLINE
dtype_t*
que_node_get_data_type(
/*===================*/
	que_node_t*	node);	/*!< in: graph node */
/***********************************************************************//**
Gets pointer to the value dfield of a graph node. */
UNIV_INLINE
dfield_t*
que_node_get_val(
/*=============*/
	que_node_t*	node);	/*!< in: graph node */
/***********************************************************************//**
Gets the value buffer size of a graph node.
@return	val buffer size, not defined if val.data == NULL in node */
UNIV_INLINE
ulint
que_node_get_val_buf_size(
/*======================*/
	que_node_t*	node);	/*!< in: graph node */
/***********************************************************************//**
Sets the value buffer size of a graph node. */
UNIV_INLINE
void
que_node_set_val_buf_size(
/*======================*/
	que_node_t*	node,	/*!< in: graph node */
	ulint		size);	/*!< in: size */
/*********************************************************************//**
Gets the next list node in a list of query graph nodes. */
UNIV_INLINE
que_node_t*
que_node_get_next(
/*==============*/
	que_node_t*	node);	/*!< in: node in a list */
/*********************************************************************//**
Gets the parent node of a query graph node.
@return	parent node or NULL */
UNIV_INLINE
que_node_t*
que_node_get_parent(
/*================*/
	que_node_t*	node);	/*!< in: node */
/****************************************************************//**
Get the first containing loop node (e.g. while_node_t or for_node_t) for the
given node, or NULL if the node is not within a loop.
@return	containing loop node, or NULL. */
UNIV_INTERN
que_node_t*
que_node_get_containing_loop_node(
/*==============================*/
	que_node_t*	node);	/*!< in: node */
/*********************************************************************//**
Catenates a query graph node to a list of them, possible empty list.
@return	one-way list of nodes */
UNIV_INLINE
que_node_t*
que_node_list_add_last(
/*===================*/
	que_node_t*	node_list,	/*!< in: node list, or NULL */
	que_node_t*	node);		/*!< in: node */
/*********************************************************************//**
Gets a query graph node list length.
@return	length, for NULL list 0 */
UNIV_INLINE
ulint
que_node_list_get_len(
/*==================*/
	que_node_t*	node_list);	/*!< in: node list, or NULL */
/**********************************************************************//**
Checks if graph, trx, or session is in a state where the query thread should
be stopped.
@return TRUE if should be stopped; NOTE that if the peek is made
without reserving the kernel mutex, then another peek with the mutex
reserved is necessary before deciding the actual stopping */
UNIV_INLINE
ibool
que_thr_peek_stop(
/*==============*/
	que_thr_t*	thr);	/*!< in: query thread */
/***********************************************************************//**
Returns TRUE if the query graph is for a SELECT statement.
@return	TRUE if a select */
UNIV_INLINE
ibool
que_graph_is_select(
/*================*/
	que_t*		graph);		/*!< in: graph */
/**********************************************************************//**
Prints info of an SQL query graph node. */
UNIV_INTERN
void
que_node_print_info(
/*================*/
	que_node_t*	node);	/*!< in: query graph node */
/*********************************************************************//**
Evaluate the given SQL
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
que_eval_sql(
/*=========*/
	pars_info_t*	info,	/*!< in: info struct, or NULL */
	const char*	sql,	/*!< in: SQL string */
	ibool		reserve_dict_mutex,
				/*!< in: if TRUE, acquire/release
				dict_sys->mutex around call to pars_sql. */
	trx_t*		trx);	/*!< in: trx */
/************************************************************************//**
Moves a thread from another state to the QUE_THR_RUNNING state. Increments
the n_active_thrs counters of the query graph and transaction if thr was
not active.
***NOTE***: This is the only functions in which such a transition is
allowed to happen! */
UNIV_INTERN
void
que_thr_move_to_run_state(
/*======================*/
	que_thr_t*	thr);	/*!< in: an query thread */

/************************************************************************//**
A patch for a client used to 'stop' a dummy query thread used in client
select, when there is no error or lock wait.

TODO: Currently only called from row0merge, needs to be removed. */
UNIV_INTERN
void
que_thr_stop_for_client_no_error(
/*=============================*/
	que_thr_t*	thr,	/*!< in: query thread */
	trx_t*		trx);	/*!< in: transaction */
/*************************************************************************//**
Reset the variables. */
UNIV_INTERN
void
que_var_init(void);
/*==============*/
/* Query graph query thread node: the fields are protected by the kernel
mutex with the exceptions named below */

struct que_thr_struct{
	que_common_t	common;		/*!< type: QUE_NODE_THR */
	ulint		magic_n;	/*!< magic number to catch memory
					corruption */
	que_node_t*	child;		/*!< graph child node */
	que_t*		graph;		/*!< graph where this node belongs */
	ibool		is_active;	/*!< TRUE if the thread has been set
					to the run state in
					que_thr_move_to_run_state, but not
					deactivated in
					que_thr_dec_reference_count */
	ulint		state;		/*!< state of the query thread */
	UT_LIST_NODE_T(que_thr_t)
			thrs;		/*!< list of thread nodes of the fork
					node */
	UT_LIST_NODE_T(que_thr_t)
			trx_thrs;	/*!< lists of threads in wait list of
					the trx */
	UT_LIST_NODE_T(que_thr_t)
			queue;		/*!< list of runnable thread nodes in
					the server task queue */
	/*------------------------------*/
	/* The following fields are private to the OS thread executing the
	query thread, and are not protected by the kernel mutex: */

	que_node_t*	run_node;	/*!< pointer to the node where the
					subgraph down from this node is
					currently executed */
	que_node_t*	prev_node;	/*!< pointer to the node from which
					the control came */
	ulint		resource;	/*!< resource usage of the query thread
					thus far */
	ulint		lock_state;	/*!< lock state of thread (table or
					row) */
};

#define QUE_THR_MAGIC_N		8476583
#define QUE_THR_MAGIC_FREED	123461526

/* Query graph fork node: its fields are protected by the kernel mutex */
struct que_fork_struct{
	que_common_t	common;		/*!< type: QUE_NODE_FORK */
	que_t*		graph;		/*!< query graph of this node */
	ulint		fork_type;	/*!< fork type */
	ulint		n_active_thrs;	/*!< if this is the root of a graph, the
					number query threads that have been
					started in que_thr_move_to_run_state
					but for which que_thr_dec_refer_count
					has not yet been called */
	trx_t*		trx;		/*!< transaction: this is set only in
					the root node */
	ulint		state;		/*!< state of the fork node */
	que_thr_t*	caller;		/*!< pointer to a possible calling query
					thread */
	UT_LIST_BASE_NODE_T(que_thr_t)
			thrs;		/*!< list of query threads */
	/*------------------------------*/
	/* The fields in this section are defined only in the root node */
	sym_tab_t*	sym_tab;	/*!< symbol table of the query,
					generated by the parser, or NULL
					if the graph was created 'by hand' */
	pars_info_t*	info;		/*!< info struct, or NULL */
	/* The following cur_... fields are relevant only in a select graph */

	ulint		cur_end;	/*!< QUE_CUR_NOT_DEFINED, QUE_CUR_START,
					QUE_CUR_END */
	ulint		cur_pos;	/*!< if there are n rows in the result
					set, values 0 and n + 1 mean before
					first row, or after last row, depending
					on cur_end; values 1...n mean a row
					index */
	ibool		cur_on_row;	/*!< TRUE if cursor is on a row, i.e.,
					it is not before the first row or
					after the last row */
	dulint		n_inserts;	/*!< number of rows inserted */
	dulint		n_updates;	/*!< number of rows updated */
	dulint		n_deletes;	/*!< number of rows deleted */
	sel_node_t*	last_sel_node;	/*!< last executed select node, or NULL
					if none */
	UT_LIST_NODE_T(que_fork_t)
			graphs;		/*!< list of query graphs of a session
					or a stored procedure */
	/*------------------------------*/
	mem_heap_t*	heap;		/*!< memory heap where the fork was
					created */

};

/* Query fork (or graph) types */
#define QUE_FORK_SELECT_NON_SCROLL	1	/* forward-only cursor */
#define QUE_FORK_SELECT_SCROLL		2	/* scrollable cursor */
#define QUE_FORK_INSERT			3
#define QUE_FORK_UPDATE			4
#define QUE_FORK_ROLLBACK		5
			/* This is really the undo graph used in rollback,
			no signal-sending roll_node in this graph */
#define QUE_FORK_PURGE			6
#define	QUE_FORK_EXECUTE		7
#define QUE_FORK_PROCEDURE		8
#define QUE_FORK_PROCEDURE_CALL		9
#define QUE_FORK_USER_INTERFACE	10
#define	QUE_FORK_RECOVERY		11

/* Query fork (or graph) states */
#define QUE_FORK_ACTIVE		1
#define QUE_FORK_COMMAND_WAIT	2
#define QUE_FORK_INVALID	3
#define QUE_FORK_BEING_FREED	4

/* Flag which is ORed to control structure statement node types */
#define QUE_NODE_CONTROL_STAT	1024

/* Query graph node types */
#define	QUE_NODE_LOCK		1
#define	QUE_NODE_INSERT		2
#define QUE_NODE_UPDATE		4
#define	QUE_NODE_CURSOR		5
#define	QUE_NODE_SELECT		6
#define	QUE_NODE_AGGREGATE	7
#define QUE_NODE_FORK		8
#define QUE_NODE_THR		9
#define QUE_NODE_UNDO		10
#define QUE_NODE_COMMIT		11
#define QUE_NODE_ROLLBACK	12
#define QUE_NODE_PURGE		13
#define QUE_NODE_CREATE_TABLE	14
#define QUE_NODE_CREATE_INDEX	15
#define QUE_NODE_SYMBOL		16
#define QUE_NODE_RES_WORD	17
#define QUE_NODE_FUNC		18
#define QUE_NODE_ORDER		19
#define QUE_NODE_PROC		(20 + QUE_NODE_CONTROL_STAT)
#define QUE_NODE_IF		(21 + QUE_NODE_CONTROL_STAT)
#define QUE_NODE_WHILE		(22 + QUE_NODE_CONTROL_STAT)
#define QUE_NODE_ASSIGNMENT	23
#define QUE_NODE_FETCH		24
#define QUE_NODE_OPEN		25
#define QUE_NODE_COL_ASSIGNMENT	26
#define QUE_NODE_FOR		(27 + QUE_NODE_CONTROL_STAT)
#define QUE_NODE_RETURN		28
#define QUE_NODE_ROW_PRINTF	29
#define QUE_NODE_ELSIF		30
#define QUE_NODE_CALL		31
#define QUE_NODE_EXIT		32

/* Query thread states */
#define QUE_THR_RUNNING		1
#define QUE_THR_PROCEDURE_WAIT	2
#define	QUE_THR_COMPLETED	3	/* in selects this means that the
					thread is at the end of its result set
					(or start, in case of a scroll cursor);
					in other statements, this means the
					thread has done its task */
#define QUE_THR_COMMAND_WAIT	4
#define QUE_THR_LOCK_WAIT	5
#define QUE_THR_SIG_REPLY_WAIT	6
#define QUE_THR_SUSPENDED	7
#define QUE_THR_ERROR		8

/* Query thread lock states */
#define QUE_THR_LOCK_NOLOCK	0
#define QUE_THR_LOCK_ROW	1
#define QUE_THR_LOCK_TABLE	2

/* From where the cursor position is counted */
#define QUE_CUR_NOT_DEFINED	1
#define QUE_CUR_START		2
#define	QUE_CUR_END		3


#ifndef UNIV_NONINL
#include "que0que.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/que0types.h
Query graph global types

Created 5/27/1996 Heikki Tuuri
*******************************************************/

#ifndef que0types_h
#define que0types_h

#include "data0data.h"
#include "dict0types.h"

/* Pseudotype for all graph nodes */
typedef void	que_node_t;

typedef struct que_fork_struct	que_fork_t;

/* Query graph root is a fork node */
typedef	que_fork_t	que_t;

typedef struct que_thr_struct		que_thr_t;
typedef struct que_common_struct	que_common_t;

/* Common struct at the beginning of each query graph node; the name of this
substruct must be 'common' */

struct que_common_struct{
	ulint		type;	/*!< query node type */
	que_node_t*	parent;	/*!< back pointer to parent node, or NULL */
	que_node_t*	brother;/* pointer to a possible brother node */
	dfield_t	val;	/*!< evaluated value for an expression */
	ulint		val_buf_size;
				/* buffer size for the evaluated value data,
				if the buffer has been allocated dynamically:
				if this field is != 0, and the node is a
				symbol node or a function node, then we
				have to free the data field in val
				explicitly */
};

#endif
/*****************************************************************************

Copyright (c) 1996, 2010, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/que0que.ic
Query graph

Created 5/27/1996 Heikki Tuuri
*******************************************************/

#include "usr0sess.h"

/***********************************************************************//**
Gets the trx of a query thread. */
UNIV_INLINE
trx_t*
thr_get_trx(
/*========*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	ut_ad(thr);

	return(thr->graph->trx);
}

/*******************************************************************//**
Determines if this thread is rolling back an incomplete transaction
in crash recovery.
@return TRUE if thr is rolling back an incomplete transaction in crash
recovery */
UNIV_INLINE
ibool
thr_is_recv(
/*========*/
	const que_thr_t*	thr)	/*!< in: query thread */
{
	return(trx_is_recv(thr->graph->trx));
}

/***********************************************************************//**
Gets the first thr in a fork. */
UNIV_INLINE
que_thr_t*
que_fork_get_first_thr(
/*===================*/
	que_fork_t*	fork)	/*!< in: query fork */
{
	return(UT_LIST_GET_FIRST(fork->thrs));
}

/***********************************************************************//**
Gets the child node of the first thr in a fork. */
UNIV_INLINE
que_node_t*
que_fork_get_child(
/*===============*/
	que_fork_t*	fork)	/*!< in: query fork */
{
	que_thr_t*	thr;

	thr = UT_LIST_GET_FIRST(fork->thrs);

	return(thr->child);
}

/***********************************************************************//**
Gets the type of a graph node. */
UNIV_INLINE
ulint
que_node_get_type(
/*==============*/
	que_node_t*	node)	/*!< in: graph node */
{
	ut_ad(node);

	return(((que_common_t*)node)->type);
}

/***********************************************************************//**
Gets pointer to the value dfield of a graph node. */
UNIV_INLINE
dfield_t*
que_node_get_val(
/*=============*/
	que_node_t*	node)	/*!< in: graph node */
{
	ut_ad(node);

	return(&(((que_common_t*)node)->val));
}

/***********************************************************************//**
Gets the value buffer size of a graph node.
@return	val buffer size, not defined if val.data == NULL in node */
UNIV_INLINE
ulint
que_node_get_val_buf_size(
/*======================*/
	que_node_t*	node)	/*!< in: graph node */
{
	ut_ad(node);

	return(((que_common_t*)node)->val_buf_size);
}

/***********************************************************************//**
Sets the value buffer size of a graph node. */
UNIV_INLINE
void
que_node_set_val_buf_size(
/*======================*/
	que_node_t*	node,	/*!< in: graph node */
	ulint		size)	/*!< in: size */
{
	ut_ad(node);

	((que_common_t*)node)->val_buf_size = size;
}

/***********************************************************************//**
Sets the parent of a graph node. */
UNIV_INLINE
void
que_node_set_parent(
/*================*/
	que_node_t*	node,	/*!< in: graph node */
	que_node_t*	parent)	/*!< in: parent */
{
	ut_ad(node);

	((que_common_t*)node)->parent = parent;
}

/***********************************************************************//**
Gets pointer to the value data type field of a graph node. */
UNIV_INLINE
dtype_t*
que_node_get_data_type(
/*===================*/
	que_node_t*	node)	/*!< in: graph node */
{
	ut_ad(node);

	return(dfield_get_type(&((que_common_t*) node)->val));
}

/*********************************************************************//**
Catenates a query graph node to a list of them, possible empty list.
@return	one-way list of nodes */
UNIV_INLINE
que_node_t*
que_node_list_add_last(
/*===================*/
	que_node_t*	node_list,	/*!< in: node list, or NULL */
	que_node_t*	node)		/*!< in: node */
{
	que_common_t*	cnode;
	que_common_t*	cnode2;

	cnode = (que_common_t*) node;

	cnode->brother = NULL;

	if (node_list == NULL) {

		return(node);
	}

	cnode2 = (que_common_t*) node_list;

	while (cnode2->brother != NULL) {
		cnode2 = (que_common_t*) cnode2->brother;
	}

	cnode2->brother = node;

	return(node_list);
}

/*********************************************************************//**
Gets the next list node in a list of query graph nodes.
@return	next node in a list of nodes */
UNIV_INLINE
que_node_t*
que_node_get_next(
/*==============*/
	que_node_t*	node)	/*!< in: node in a list */
{
	return(((que_common_t*)node)->brother);
}

/*********************************************************************//**
Gets a query graph node list length.
@return	length, for NULL list 0 */
UNIV_INLINE
ulint
que_node_list_get_len(
/*==================*/
	que_node_t*	node_list)	/*!< in: node list, or NULL */
{
	const que_common_t*	cnode;
	ulint			len;

	cnode = (const que_common_t*) node_list;
	len = 0;

	while (cnode != NULL) {
		len++;
		cnode = (const que_common_t*) cnode->brother;
	}

	return(len);
}

/*********************************************************************//**
Gets the parent node of a query graph node.
@return	parent node or NULL */
UNIV_INLINE
que_node_t*
que_node_get_parent(
/*================*/
	que_node_t*	node)	/*!< in: node */
{
	return(((que_common_t*)node)->parent);
}

/**********************************************************************//**
Checks if graph, trx, or session is in a state where the query thread should
be stopped.
@return TRUE if should be stopped; NOTE that if the peek is made
without reserving the kernel mutex, then another peek with the mutex
reserved is necessary before deciding the actual stopping */
UNIV_INLINE
ibool
que_thr_peek_stop(
/*==============*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	trx_t*	trx;
	que_t*	graph;

	graph = thr->graph;
	trx = graph->trx;

	if (graph->state != QUE_FORK_ACTIVE
	    || trx->que_state == TRX_QUE_LOCK_WAIT
	    || (UT_LIST_GET_LEN(trx->signals) > 0
		&& trx->que_state == TRX_QUE_RUNNING)) {

		return(TRUE);
	}

	return(FALSE);
}

/***********************************************************************//**
Returns TRUE if the query graph is for a SELECT statement.
@return	TRUE if a select */
UNIV_INLINE
ibool
que_graph_is_select(
/*================*/
	que_t*		graph)		/*!< in: graph */
{
	if (graph->fork_type == QUE_FORK_SELECT_SCROLL
	    || graph->fork_type == QUE_FORK_SELECT_NON_SCROLL) {

		return(TRUE);
	}

	return(FALSE);
}
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/eval0eval.h
SQL evaluator: evaluates simple data structures, like expressions, in
a query graph

Created 12/29/1997 Heikki Tuuri
*******************************************************/

#ifndef eval0eval_h
#define eval0eval_h

#include "univ.i"
#include "que0types.h"
#include "pars0sym.h"
#include "pars0pars.h"

/*****************************************************************//**
Free the buffer from global dynamic memory for a value of a que_node,
if it has been allocated in the above function. The freeing for pushed
column values is done in sel_col_prefetch_buf_free. */
UNIV_INTERN
void
eval_node_free_val_buf(
/*===================*/
	que_node_t*	node);	/*!< in: query graph node */
/*****************************************************************//**
Evaluates a symbol table symbol. */
UNIV_INLINE
void
eval_sym(
/*=====*/
	sym_node_t*	sym_node);	/*!< in: symbol table node */
/*****************************************************************//**
Evaluates an expression. */
UNIV_INLINE
void
eval_exp(
/*=====*/
	que_node_t*	exp_node);	/*!< in: expression */
/*****************************************************************//**
Sets an integer value as the value of an expression node. */
UNIV_INLINE
void
eval_node_set_int_val(
/*==================*/
	que_node_t*	node,	/*!< in: expression node */
	lint		val);	/*!< in: value to set */
/*****************************************************************//**
Gets an integer value from an expression node.
@return	integer value */
UNIV_INLINE
lint
eval_node_get_int_val(
/*==================*/
	que_node_t*	node);	/*!< in: expression node */
/*****************************************************************//**
Copies a binary string value as the value of a query graph node. Allocates a
new buffer if necessary. */
UNIV_INLINE
void
eval_node_copy_and_alloc_val(
/*=========================*/
	que_node_t*	node,	/*!< in: query graph node */
	const byte*	str,	/*!< in: binary string */
	ulint		len);	/*!< in: string length or UNIV_SQL_NULL */
/*****************************************************************//**
Copies a query node value to another node. */
UNIV_INLINE
void
eval_node_copy_val(
/*===============*/
	que_node_t*	node1,	/*!< in: node to copy to */
	que_node_t*	node2);	/*!< in: node to copy from */
/*****************************************************************//**
Gets a iboolean value from a query node.
@return	iboolean value */
UNIV_INLINE
ibool
eval_node_get_ibool_val(
/*====================*/
	que_node_t*	node);	/*!< in: query graph node */
/*****************************************************************//**
Evaluates a comparison node.
@return	the result of the comparison */
UNIV_INTERN
ibool
eval_cmp(
/*=====*/
	func_node_t*	cmp_node);	/*!< in: comparison node */


#ifndef UNIV_NONINL
#include "eval0eval.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1998, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/eval0proc.h
Executes SQL stored procedures and their control structures

Created 1/20/1998 Heikki Tuuri
*******************************************************/

#ifndef eval0proc_h
#define eval0proc_h

#include "univ.i"
#include "que0types.h"
#include "pars0sym.h"
#include "pars0pars.h"

/**********************************************************************//**
Performs an execution step of a procedure node.
@return	query thread to run next or NULL */
UNIV_INLINE
que_thr_t*
proc_step(
/*======*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of an if-statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
if_step(
/*====*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of a while-statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
while_step(
/*=======*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of a for-loop node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
for_step(
/*=====*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of an assignment statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
assign_step(
/*========*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of a procedure call node.
@return	query thread to run next or NULL */
UNIV_INLINE
que_thr_t*
proc_eval_step(
/*===========*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of an exit statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
exit_step(
/*======*/
	que_thr_t*	thr);	/*!< in: query thread */
/**********************************************************************//**
Performs an execution step of a return-statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
return_step(
/*========*/
	que_thr_t*	thr);	/*!< in: query thread */


#ifndef UNIV_NONINL
#include "eval0proc.ic"
#endif

#endif
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/eval0eval.ic
SQL evaluator: evaluates simple data structures, like expressions, in
a query graph

Created 12/29/1997 Heikki Tuuri
*******************************************************/

#include "que0que.h"
#include "rem0cmp.h"
#include "pars0grm.h"

/*****************************************************************//**
Evaluates a function node. */
UNIV_INTERN
void
eval_func(
/*======*/
	func_node_t*	func_node);	/*!< in: function node */
/*****************************************************************//**
Allocate a buffer from global dynamic memory for a value of a que_node.
NOTE that this memory must be explicitly freed when the query graph is
freed. If the node already has allocated buffer, that buffer is freed
here. NOTE that this is the only function where dynamic memory should be
allocated for a query node val field.
@return	pointer to allocated buffer */
UNIV_INTERN
byte*
eval_node_alloc_val_buf(
/*====================*/
	que_node_t*	node,	/*!< in: query graph node; sets the val field
				data field to point to the new buffer, and
				len field equal to size */
	ulint		size);	/*!< in: buffer size */


/*****************************************************************//**
Allocates a new buffer if needed.
@return	pointer to buffer */
UNIV_INLINE
byte*
eval_node_ensure_val_buf(
/*=====================*/
	que_node_t*	node,	/*!< in: query graph node; sets the val field
				data field to point to the new buffer, and
				len field equal to size */
	ulint		size)	/*!< in: buffer size */
{
	dfield_t*	dfield;
	byte*		data;

	dfield = que_node_get_val(node);
	dfield_set_len(dfield, size);

	data = dfield_get_data(dfield);

	if (!data || que_node_get_val_buf_size(node) < size) {

		data = eval_node_alloc_val_buf(node, size);
	}

	return(data);
}

/*****************************************************************//**
Evaluates a symbol table symbol. */
UNIV_INLINE
void
eval_sym(
/*=====*/
	sym_node_t*	sym_node)	/*!< in: symbol table node */
{

	ut_ad(que_node_get_type(sym_node) == QUE_NODE_SYMBOL);

	if (sym_node->indirection) {
		/* The symbol table node is an alias for a variable or a
		column */

		dfield_copy_data(que_node_get_val(sym_node),
				 que_node_get_val(sym_node->indirection));
	}
}

/*****************************************************************//**
Evaluates an expression. */
UNIV_INLINE
void
eval_exp(
/*=====*/
	que_node_t*	exp_node)	/*!< in: expression */
{
	if (que_node_get_type(exp_node) == QUE_NODE_SYMBOL) {

		eval_sym((sym_node_t*)exp_node);

		return;
	}

	eval_func(exp_node);
}

/*****************************************************************//**
Sets an integer value as the value of an expression node. */
UNIV_INLINE
void
eval_node_set_int_val(
/*==================*/
	que_node_t*	node,	/*!< in: expression node */
	lint		val)	/*!< in: value to set */
{
	dfield_t*	dfield;
	byte*		data;

	dfield = que_node_get_val(node);

	data = dfield_get_data(dfield);

	if (data == NULL) {
		data = eval_node_alloc_val_buf(node, 4);
	}

	ut_ad(dfield_get_len(dfield) == 4);

	mach_write_to_4(data, (ulint)val);
}

/*****************************************************************//**
Gets an integer non-SQL null value from an expression node.
@return	integer value */
UNIV_INLINE
lint
eval_node_get_int_val(
/*==================*/
	que_node_t*	node)	/*!< in: expression node */
{
	dfield_t*	dfield;

	dfield = que_node_get_val(node);

	ut_ad(dfield_get_len(dfield) == 4);

	return((int)mach_read_from_4(dfield_get_data(dfield)));
}

/*****************************************************************//**
Gets a iboolean value from a query node.
@return	iboolean value */
UNIV_INLINE
ibool
eval_node_get_ibool_val(
/*====================*/
	que_node_t*	node)	/*!< in: query graph node */
{
	dfield_t*	dfield;
	byte*		data;

	dfield = que_node_get_val(node);

	data = dfield_get_data(dfield);

	ut_ad(data != NULL);

	return(mach_read_from_1(data));
}

/*****************************************************************//**
Sets a iboolean value as the value of a function node. */
UNIV_INLINE
void
eval_node_set_ibool_val(
/*====================*/
	func_node_t*	func_node,	/*!< in: function node */
	ibool		val)		/*!< in: value to set */
{
	dfield_t*	dfield;
	byte*		data;

	dfield = que_node_get_val(func_node);

	data = dfield_get_data(dfield);

	if (data == NULL) {
		/* Allocate 1 byte to hold the value */

		data = eval_node_alloc_val_buf(func_node, 1);
	}

	ut_ad(dfield_get_len(dfield) == 1);

	mach_write_to_1(data, val);
}

/*****************************************************************//**
Copies a binary string value as the value of a query graph node. Allocates a
new buffer if necessary. */
UNIV_INLINE
void
eval_node_copy_and_alloc_val(
/*=========================*/
	que_node_t*	node,	/*!< in: query graph node */
	const byte*	str,	/*!< in: binary string */
	ulint		len)	/*!< in: string length or UNIV_SQL_NULL */
{
	byte*		data;

	if (len == UNIV_SQL_NULL) {
		dfield_set_len(que_node_get_val(node), len);

		return;
	}

	data = eval_node_ensure_val_buf(node, len);

	ut_memcpy(data, str, len);
}

/*****************************************************************//**
Copies a query node value to another node. */
UNIV_INLINE
void
eval_node_copy_val(
/*===============*/
	que_node_t*	node1,	/*!< in: node to copy to */
	que_node_t*	node2)	/*!< in: node to copy from */
{
	dfield_t*	dfield2;

	dfield2 = que_node_get_val(node2);

	eval_node_copy_and_alloc_val(node1, dfield_get_data(dfield2),
				     dfield_get_len(dfield2));
}
/*****************************************************************************

Copyright (c) 1998, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file include/eval0proc.ic
Executes SQL stored procedures and their control structures

Created 1/20/1998 Heikki Tuuri
*******************************************************/

#include "pars0pars.h"
#include "que0que.h"
#include "eval0eval.h"

/**********************************************************************//**
Performs an execution step of a procedure node.
@return	query thread to run next or NULL */
UNIV_INLINE
que_thr_t*
proc_step(
/*======*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	proc_node_t*	node;

	ut_ad(thr);

	node = thr->run_node;
	ut_ad(que_node_get_type(node) == QUE_NODE_PROC);

	if (thr->prev_node == que_node_get_parent(node)) {
		/* Start execution from the first statement in the statement
		list */

		thr->run_node = node->stat_list;
	} else {
		/* Move to the next statement */
		ut_ad(que_node_get_next(thr->prev_node) == NULL);

		thr->run_node = NULL;
	}

	if (thr->run_node == NULL) {
		thr->run_node = que_node_get_parent(node);
	}

	return(thr);
}

/**********************************************************************//**
Performs an execution step of a procedure call node.
@return	query thread to run next or NULL */
UNIV_INLINE
que_thr_t*
proc_eval_step(
/*===========*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	func_node_t*	node;

	ut_ad(thr);

	node = thr->run_node;
	ut_ad(que_node_get_type(node) == QUE_NODE_FUNC);

	/* Evaluate the procedure */

	eval_exp(node);

	thr->run_node = que_node_get_parent(node);

	return(thr);
}


=== IMPLEMENTATION ===

#include "univ.i"
#line 2 "lexyy.c"

#line 4 "lexyy.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

static int yyleng;

static FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

    #define YY_LESS_LINENO(n)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
static int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

static void yyrestart (FILE *input_file  );
__attribute__((unused)) static void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
static YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
static void yy_delete_buffer (YY_BUFFER_STATE b  );
static void yy_flush_buffer (YY_BUFFER_STATE b  );
__attribute__((unused)) static void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
__attribute__((unused)) static void yypop_buffer_state (void );

static void yyensure_buffer_stack (void );
static void yy_load_buffer_state (void );
static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );

#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )

YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );

static void *yyalloc (yy_size_t  );
static void *yyrealloc (void *,yy_size_t  );
static void yyfree (void *  );

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer(yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define yywrap(n) 1
#define YY_SKIP_YYWRAP

typedef unsigned char YY_CHAR;

static FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;

typedef int yy_state_type;

static int yylineno;

static int yylineno = 1;

static char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state (void );
static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
static int yy_get_next_buffer (void );
static void yy_fatal_error (yyconst char msg[]  );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 119
#define YY_END_OF_BUFFER 120
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static yyconst flex_int16_t yy_accept[399] =
    {   0,
        0,    0,  114,  114,    0,    0,    0,    0,  120,  118,
      117,  117,    8,  118,  109,    5,   98,  104,  107,  105,
      102,  106,  118,  108,    1,  118,  103,  101,   99,  100,
      112,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
      110,  111,  114,  115,    6,    7,    9,   10,  117,    4,
       93,  113,    2,    1,    3,   94,   95,   97,   96,   92,
       92,   92,   92,   92,   92,   44,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   28,   17,   25,   92,   92,   92,   92,   92,

       54,   61,   92,   14,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   92,  114,  115,  115,  116,    6,    7,    9,   10,
        2,   13,   45,   92,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       92,   27,   92,   92,   92,   41,   92,   92,   92,   92,
       21,   92,   92,   92,   92,   15,   92,   92,   92,   18,
       92,   92,   92,   92,   92,   80,   92,   92,   92,   51,
       92,   12,   92,   36,   92,   92,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   20,   24,

       92,   92,   92,   92,   92,   92,   92,   92,   92,   92,
       46,   92,   92,   30,   92,   87,   92,   92,   39,   92,
       92,   92,   92,   92,   48,   92,   89,   32,   91,   92,
       11,   64,   92,   92,   92,   42,   92,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   29,   92,   92,   92,
       92,   92,   92,   92,   92,   92,   85,   92,   26,   92,
       66,   92,   92,   92,   37,   92,   92,   92,   92,   92,
       92,   92,   31,   65,   23,   92,   57,   92,   75,   92,
       92,   92,   43,   92,   92,   92,   92,   92,   92,   92,
       92,   90,   92,   92,   56,   92,   92,   92,   92,   92,

       92,   92,   40,   33,   79,   19,   92,   83,   74,   55,
       92,   63,   92,   52,   92,   92,   92,   47,   92,   76,
       92,   78,   92,   92,   34,   92,   92,   92,   35,   72,
       92,   92,   92,   92,   58,   92,   50,   49,   92,   92,
       53,   62,   92,   92,   92,   22,   92,   92,   73,   81,
       92,   92,   77,   92,   68,   92,   92,   92,   92,   38,
       92,   88,   67,   92,   84,   92,   92,   92,   86,   92,
       59,   92,   16,   92,   70,   69,   92,   92,   82,   92,
       92,   92,   92,   92,   92,   92,   92,   92,   92,   71,
       92,   92,   92,   92,   92,   92,   60,    0

    } ;

static yyconst flex_int32_t yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    4,    1,    5,    6,    1,    7,    8,
        9,   10,   11,   12,   13,   14,   15,   16,   16,   16,
       16,   16,   16,   16,   16,   16,   16,   17,   18,   19,
       20,   21,   22,    1,   23,   24,   25,   26,   27,   28,
       29,   30,   31,   32,   33,   34,   35,   36,   37,   38,
       39,   40,   41,   42,   43,   44,   45,   46,   47,   32,
        1,    1,    1,    1,   48,    1,   32,   32,   32,   32,

       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
       32,   32,   49,    1,   50,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst flex_int32_t yy_meta[51] =
    {   0,
        1,    1,    1,    2,    1,    1,    3,    1,    1,    4,
        1,    1,    1,    1,    1,    5,    1,    1,    1,    6,
        1,    1,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    1,    1
    } ;

static yyconst flex_int16_t yy_base[409] =
    {   0,
        0,    0,  437,  436,  438,  437,  439,  438,  441,  448,
       49,   51,  448,    0,  448,  448,  448,  448,  448,  448,
      448,  448,  426,  429,   41,  418,  448,   38,  448,  417,
      448,   20,   33,   32,   46,   40,   44,    0,   54,   52,
      399,   48,   60,  395,   65,   67,   81,   27,  411,   75,
      448,  448,    0,   98,    0,  426,    0,  428,  113,    0,
      448,  448,  415,   54,  410,  448,  448,  448,  448,    0,
      403,   68,  399,  391,  389,    0,  402,   80,   84,  397,
      383,   96,  381,  394,  379,  393,  387,  375,  379,  375,
      377,  377,    0,   98,    0,  376,   97,  385,  368,  375,

        0,    0,  381,  381,  364,   94,  103,  379,   98,   65,
      381,  369,  109,  361,  377,  373,  351,   97,  372,  363,
      115,  356,    0,  137,  138,  448,    0,  388,    0,  390,
      377,    0,    0,  365,  360,  367,  365,  348,  346,  345,
      350,  359,  347,  359,   95,  347,  353,  354,  336,  336,
      123,    0,  334,  350,  351,    0,  338,  347,  344,  122,
      124,  341,  336,  330,  340,  338,  331,  328,  336,    0,
      326,  336,  334,  325,  315,  309,  322,  307,  327,    0,
      313,    0,  311,    0,  325,  316,  313,  131,  309,  316,
      323,  302,  304,  309,  309,  301,  304,  299,    0,    0,

      311,  295,  305,  312,  292,  291,  305,  294,  307,  287,
        0,  297,  279,    0,  298,    0,  295,  282,    0,  281,
      276,  281,  280,  290,    0,  276,    0,    0,    0,  280,
        0,    0,  276,  273,  287,    0,  272,  272,  270,  286,
      271,  283,  280,  264,  282,  277,    0,  272,  272,  258,
      257,  270,  256,  270,  269,  268,    0,  252,    0,  246,
        0,  265,  249,  248,    0,  262,  252,  247,  246,  258,
      248,  247,    0,    0,    0,  251,    0,  239,    0,  253,
      249,  235,    0,  249,  250,  233,  238,  231,  249,  231,
      228,    0,  229,  226,    0,  231,  243,  230,  237,  227,

      235,  220,    0,    0,    0,  212,  219,    0,    0,    0,
      216,    0,  230,    0,  231,  218,  217,    0,  213,    0,
      216,    0,  208,  210,    0,  209,  223,  216,    0,    0,
      219,  222,  204,  219,    0,  215,    0,    0,  199,  213,
        0,    0,  197,  196,  201,    0,  210,  195,    0,    0,
      201,  197,    0,  192,    0,  204,  204,  192,  202,    0,
      179,    0,    0,  199,    0,  183,  177,  183,    0,  174,
        0,  193,    0,  192,    0,    0,  183,  187,    0,  174,
      174,  180,  166,  189,  181,  180,  166,  151,  118,    0,
      130,  136,  127,  123,  119,  111,    0,  448,  167,  173,

      179,  152,  181,  124,  187,  193,  199,  205
    } ;

static yyconst flex_int16_t yy_def[409] =
    {   0,
      398,    1,  399,  399,  400,  400,  401,  401,  398,  398,
      398,  398,  398,  402,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  403,  398,  398,  398,  398,
      398,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      398,  398,  405,  406,  407,  398,  408,  398,  398,  402,
      398,  398,  398,  398,  403,  398,  398,  398,  398,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,

      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  405,  406,  406,  398,  407,  398,  408,  398,
      398,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,

      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,

      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,  404,  404,  404,
      404,  404,  404,  404,  404,  404,  404,    0,  398,  398,

      398,  398,  398,  398,  398,  398,  398,  398
    } ;

static yyconst flex_int16_t yy_nxt[499] =
    {   0,
       10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
       20,   21,   22,   23,   24,   25,   26,   27,   28,   29,
       30,   31,   32,   33,   34,   35,   36,   37,   38,   38,
       39,   38,   38,   40,   41,   42,   43,   44,   38,   45,
       46,   47,   48,   49,   50,   38,   38,   38,   51,   52,
       59,   59,   59,   59,   63,   71,   64,   67,   68,   73,
       72,   77,  118,   74,  119,   78,   75,   63,   79,   64,
       88,   80,   82,   85,   81,   86,   83,   89,   96,   76,
       90,   93,   84,   91,   99,   87,   92,  101,   97,   94,
      100,  107,  133,  110,   95,  102,  111,  103,  179,  104,

      108,  109,  105,  115,  121,  112,  180,  125,  134,  113,
      116,  122,  126,  114,   59,   59,  139,  117,  141,  142,
      146,  163,  140,  159,  171,  173,  143,  189,   70,  147,
      172,  177,  183,  164,  207,  208,  148,  190,  160,  161,
      174,  193,  178,  184,  175,  194,  398,  125,  222,  214,
      224,  398,  126,  215,  248,  249,   60,  397,  396,  395,
      225,  394,  393,  223,  392,  391,  250,   53,   53,   53,
       53,   53,   53,   55,   55,   55,   55,   55,   55,   57,
       57,   57,   57,   57,   57,   65,   65,  123,  123,  123,
      390,  123,  123,  124,  124,  124,  124,  124,  124,  127,

      127,  389,  127,  127,  127,  129,  388,  129,  129,  129,
      129,  387,  386,  385,  384,  383,  382,  381,  380,  379,
      378,  377,  376,  375,  374,  373,  372,  371,  370,  369,
      368,  367,  366,  365,  364,  363,  362,  361,  360,  359,
      358,  357,  356,  355,  354,  353,  352,  351,  350,  349,
      348,  347,  346,  345,  344,  343,  342,  341,  340,  339,
      338,  337,  336,  335,  334,  333,  332,  331,  330,  329,
      328,  327,  326,  325,  324,  323,  322,  321,  320,  319,
      318,  317,  316,  315,  314,  313,  312,  311,  310,  309,
      308,  307,  306,  305,  304,  303,  302,  301,  300,  299,

      298,  297,  296,  295,  294,  293,  292,  291,  290,  289,
      288,  287,  286,  285,  284,  283,  282,  281,  280,  279,
      278,  277,  276,  275,  274,  273,  272,  271,  270,  269,
      268,  267,  266,  265,  264,  263,  262,  261,  260,  259,
      258,  257,  256,  255,  254,  253,  252,  251,  247,  246,
      245,  244,  243,  242,  241,  240,  239,  238,  237,  236,
      235,  234,  233,  232,  231,  230,  229,  228,  227,  226,
      221,  220,  219,  218,  217,  216,  213,  212,  211,  210,
      209,  206,  205,  204,  203,  202,  201,  200,  199,  198,
      197,  196,  131,  130,  128,  195,  192,  191,  188,  187,

      186,  185,  182,  181,  176,  170,  169,  168,  167,  166,
      165,  162,  158,  157,  156,  155,  154,  153,  152,  151,
      150,  149,  145,  144,  138,  137,  136,  135,  132,  398,
      131,  130,  128,  120,  106,   98,   69,   66,   62,   61,
      398,   58,   58,   56,   56,   54,   54,    9,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398

    } ;

static yyconst flex_int16_t yy_chk[499] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
       11,   11,   12,   12,   25,   32,   25,   28,   28,   33,
       32,   34,   48,   33,   48,   34,   33,   64,   34,   64,
       37,   34,   35,   36,   34,   36,   35,   37,   40,   33,
       37,   39,   35,   37,   42,   36,   37,   43,   40,   39,
       42,   45,   72,   46,   39,   43,   46,   43,  110,   43,

       45,   45,   43,   47,   50,   46,  110,   54,   72,   46,
       47,   50,   54,   46,   59,   59,   78,   47,   79,   79,
       82,   97,   78,   94,  106,  107,   79,  118,  404,   82,
      106,  109,  113,   97,  145,  145,   82,  118,   94,   94,
      107,  121,  109,  113,  107,  121,  124,  125,  160,  151,
      161,  124,  125,  151,  188,  188,  402,  396,  395,  394,
      161,  393,  392,  160,  391,  389,  188,  399,  399,  399,
      399,  399,  399,  400,  400,  400,  400,  400,  400,  401,
      401,  401,  401,  401,  401,  403,  403,  405,  405,  405,
      388,  405,  405,  406,  406,  406,  406,  406,  406,  407,

      407,  387,  407,  407,  407,  408,  386,  408,  408,  408,
      408,  385,  384,  383,  382,  381,  380,  378,  377,  374,
      372,  370,  368,  367,  366,  364,  361,  359,  358,  357,
      356,  354,  352,  351,  348,  347,  345,  344,  343,  340,
      339,  336,  334,  333,  332,  331,  328,  327,  326,  324,
      323,  321,  319,  317,  316,  315,  313,  311,  307,  306,
      302,  301,  300,  299,  298,  297,  296,  294,  293,  291,
      290,  289,  288,  287,  286,  285,  284,  282,  281,  280,
      278,  276,  272,  271,  270,  269,  268,  267,  266,  264,
      263,  262,  260,  258,  256,  255,  254,  253,  252,  251,

      250,  249,  248,  246,  245,  244,  243,  242,  241,  240,
      239,  238,  237,  235,  234,  233,  230,  226,  224,  223,
      222,  221,  220,  218,  217,  215,  213,  212,  210,  209,
      208,  207,  206,  205,  204,  203,  202,  201,  198,  197,
      196,  195,  194,  193,  192,  191,  190,  189,  187,  186,
      185,  183,  181,  179,  178,  177,  176,  175,  174,  173,
      172,  171,  169,  168,  167,  166,  165,  164,  163,  162,
      159,  158,  157,  155,  154,  153,  150,  149,  148,  147,
      146,  144,  143,  142,  141,  140,  139,  138,  137,  136,
      135,  134,  131,  130,  128,  122,  120,  119,  117,  116,

      115,  114,  112,  111,  108,  105,  104,  103,  100,   99,
       98,   96,   92,   91,   90,   89,   88,   87,   86,   85,
       84,   83,   81,   80,   77,   75,   74,   73,   71,   65,
       63,   58,   56,   49,   44,   41,   30,   26,   24,   23,
        9,    8,    7,    6,    5,    4,    3,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398,  398,  398,
      398,  398,  398,  398,  398,  398,  398,  398

    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

static int yy_flex_debug;
static int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
static char *yytext;
#line 1 "pars0lex.l"
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/
/******************************************************
SQL parser lexical analyzer: input file for the GNU Flex lexer generator

The InnoDB parser is frozen because MySQL takes care of SQL parsing.
Therefore we normally keep the InnoDB parser C files as they are, and do
not automatically generate them from pars0grm.y and pars0lex.l.

How to make the InnoDB parser and lexer C files:

1. Run ./make_flex.sh to generate lexer files.

2. Run ./make_bison.sh to generate parser files.

These instructions seem to work at least with bison-1.875d and flex-2.5.31 on
Linux.

Created 12/14/1997 Heikki Tuuri
*******************************************************/
#define YY_NO_INPUT 1
#define YY_NO_UNISTD_H 1
#line 55 "pars0lex.l"
#define YYSTYPE que_node_t*

#include "univ.i"
#include "pars0pars.h"
#include "pars0grm.h"
#include "pars0sym.h"
#include "mem0mem.h"
#include "os0proc.h"

#define malloc(A)	ut_malloc(A)
#define free(A)		ut_free(A)
#define realloc(P, A)	ut_realloc(P, A)
#define exit(A) 	ut_error

#define YY_INPUT(buf, result, max_size) pars_get_lex_chars(buf, &result, max_size)

/* String buffer for removing quotes */
static ulint	stringbuf_len_alloc = 0; /* Allocated length */
static ulint	stringbuf_len = 0; /* Current length */
static char*	stringbuf; /* Start of buffer */
/** Appends a string to the buffer. */
static
void
string_append(
/*==========*/
	const char*	str,	/*!< in: string to be appended */
	ulint		len)	/*!< in: length of the string */
{
	if (stringbuf == NULL) {
		stringbuf = ut_malloc(1);
		stringbuf_len_alloc = 1;
	}

	if (stringbuf_len + len > stringbuf_len_alloc) {
		while (stringbuf_len + len > stringbuf_len_alloc) {
			stringbuf_len_alloc <<= 1;
		}
		stringbuf = ut_realloc(stringbuf, stringbuf_len_alloc);
	}

	memcpy(stringbuf + stringbuf_len, str, len);
	stringbuf_len += len;
}

/*************************************************************************
Reset the lexing variables. */
UNIV_INTERN
void
pars_lexer_var_init(void)
/*=====================*/
{
	stringbuf_len = 0;
	stringbuf_len_alloc = 0;

	if (stringbuf != NULL) {
		ut_free(stringbuf);
		stringbuf = NULL;
	}
}




#line 806 "lexyy.c"

#define INITIAL 0
#define comment 1
#define quoted 2
#define id 3

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#define YY_EXTRA_TYPE que_node_t*

static int yy_init_globals (void );

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

__attribute__((unused)) static int yylex_destroy (void );

__attribute__((unused)) static int yyget_debug (void );

__attribute__((unused)) static void yyset_debug (int debug_flag  );

YY_EXTRA_TYPE yyget_extra (void );

__attribute__((unused)) static void yyset_extra (YY_EXTRA_TYPE user_defined  );

__attribute__((unused)) static FILE *yyget_in (void );

__attribute__((unused)) static void yyset_in  (FILE * in_str  );

__attribute__((unused)) static FILE *yyget_out (void );

__attribute__((unused)) static void yyset_out  (FILE * out_str  );

__attribute__((unused)) static int yyget_leng (void );

__attribute__((unused)) static char *yyget_text (void );

__attribute__((unused)) static int yyget_lineno (void );

__attribute__((unused)) static void yyset_lineno (int line_number  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap (void );
#else
extern int yywrap (void );
#endif
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy (char *,yyconst char *,int );
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * );
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void );
#else
static int input (void );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

UNIV_INTERN int yylex (void);

#define YY_DECL UNIV_INTERN int yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;
    
#line 125 "pars0lex.l"


#line 995 "lexyy.c"

	if ( !(yy_init) )
		{
		(yy_init) = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! (yy_start) )
			(yy_start) = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack ();
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer(yyin,YY_BUF_SIZE );
		}

		yy_load_buffer_state( );
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = (yy_c_buf_p);

		/* Support of yytext. */
		*yy_cp = (yy_hold_char);

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = (yy_start);
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				(yy_last_accepting_state) = yy_current_state;
				(yy_last_accepting_cpos) = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 399 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_current_state != 398 );
		yy_cp = (yy_last_accepting_cpos);
		yy_current_state = (yy_last_accepting_state);

yy_find_action:
		yy_act = yy_accept[yy_current_state];

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = (yy_hold_char);
			yy_cp = (yy_last_accepting_cpos);
			yy_current_state = (yy_last_accepting_state);
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 127 "pars0lex.l"
{
			yylval = sym_tab_add_int_lit(pars_sym_tab_global,
								atoi(yytext));
			return(PARS_INT_LIT);
}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 133 "pars0lex.l"
{
			ut_error;	/* not implemented */

			return(PARS_FLOAT_LIT);
}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 139 "pars0lex.l"
{
			ulint	type;

			yylval = sym_tab_add_bound_lit(pars_sym_tab_global,
				yytext + 1, &type);

			return((int) type);
}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 148 "pars0lex.l"
{
			yylval = sym_tab_add_bound_id(pars_sym_tab_global,
				yytext + 1);

			return(PARS_ID_TOKEN);
}
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 155 "pars0lex.l"
{
/* Quoted character string literals are handled in an explicit
start state 'quoted'.  This state is entered and the buffer for
the scanned string is emptied upon encountering a starting quote.

In the state 'quoted', only two actions are possible (defined below). */
			BEGIN(quoted);
			stringbuf_len = 0;
}
	YY_BREAK
case 6:
/* rule 6 can match eol */
YY_RULE_SETUP
#line 164 "pars0lex.l"
{
			/* Got a sequence of characters other than "'":
			append to string buffer */
			string_append(yytext, yyleng);
}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 169 "pars0lex.l"
{
			/* Got a sequence of "'" characters:
			append half of them to string buffer,
			as "''" represents a single "'".
			We apply truncating division,
			so that "'''" will result in "'". */

			string_append(yytext, yyleng / 2);

			/* If we got an odd number of quotes, then the
			last quote we got is the terminating quote.
			At the end of the string, we return to the
			initial start state and report the scanned
			string literal. */

			if (yyleng % 2) {
				BEGIN(INITIAL);
				yylval = sym_tab_add_str_lit(
					pars_sym_tab_global,
					(byte*) stringbuf, stringbuf_len);
				return(PARS_STR_LIT);
			}
}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 193 "pars0lex.l"
{
/* Quoted identifiers are handled in an explicit start state 'id'.
This state is entered and the buffer for the scanned string is emptied
upon encountering a starting quote.

In the state 'id', only two actions are possible (defined below). */
			BEGIN(id);
			stringbuf_len = 0;
}
	YY_BREAK
case 9:
/* rule 9 can match eol */
YY_RULE_SETUP
#line 202 "pars0lex.l"
{
			/* Got a sequence of characters other than '"':
			append to string buffer */
			string_append(yytext, yyleng);
}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 207 "pars0lex.l"
{
			/* Got a sequence of '"' characters:
			append half of them to string buffer,
			as '""' represents a single '"'.
			We apply truncating division,
			so that '"""' will result in '"'. */

			string_append(yytext, yyleng / 2);

			/* If we got an odd number of quotes, then the
			last quote we got is the terminating quote.
			At the end of the string, we return to the
			initial start state and report the scanned
			identifier. */

			if (yyleng % 2) {
				BEGIN(INITIAL);
				yylval = sym_tab_add_id(
					pars_sym_tab_global,
					(byte*) stringbuf, stringbuf_len);

				return(PARS_ID_TOKEN);
			}
}
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 232 "pars0lex.l"
{
			yylval = sym_tab_add_null_lit(pars_sym_tab_global);

			return(PARS_NULL_LIT);
}
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 238 "pars0lex.l"
{
			/* Implicit cursor name */
			yylval = sym_tab_add_str_lit(pars_sym_tab_global,
							(byte*) yytext, yyleng);
			return(PARS_SQL_TOKEN);
}
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 245 "pars0lex.l"
{
			return(PARS_AND_TOKEN);
}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 249 "pars0lex.l"
{
			return(PARS_OR_TOKEN);
}
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 253 "pars0lex.l"
{
			return(PARS_NOT_TOKEN);
}
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 257 "pars0lex.l"
{
			return(PARS_PROCEDURE_TOKEN);
}
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 261 "pars0lex.l"
{
			return(PARS_IN_TOKEN);
}
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 265 "pars0lex.l"
{
			return(PARS_OUT_TOKEN);
}
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 269 "pars0lex.l"
{
	 		return(PARS_BINARY_TOKEN);
}
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 273 "pars0lex.l"
{
	 		return(PARS_BLOB_TOKEN);
}
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 277 "pars0lex.l"
{
	 		return(PARS_INT_TOKEN);
}
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 281 "pars0lex.l"
{
	 		return(PARS_INT_TOKEN);
}
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 285 "pars0lex.l"
{
	 		return(PARS_FLOAT_TOKEN);
}
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 289 "pars0lex.l"
{
	 		return(PARS_CHAR_TOKEN);
}
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 293 "pars0lex.l"
{
			return(PARS_IS_TOKEN);
}
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 297 "pars0lex.l"
{
			return(PARS_BEGIN_TOKEN);
}
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 301 "pars0lex.l"
{
			return(PARS_END_TOKEN);
}
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 305 "pars0lex.l"
{
			return(PARS_IF_TOKEN);
}
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 309 "pars0lex.l"
{
			return(PARS_THEN_TOKEN);
}
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 313 "pars0lex.l"
{
			return(PARS_ELSE_TOKEN);
}
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 317 "pars0lex.l"
{
			return(PARS_ELSIF_TOKEN);
}
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 321 "pars0lex.l"
{
			return(PARS_LOOP_TOKEN);
}
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 325 "pars0lex.l"
{
			return(PARS_WHILE_TOKEN);
}
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 329 "pars0lex.l"
{
			return(PARS_RETURN_TOKEN);
}
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 333 "pars0lex.l"
{
			return(PARS_SELECT_TOKEN);
}
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 337 "pars0lex.l"
{
			return(PARS_SUM_TOKEN);
}
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 341 "pars0lex.l"
{
			return(PARS_COUNT_TOKEN);
}
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 345 "pars0lex.l"
{
			return(PARS_DISTINCT_TOKEN);
}
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 349 "pars0lex.l"
{
			return(PARS_FROM_TOKEN);
}
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 353 "pars0lex.l"
{
			return(PARS_WHERE_TOKEN);
}
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 357 "pars0lex.l"
{
			return(PARS_FOR_TOKEN);
}
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 361 "pars0lex.l"
{
			return(PARS_READ_TOKEN);
}
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 365 "pars0lex.l"
{
			return(PARS_ORDER_TOKEN);
}
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 369 "pars0lex.l"
{
			return(PARS_BY_TOKEN);
}
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 373 "pars0lex.l"
{
			return(PARS_ASC_TOKEN);
}
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 377 "pars0lex.l"
{
			return(PARS_DESC_TOKEN);
}
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 381 "pars0lex.l"
{
			return(PARS_INSERT_TOKEN);
}
	YY_BREAK
case 48:
YY_RULE_SETUP
#line 385 "pars0lex.l"
{
			return(PARS_INTO_TOKEN);
}
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 389 "pars0lex.l"
{
			return(PARS_VALUES_TOKEN);
}
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 393 "pars0lex.l"
{
			return(PARS_UPDATE_TOKEN);
}
	YY_BREAK
case 51:
YY_RULE_SETUP
#line 397 "pars0lex.l"
{
			return(PARS_SET_TOKEN);
}
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 401 "pars0lex.l"
{
			return(PARS_DELETE_TOKEN);
}
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 405 "pars0lex.l"
{
			return(PARS_CURRENT_TOKEN);
}
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 409 "pars0lex.l"
{
			return(PARS_OF_TOKEN);
}
	YY_BREAK
case 55:
YY_RULE_SETUP
#line 413 "pars0lex.l"
{
			return(PARS_CREATE_TOKEN);
}
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 417 "pars0lex.l"
{
			return(PARS_TABLE_TOKEN);
}
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 421 "pars0lex.l"
{
	 		return(PARS_INDEX_TOKEN);
}
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 425 "pars0lex.l"
{
	 		return(PARS_UNIQUE_TOKEN);
}
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 429 "pars0lex.l"
{
	 		return(PARS_CLUSTERED_TOKEN);
}
	YY_BREAK
case 60:
YY_RULE_SETUP
#line 433 "pars0lex.l"
{
			return(PARS_DOES_NOT_FIT_IN_MEM_TOKEN);
}
	YY_BREAK
case 61:
YY_RULE_SETUP
#line 437 "pars0lex.l"
{
	 		return(PARS_ON_TOKEN);
}
	YY_BREAK
case 62:
YY_RULE_SETUP
#line 441 "pars0lex.l"
{
			return(PARS_DECLARE_TOKEN);
}
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 445 "pars0lex.l"
{
			return(PARS_CURSOR_TOKEN);
}
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 449 "pars0lex.l"
{
			return(PARS_OPEN_TOKEN);
}
	YY_BREAK
case 65:
YY_RULE_SETUP
#line 453 "pars0lex.l"
{
			return(PARS_FETCH_TOKEN);
}
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 457 "pars0lex.l"
{
			return(PARS_CLOSE_TOKEN);
}
	YY_BREAK
case 67:
YY_RULE_SETUP
#line 461 "pars0lex.l"
{
			return(PARS_NOTFOUND_TOKEN);
}
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 465 "pars0lex.l"
{
			return(PARS_TO_CHAR_TOKEN);
}
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 469 "pars0lex.l"
{
			return(PARS_TO_NUMBER_TOKEN);
}
	YY_BREAK
case 70:
YY_RULE_SETUP
#line 473 "pars0lex.l"
{
			return(PARS_TO_BINARY_TOKEN);
}
	YY_BREAK
case 71:
YY_RULE_SETUP
#line 477 "pars0lex.l"
{
			return(PARS_BINARY_TO_NUMBER_TOKEN);
}
	YY_BREAK
case 72:
YY_RULE_SETUP
#line 481 "pars0lex.l"
{
			return(PARS_SUBSTR_TOKEN);
}
	YY_BREAK
case 73:
YY_RULE_SETUP
#line 485 "pars0lex.l"
{
			return(PARS_REPLSTR_TOKEN);
}
	YY_BREAK
case 74:
YY_RULE_SETUP
#line 489 "pars0lex.l"
{
			return(PARS_CONCAT_TOKEN);
}
	YY_BREAK
case 75:
YY_RULE_SETUP
#line 493 "pars0lex.l"
{
			return(PARS_INSTR_TOKEN);
}
	YY_BREAK
case 76:
YY_RULE_SETUP
#line 497 "pars0lex.l"
{
			return(PARS_LENGTH_TOKEN);
}
	YY_BREAK
case 77:
YY_RULE_SETUP
#line 501 "pars0lex.l"
{
			return(PARS_SYSDATE_TOKEN);
}
	YY_BREAK
case 78:
YY_RULE_SETUP
#line 505 "pars0lex.l"
{
			return(PARS_PRINTF_TOKEN);
}
	YY_BREAK
case 79:
YY_RULE_SETUP
#line 509 "pars0lex.l"
{
			return(PARS_ASSERT_TOKEN);
}
	YY_BREAK
case 80:
YY_RULE_SETUP
#line 513 "pars0lex.l"
{
			return(PARS_RND_TOKEN);
}
	YY_BREAK
case 81:
YY_RULE_SETUP
#line 517 "pars0lex.l"
{
			return(PARS_RND_STR_TOKEN);
}
	YY_BREAK
case 82:
YY_RULE_SETUP
#line 521 "pars0lex.l"
{
			return(PARS_ROW_PRINTF_TOKEN);
}
	YY_BREAK
case 83:
YY_RULE_SETUP
#line 525 "pars0lex.l"
{
			return(PARS_COMMIT_TOKEN);
}
	YY_BREAK
case 84:
YY_RULE_SETUP
#line 529 "pars0lex.l"
{
			return(PARS_ROLLBACK_TOKEN);
}
	YY_BREAK
case 85:
YY_RULE_SETUP
#line 533 "pars0lex.l"
{
			return(PARS_WORK_TOKEN);
}
	YY_BREAK
case 86:
YY_RULE_SETUP
#line 537 "pars0lex.l"
{
			return(PARS_UNSIGNED_TOKEN);
}
	YY_BREAK
case 87:
YY_RULE_SETUP
#line 541 "pars0lex.l"
{
			return(PARS_EXIT_TOKEN);
}
	YY_BREAK
case 88:
YY_RULE_SETUP
#line 545 "pars0lex.l"
{
			return(PARS_FUNCTION_TOKEN);
}
	YY_BREAK
case 89:
YY_RULE_SETUP
#line 549 "pars0lex.l"
{
			return(PARS_LOCK_TOKEN);
}
	YY_BREAK
case 90:
YY_RULE_SETUP
#line 553 "pars0lex.l"
{
			return(PARS_SHARE_TOKEN);
}
	YY_BREAK
case 91:
YY_RULE_SETUP
#line 557 "pars0lex.l"
{
			return(PARS_MODE_TOKEN);
}
	YY_BREAK
case 92:
YY_RULE_SETUP
#line 561 "pars0lex.l"
{
			yylval = sym_tab_add_id(pars_sym_tab_global,
							(byte*)yytext,
							ut_strlen(yytext));
			return(PARS_ID_TOKEN);
}
	YY_BREAK
case 93:
YY_RULE_SETUP
#line 568 "pars0lex.l"
{
			return(PARS_DDOT_TOKEN);
}
	YY_BREAK
case 94:
YY_RULE_SETUP
#line 572 "pars0lex.l"
{
			return(PARS_ASSIGN_TOKEN);
}
	YY_BREAK
case 95:
YY_RULE_SETUP
#line 576 "pars0lex.l"
{
			return(PARS_LE_TOKEN);
}
	YY_BREAK
case 96:
YY_RULE_SETUP
#line 580 "pars0lex.l"
{
			return(PARS_GE_TOKEN);
}
	YY_BREAK
case 97:
YY_RULE_SETUP
#line 584 "pars0lex.l"
{
			return(PARS_NE_TOKEN);
}
	YY_BREAK
case 98:
YY_RULE_SETUP
#line 588 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 99:
YY_RULE_SETUP
#line 593 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 100:
YY_RULE_SETUP
#line 598 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 101:
YY_RULE_SETUP
#line 603 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 102:
YY_RULE_SETUP
#line 608 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 103:
YY_RULE_SETUP
#line 613 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 104:
YY_RULE_SETUP
#line 618 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 105:
YY_RULE_SETUP
#line 623 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 106:
YY_RULE_SETUP
#line 628 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 107:
YY_RULE_SETUP
#line 633 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 108:
YY_RULE_SETUP
#line 638 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 109:
YY_RULE_SETUP
#line 643 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 110:
YY_RULE_SETUP
#line 648 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 111:
YY_RULE_SETUP
#line 653 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 112:
YY_RULE_SETUP
#line 658 "pars0lex.l"
{

			return((int)(*yytext));
}
	YY_BREAK
case 113:
YY_RULE_SETUP
#line 663 "pars0lex.l"
BEGIN(comment); /* eat up comment */
	YY_BREAK
case 114:
/* rule 114 can match eol */
YY_RULE_SETUP
#line 665 "pars0lex.l"

	YY_BREAK
case 115:
/* rule 115 can match eol */
YY_RULE_SETUP
#line 666 "pars0lex.l"

	YY_BREAK
case 116:
YY_RULE_SETUP
#line 667 "pars0lex.l"
BEGIN(INITIAL);
	YY_BREAK
case 117:
/* rule 117 can match eol */
YY_RULE_SETUP
#line 669 "pars0lex.l"
/* eat up whitespace */
	YY_BREAK
case 118:
YY_RULE_SETUP
#line 672 "pars0lex.l"
{
			ib_logger(ib_stream,"Unrecognized character: %02x\n",
				*yytext);

			ut_error;

			return(0);
}
	YY_BREAK
case 119:
YY_RULE_SETUP
#line 681 "pars0lex.l"
YY_FATAL_ERROR( "flex scanner jammed" );
	YY_BREAK
#line 1997 "lexyy.c"
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(comment):
case YY_STATE_EOF(quoted):
case YY_STATE_EOF(id):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = (yy_hold_char);
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state(  );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = (yytext_ptr) + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++(yy_c_buf_p);
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = (yy_last_accepting_cpos);
				yy_current_state = (yy_last_accepting_state);
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer(  ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap( ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				(yy_c_buf_p) =
					(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

				yy_current_state = yy_get_previous_state(  );

				yy_cp = (yy_c_buf_p);
				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (void)
{
    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	register char *source = (yytext_ptr);
	register int number_to_move, i;
	int ret_val;

	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

			int yy_c_buf_p_offset =
				(int) ((yy_c_buf_p) - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
						number_to_move - 1;

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			(yy_n_chars), (size_t) num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	if ( (yy_n_chars) == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart(yyin  );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
	}

	(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (void)
{
	register yy_state_type yy_current_state;
	register char *yy_cp;
    
	yy_current_state = (yy_start);

	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		if ( yy_accept[yy_current_state] )
			{
			(yy_last_accepting_state) = yy_current_state;
			(yy_last_accepting_cpos) = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 399 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
{
	register int yy_is_jam;
    	register char *yy_cp = (yy_c_buf_p);

	register YY_CHAR yy_c = 1;
	if ( yy_accept[yy_current_state] )
		{
		(yy_last_accepting_state) = yy_current_state;
		(yy_last_accepting_cpos) = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 399 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 398);

	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (void)
#else
    static int input  (void)
#endif

{
	int c;
    
	*(yy_c_buf_p) = (yy_hold_char);

	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
			/* This was really a NUL. */
			*(yy_c_buf_p) = '\0';

		else
			{ /* need more input */
			int offset = (int)((yy_c_buf_p) - (yytext_ptr));
			++(yy_c_buf_p);

			switch ( yy_get_next_buffer(  ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart(yyin );

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( ) )
						return EOF;

					if ( ! (yy_did_buffer_switch_on_eof) )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					(yy_c_buf_p) = (yytext_ptr) + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
	*(yy_c_buf_p) = '\0';	/* preserve yytext */
	(yy_hold_char) = *++(yy_c_buf_p);

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
    static void yyrestart  (FILE * input_file )
{
    
	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack ();
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer(yyin,YY_BUF_SIZE );
	}

	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
	yy_load_buffer_state( );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
    __attribute__((unused)) static void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
{
    
	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack ();
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	(yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state  (void)
{
    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	(yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
    static YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer(b,file );

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * 
 */
    static void yy_delete_buffer (YY_BUFFER_STATE  b )
{
    
	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree((void *) b->yy_ch_buf  );

	yyfree((void *) b  );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )

{
	int oerrno = errno;
    
	yy_flush_buffer(b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
    static void yy_flush_buffer (YY_BUFFER_STATE  b )
{
    	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
__attribute__((unused)) static void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
{
    	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack();

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*(yy_c_buf_p) = (yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		(yy_buffer_stack_top)++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( );
	(yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
__attribute__((unused)) static void yypop_buffer_state (void)
{
    	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER );
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if ((yy_buffer_stack_top) > 0)
		--(yy_buffer_stack_top);

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( );
		(yy_did_buffer_switch_on_eof) = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (void)
{
	int num_to_alloc;
    
	if (!(yy_buffer_stack)) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
		num_to_alloc = 1;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
								  
		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
				
		(yy_buffer_stack_max) = num_to_alloc;
		(yy_buffer_stack_top) = 0;
		return;
	}

	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){

		/* Increase the buffer to prepare for a possible push. */
		int grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = (yy_buffer_stack_max) + grow_size;
		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
								((yy_buffer_stack),
								num_to_alloc * sizeof(struct yy_buffer_state*)
								);
		if ( ! (yy_buffer_stack) )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		(yy_buffer_stack_max) = num_to_alloc;
	}
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yy_fatal_error (yyconst char* msg )
{
    	(void) ib_logger(ib_stream, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
__attribute__((unused)) static int yyget_lineno  (void)
{
        
    return yylineno;
}

/** Get the input stream.
 * 
 */
__attribute__((unused)) static FILE *yyget_in  (void)
{
        return yyin;
}

/** Get the output stream.
 * 
 */
__attribute__((unused)) static FILE *yyget_out  (void)
{
        return yyout;
}

/** Get the length of the current token.
 * 
 */
__attribute__((unused)) static int yyget_leng  (void)
{
        return yyleng;
}

/** Get the current token.
 * 
 */

__attribute__((unused)) static char *yyget_text  (void)
{
        return yytext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
__attribute__((unused)) static void yyset_lineno (int  line_number )
{
    
    yylineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see yy_switch_to_buffer
 */
__attribute__((unused)) static void yyset_in (FILE *  in_str )
{
        yyin = in_str ;
}

__attribute__((unused)) static void yyset_out (FILE *  out_str )
{
        yyout = out_str ;
}

__attribute__((unused)) static int yyget_debug  (void)
{
        return yy_flex_debug;
}

__attribute__((unused)) static void yyset_debug (int  bdebug )
{
        yy_flex_debug = bdebug ;
}

static int yy_init_globals (void)
{
        /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    (yy_buffer_stack) = 0;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = (char *) 0;
    (yy_init) = 0;
    (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = (FILE *) 0;
    yyout = (FILE *) 0;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
__attribute__((unused)) static int yylex_destroy  (void)
{
    
    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer(YY_CURRENT_BUFFER  );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state();
	}

	/* Destroy the stack itself. */
	yyfree((yy_buffer_stack) );
	(yy_buffer_stack) = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( );

    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char * s )
{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

static void *yyalloc (yy_size_t  size )
{
	return (void *) malloc( size );
}

static void *yyrealloc  (void * ptr, yy_size_t  size )
{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
}

static void yyfree (void * ptr )
{
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 681 "pars0lex.l"



/**********************************************************************
Release any resources used by the lexer. */
UNIV_INTERN
void
pars_lexer_close(void)
/*==================*/
{
	yylex_destroy();

	if (stringbuf != NULL) {
		ut_free(stringbuf);
		stringbuf = NULL;
		stringbuf_len_alloc = stringbuf_len = 0;
	}
}

/* This definition is added here to get rid of a warning. */
__attribute__((unused)) static void yyset_extra(void* p) { }
/*****************************************************************************

Copyright (c) 1995, 2009, Innobase Oy. All Rights Reserved.
Copyright (c) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004 Free Software
Foundation, Inc.

As a special exception, when this file is copied by Bison into a
Bison output file, you may use that output file without restriction.
This special exception was added by the Free Software Foundation
in version 1.24 of Bison.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA
*****************************************************************************/

/* A Bison parser, made by GNU Bison 2.0.  */

/* Written by Richard Stallman by simplifying the original so called
   ``semantic'' parser.  */

/* C LALR(1) parser skeleton written by Richard Stallman, by
   simplifying the original so-called "semantic" parser.  */

/* All symbols defined below should begin with yy or YY, to avoid
   infringing on user name space.  This should be done even for local
   variables, as they might otherwise be expanded by user macros.
   There are some unavoidable exceptions within include files to
   define necessary library symbols; they are noted "INFRINGES ON
   USER NAME SPACE" below.  */

/* Identify Bison output.  */
#define YYBISON 1

/* Bison version.  */
#define YYBISON_VERSION "2.3"

/* Skeleton name.  */
#define YYSKELETON_NAME "yacc.c"

/* Pure parsers.  */
#define YYPURE 0

/* Using locations.  */
#define YYLSP_NEEDED 0



/* Tokens.  */
#ifndef YYTOKENTYPE
# define YYTOKENTYPE
   /* Put the tokens into the symbol table, so that GDB and other debuggers
      know about them.  */
   enum yytokentype {
     PARS_INT_LIT = 258,
     PARS_FLOAT_LIT = 259,
     PARS_STR_LIT = 260,
     PARS_FIXBINARY_LIT = 261,
     PARS_BLOB_LIT = 262,
     PARS_NULL_LIT = 263,
     PARS_ID_TOKEN = 264,
     PARS_AND_TOKEN = 265,
     PARS_OR_TOKEN = 266,
     PARS_NOT_TOKEN = 267,
     PARS_GE_TOKEN = 268,
     PARS_LE_TOKEN = 269,
     PARS_NE_TOKEN = 270,
     PARS_PROCEDURE_TOKEN = 271,
     PARS_IN_TOKEN = 272,
     PARS_OUT_TOKEN = 273,
     PARS_BINARY_TOKEN = 274,
     PARS_BLOB_TOKEN = 275,
     PARS_INT_TOKEN = 276,
     PARS_INTEGER_TOKEN = 277,
     PARS_FLOAT_TOKEN = 278,
     PARS_CHAR_TOKEN = 279,
     PARS_IS_TOKEN = 280,
     PARS_BEGIN_TOKEN = 281,
     PARS_END_TOKEN = 282,
     PARS_IF_TOKEN = 283,
     PARS_THEN_TOKEN = 284,
     PARS_ELSE_TOKEN = 285,
     PARS_ELSIF_TOKEN = 286,
     PARS_LOOP_TOKEN = 287,
     PARS_WHILE_TOKEN = 288,
     PARS_RETURN_TOKEN = 289,
     PARS_SELECT_TOKEN = 290,
     PARS_SUM_TOKEN = 291,
     PARS_COUNT_TOKEN = 292,
     PARS_DISTINCT_TOKEN = 293,
     PARS_FROM_TOKEN = 294,
     PARS_WHERE_TOKEN = 295,
     PARS_FOR_TOKEN = 296,
     PARS_DDOT_TOKEN = 297,
     PARS_READ_TOKEN = 298,
     PARS_ORDER_TOKEN = 299,
     PARS_BY_TOKEN = 300,
     PARS_ASC_TOKEN = 301,
     PARS_DESC_TOKEN = 302,
     PARS_INSERT_TOKEN = 303,
     PARS_INTO_TOKEN = 304,
     PARS_VALUES_TOKEN = 305,
     PARS_UPDATE_TOKEN = 306,
     PARS_SET_TOKEN = 307,
     PARS_DELETE_TOKEN = 308,
     PARS_CURRENT_TOKEN = 309,
     PARS_OF_TOKEN = 310,
     PARS_CREATE_TOKEN = 311,
     PARS_TABLE_TOKEN = 312,
     PARS_INDEX_TOKEN = 313,
     PARS_UNIQUE_TOKEN = 314,
     PARS_CLUSTERED_TOKEN = 315,
     PARS_DOES_NOT_FIT_IN_MEM_TOKEN = 316,
     PARS_ON_TOKEN = 317,
     PARS_ASSIGN_TOKEN = 318,
     PARS_DECLARE_TOKEN = 319,
     PARS_CURSOR_TOKEN = 320,
     PARS_SQL_TOKEN = 321,
     PARS_OPEN_TOKEN = 322,
     PARS_FETCH_TOKEN = 323,
     PARS_CLOSE_TOKEN = 324,
     PARS_NOTFOUND_TOKEN = 325,
     PARS_TO_CHAR_TOKEN = 326,
     PARS_TO_NUMBER_TOKEN = 327,
     PARS_TO_BINARY_TOKEN = 328,
     PARS_BINARY_TO_NUMBER_TOKEN = 329,
     PARS_SUBSTR_TOKEN = 330,
     PARS_REPLSTR_TOKEN = 331,
     PARS_CONCAT_TOKEN = 332,
     PARS_INSTR_TOKEN = 333,
     PARS_LENGTH_TOKEN = 334,
     PARS_SYSDATE_TOKEN = 335,
     PARS_PRINTF_TOKEN = 336,
     PARS_ASSERT_TOKEN = 337,
     PARS_RND_TOKEN = 338,
     PARS_RND_STR_TOKEN = 339,
     PARS_ROW_PRINTF_TOKEN = 340,
     PARS_COMMIT_TOKEN = 341,
     PARS_ROLLBACK_TOKEN = 342,
     PARS_WORK_TOKEN = 343,
     PARS_UNSIGNED_TOKEN = 344,
     PARS_EXIT_TOKEN = 345,
     PARS_FUNCTION_TOKEN = 346,
     PARS_LOCK_TOKEN = 347,
     PARS_SHARE_TOKEN = 348,
     PARS_MODE_TOKEN = 349,
     NEG = 350
   };
#endif
/* Tokens.  */
#define PARS_INT_LIT 258
#define PARS_FLOAT_LIT 259
#define PARS_STR_LIT 260
#define PARS_FIXBINARY_LIT 261
#define PARS_BLOB_LIT 262
#define PARS_NULL_LIT 263
#define PARS_ID_TOKEN 264
#define PARS_AND_TOKEN 265
#define PARS_OR_TOKEN 266
#define PARS_NOT_TOKEN 267
#define PARS_GE_TOKEN 268
#define PARS_LE_TOKEN 269
#define PARS_NE_TOKEN 270
#define PARS_PROCEDURE_TOKEN 271
#define PARS_IN_TOKEN 272
#define PARS_OUT_TOKEN 273
#define PARS_BINARY_TOKEN 274
#define PARS_BLOB_TOKEN 275
#define PARS_INT_TOKEN 276
#define PARS_INTEGER_TOKEN 277
#define PARS_FLOAT_TOKEN 278
#define PARS_CHAR_TOKEN 279
#define PARS_IS_TOKEN 280
#define PARS_BEGIN_TOKEN 281
#define PARS_END_TOKEN 282
#define PARS_IF_TOKEN 283
#define PARS_THEN_TOKEN 284
#define PARS_ELSE_TOKEN 285
#define PARS_ELSIF_TOKEN 286
#define PARS_LOOP_TOKEN 287
#define PARS_WHILE_TOKEN 288
#define PARS_RETURN_TOKEN 289
#define PARS_SELECT_TOKEN 290
#define PARS_SUM_TOKEN 291
#define PARS_COUNT_TOKEN 292
#define PARS_DISTINCT_TOKEN 293
#define PARS_FROM_TOKEN 294
#define PARS_WHERE_TOKEN 295
#define PARS_FOR_TOKEN 296
#define PARS_DDOT_TOKEN 297
#define PARS_READ_TOKEN 298
#define PARS_ORDER_TOKEN 299
#define PARS_BY_TOKEN 300
#define PARS_ASC_TOKEN 301
#define PARS_DESC_TOKEN 302
#define PARS_INSERT_TOKEN 303
#define PARS_INTO_TOKEN 304
#define PARS_VALUES_TOKEN 305
#define PARS_UPDATE_TOKEN 306
#define PARS_SET_TOKEN 307
#define PARS_DELETE_TOKEN 308
#define PARS_CURRENT_TOKEN 309
#define PARS_OF_TOKEN 310
#define PARS_CREATE_TOKEN 311
#define PARS_TABLE_TOKEN 312
#define PARS_INDEX_TOKEN 313
#define PARS_UNIQUE_TOKEN 314
#define PARS_CLUSTERED_TOKEN 315
#define PARS_DOES_NOT_FIT_IN_MEM_TOKEN 316
#define PARS_ON_TOKEN 317
#define PARS_ASSIGN_TOKEN 318
#define PARS_DECLARE_TOKEN 319
#define PARS_CURSOR_TOKEN 320
#define PARS_SQL_TOKEN 321
#define PARS_OPEN_TOKEN 322
#define PARS_FETCH_TOKEN 323
#define PARS_CLOSE_TOKEN 324
#define PARS_NOTFOUND_TOKEN 325
#define PARS_TO_CHAR_TOKEN 326
#define PARS_TO_NUMBER_TOKEN 327
#define PARS_TO_BINARY_TOKEN 328
#define PARS_BINARY_TO_NUMBER_TOKEN 329
#define PARS_SUBSTR_TOKEN 330
#define PARS_REPLSTR_TOKEN 331
#define PARS_CONCAT_TOKEN 332
#define PARS_INSTR_TOKEN 333
#define PARS_LENGTH_TOKEN 334
#define PARS_SYSDATE_TOKEN 335
#define PARS_PRINTF_TOKEN 336
#define PARS_ASSERT_TOKEN 337
#define PARS_RND_TOKEN 338
#define PARS_RND_STR_TOKEN 339
#define PARS_ROW_PRINTF_TOKEN 340
#define PARS_COMMIT_TOKEN 341
#define PARS_ROLLBACK_TOKEN 342
#define PARS_WORK_TOKEN 343
#define PARS_UNSIGNED_TOKEN 344
#define PARS_EXIT_TOKEN 345
#define PARS_FUNCTION_TOKEN 346
#define PARS_LOCK_TOKEN 347
#define PARS_SHARE_TOKEN 348
#define PARS_MODE_TOKEN 349
#define NEG 350




/* Copy the first part of user declarations.  */
#line 13 "pars0grm.y"

/* The value of the semantic attribute is a pointer to a query tree node
que_node_t */

#include "univ.i"
#include <math.h>				/* Can't be before univ.i */
#include "pars0pars.h"
#include "mem0mem.h"
#include "que0types.h"
#include "que0que.h"
#include "row0sel.h"

#define YYSTYPE que_node_t*

/* #define __STDC__ */

int
yylex(void);


/* Enabling traces.  */
#ifndef YYDEBUG
# define YYDEBUG 0
#endif

/* Enabling verbose error messages.  */
#ifdef YYERROR_VERBOSE
# undef YYERROR_VERBOSE
# define YYERROR_VERBOSE 1
#else
# define YYERROR_VERBOSE 0
#endif

/* Enabling the token table.  */
#ifndef YYTOKEN_TABLE
# define YYTOKEN_TABLE 0
#endif

#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef int YYSTYPE;
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
# define YYSTYPE_IS_TRIVIAL 1
#endif



/* Copy the second part of user declarations.  */


/* Line 216 of yacc.c.  */
#line 316 "pars0grm.c"

#ifdef short
# undef short
#endif

#ifdef YYTYPE_UINT8
typedef YYTYPE_UINT8 yytype_uint8;
#else
typedef unsigned char yytype_uint8;
#endif

#ifdef YYTYPE_INT8
typedef YYTYPE_INT8 yytype_int8;
#elif (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
typedef signed char yytype_int8;
#else
typedef short int yytype_int8;
#endif

#ifdef YYTYPE_UINT16
typedef YYTYPE_UINT16 yytype_uint16;
#else
typedef unsigned short int yytype_uint16;
#endif

#ifdef YYTYPE_INT16
typedef YYTYPE_INT16 yytype_int16;
#else
typedef short int yytype_int16;
#endif

#ifndef YYSIZE_T
# ifdef __SIZE_TYPE__
#  define YYSIZE_T __SIZE_TYPE__
# elif defined size_t
#  define YYSIZE_T size_t
# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
#  define YYSIZE_T size_t
# else
#  define YYSIZE_T unsigned int
# endif
#endif

#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)

#ifndef YY_
# if YYENABLE_NLS
#  if ENABLE_NLS
#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
#   define YY_(msgid) dgettext ("bison-runtime", msgid)
#  endif
# endif
# ifndef YY_
#  define YY_(msgid) msgid
# endif
#endif

/* Suppress unused-variable warnings by "using" E.  */
#if ! defined lint || defined __GNUC__
# define YYUSE(e) ((void) (e))
#else
# define YYUSE(e) /* empty */
#endif

/* Identity function, used to suppress warnings about constant conditions.  */
#ifndef lint
# define YYID(n) (n)
#else
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC int
YYID (int i)
#else
UNIV_STATIC int
YYID (i)
    int i;
#endif
{
  return i;
}
#endif

#if ! defined yyoverflow || YYERROR_VERBOSE

/* The parser invokes alloca or malloc; define the necessary symbols.  */

# ifdef YYSTACK_USE_ALLOCA
#  if YYSTACK_USE_ALLOCA
#   ifdef __GNUC__
#    define YYSTACK_ALLOC __builtin_alloca
#   elif defined __BUILTIN_VA_ARG_INCR
#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
#   elif defined _AIX
#    define YYSTACK_ALLOC __alloca
#   elif defined _MSC_VER
#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
#    define alloca _alloca
#   else
#    define YYSTACK_ALLOC alloca
#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#     ifndef _STDLIB_H
#      define _STDLIB_H 1
#     endif
#    endif
#   endif
#  endif
# endif

# ifdef YYSTACK_ALLOC
   /* Pacify GCC's `empty if-body' warning.  */
#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
#  ifndef YYSTACK_ALLOC_MAXIMUM
    /* The OS might guarantee only one guard page at the bottom of the stack,
       and a page size can be as small as 4096 bytes.  So we cannot safely
       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
       to allow for a few compiler-allocated temporary stack slots.  */
#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
#  endif
# else
#  define YYSTACK_ALLOC YYMALLOC
#  define YYSTACK_FREE YYFREE
#  ifndef YYSTACK_ALLOC_MAXIMUM
#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
#  endif
#  if (defined __cplusplus && ! defined _STDLIB_H \
       && ! ((defined YYMALLOC || defined malloc) \
	     && (defined YYFREE || defined free)))
#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
#   ifndef _STDLIB_H
#    define _STDLIB_H 1
#   endif
#  endif
#  ifndef YYMALLOC
#   define YYMALLOC malloc
#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
#  ifndef YYFREE
#   define YYFREE free
#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
void free (void *); /* INFRINGES ON USER NAME SPACE */
#   endif
#  endif
# endif
#endif /* ! defined yyoverflow || YYERROR_VERBOSE */


#if (! defined yyoverflow \
     && (! defined __cplusplus \
	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))

/* A type that is properly aligned for any stack member.  */
union yyalloc
{
  yytype_int16 yyss;
  YYSTYPE yyvs;
  };

/* The size of the maximum gap between one aligned stack and the next.  */
# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)

/* The size of an array large to enough to hold all stacks, each with
   N elements.  */
# define YYSTACK_BYTES(N) \
     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
      + YYSTACK_GAP_MAXIMUM)

/* Copy COUNT objects from FROM to TO.  The source and destination do
   not overlap.  */
# ifndef YYCOPY
#  if defined __GNUC__ && 1 < __GNUC__
#   define YYCOPY(To, From, Count) \
      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
#  else
#   define YYCOPY(To, From, Count)		\
      do					\
	{					\
	  YYSIZE_T yyi;				\
	  for (yyi = 0; yyi < (Count); yyi++)	\
	    (To)[yyi] = (From)[yyi];		\
	}					\
      while (YYID (0))
#  endif
# endif

/* Relocate STACK from its old location to the new one.  The
   local variables YYSIZE and YYSTACKSIZE give the old and new number of
   elements in the stack, and YYPTR gives the new location of the
   stack.  Advance YYPTR to a properly aligned location for the next
   stack.  */
# define YYSTACK_RELOCATE(Stack)					\
    do									\
      {									\
	YYSIZE_T yynewbytes;						\
	YYCOPY (&yyptr->Stack, Stack, yysize);				\
	Stack = &yyptr->Stack;						\
	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
	yyptr += yynewbytes / sizeof (*yyptr);				\
      }									\
    while (YYID (0))

#endif

/* YYFINAL -- State number of the termination state.  */
#define YYFINAL  5
/* YYLAST -- Last index in YYTABLE.  */
#define YYLAST   752

/* YYNTOKENS -- Number of terminals.  */
#define YYNTOKENS  111
/* YYNNTS -- Number of nonterminals.  */
#define YYNNTS  70
/* YYNRULES -- Number of rules.  */
#define YYNRULES  175
/* YYNRULES -- Number of states.  */
#define YYNSTATES  339

/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
#define YYUNDEFTOK  2
#define YYMAXUTOK   350

#define YYTRANSLATE(YYX)						\
  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)

/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
UNIV_STATIC const yytype_uint8 yytranslate[] =
{
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,   103,     2,     2,
     105,   106,   100,    99,   108,    98,     2,   101,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,   104,
      96,    95,    97,   107,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,   109,     2,   110,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
     102
};

#if YYDEBUG
/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
   YYRHS.  */
UNIV_STATIC const yytype_uint16 yyprhs[] =
{
       0,     0,     3,     6,     8,    11,    14,    17,    20,    23,
      26,    29,    32,    35,    38,    41,    44,    47,    50,    53,
      56,    59,    62,    65,    68,    71,    73,    76,    78,    83,
      85,    87,    89,    91,    93,    95,    97,   101,   105,   109,
     113,   116,   120,   124,   128,   132,   136,   140,   144,   148,
     152,   155,   159,   163,   165,   167,   169,   171,   173,   175,
     177,   179,   181,   183,   185,   186,   188,   192,   199,   204,
     206,   208,   210,   214,   216,   220,   221,   223,   227,   228,
     230,   234,   236,   241,   247,   252,   253,   255,   259,   261,
     265,   267,   268,   271,   272,   275,   276,   281,   282,   284,
     286,   287,   292,   301,   305,   311,   314,   318,   320,   324,
     329,   334,   337,   340,   344,   347,   350,   353,   357,   362,
     364,   367,   368,   371,   373,   381,   388,   399,   401,   403,
     406,   409,   414,   419,   425,   427,   431,   432,   436,   437,
     439,   440,   443,   444,   446,   454,   456,   460,   461,   463,
     464,   466,   477,   480,   483,   485,   487,   489,   491,   493,
     497,   501,   502,   504,   508,   512,   513,   515,   518,   525,
     530,   532,   534,   535,   537,   540
};

/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
UNIV_STATIC const yytype_int16 yyrhs[] =
{
     112,     0,    -1,   180,   104,    -1,   118,    -1,   119,   104,
      -1,   151,   104,    -1,   152,   104,    -1,   153,   104,    -1,
     150,   104,    -1,   154,   104,    -1,   146,   104,    -1,   133,
     104,    -1,   135,   104,    -1,   145,   104,    -1,   143,   104,
      -1,   144,   104,    -1,   140,   104,    -1,   141,   104,    -1,
     155,   104,    -1,   157,   104,    -1,   156,   104,    -1,   169,
     104,    -1,   170,   104,    -1,   164,   104,    -1,   168,   104,
      -1,   113,    -1,   114,   113,    -1,     9,    -1,   116,   105,
     124,   106,    -1,     3,    -1,     4,    -1,     5,    -1,     6,
      -1,     7,    -1,     8,    -1,    66,    -1,   115,    99,   115,
      -1,   115,    98,   115,    -1,   115,   100,   115,    -1,   115,
     101,   115,    -1,    98,   115,    -1,   105,   115,   106,    -1,
     115,    95,   115,    -1,   115,    96,   115,    -1,   115,    97,
     115,    -1,   115,    13,   115,    -1,   115,    14,   115,    -1,
     115,    15,   115,    -1,   115,    10,   115,    -1,   115,    11,
     115,    -1,    12,   115,    -1,     9,   103,    70,    -1,    66,
     103,    70,    -1,    71,    -1,    72,    -1,    73,    -1,    74,
      -1,    75,    -1,    77,    -1,    78,    -1,    79,    -1,    80,
      -1,    83,    -1,    84,    -1,    -1,   107,    -1,   117,   108,
     107,    -1,   109,     9,   105,   117,   106,   110,    -1,   120,
     105,   124,   106,    -1,    76,    -1,    81,    -1,    82,    -1,
       9,   105,   106,    -1,     9,    -1,   122,   108,     9,    -1,
      -1,     9,    -1,   123,   108,     9,    -1,    -1,   115,    -1,
     124,   108,   115,    -1,   115,    -1,    37,   105,   100,   106,
      -1,    37,   105,    38,     9,   106,    -1,    36,   105,   115,
     106,    -1,    -1,   125,    -1,   126,   108,   125,    -1,   100,
      -1,   126,    49,   123,    -1,   126,    -1,    -1,    40,   115,
      -1,    -1,    41,    51,    -1,    -1,    92,    17,    93,    94,
      -1,    -1,    46,    -1,    47,    -1,    -1,    44,    45,     9,
     131,    -1,    35,   127,    39,   122,   128,   129,   130,   132,
      -1,    48,    49,     9,    -1,   134,    50,   105,   124,   106,
      -1,   134,   133,    -1,     9,    95,   115,    -1,   136,    -1,
     137,   108,   136,    -1,    40,    54,    55,     9,    -1,    51,
       9,    52,   137,    -1,   139,   128,    -1,   139,   138,    -1,
      53,    39,     9,    -1,   142,   128,    -1,   142,   138,    -1,
      85,   133,    -1,     9,    63,   115,    -1,    31,   115,    29,
     114,    -1,   147,    -1,   148,   147,    -1,    -1,    30,   114,
      -1,   148,    -1,    28,   115,    29,   114,   149,    27,    28,
      -1,    33,   115,    32,   114,    27,    32,    -1,    41,     9,
      17,   115,    42,   115,    32,   114,    27,    32,    -1,    90,
      -1,    34,    -1,    67,     9,    -1,    69,     9,    -1,    68,
       9,    49,   123,    -1,    68,     9,    49,   121,    -1,     9,
     171,   160,   161,   162,    -1,   158,    -1,   159,   108,   158,
      -1,    -1,   105,     3,   106,    -1,    -1,    89,    -1,    -1,
      12,     8,    -1,    -1,    61,    -1,    56,    57,     9,   105,
     159,   106,   163,    -1,     9,    -1,   165,   108,     9,    -1,
      -1,    59,    -1,    -1,    60,    -1,    56,   166,   167,    58,
       9,    62,     9,   105,   165,   106,    -1,    86,    88,    -1,
      87,    88,    -1,    21,    -1,    22,    -1,    24,    -1,    19,
      -1,    20,    -1,     9,    17,   171,    -1,     9,    18,   171,
      -1,    -1,   172,    -1,   173,   108,   172,    -1,     9,   171,
     104,    -1,    -1,   174,    -1,   175,   174,    -1,    64,    65,
       9,    25,   133,   104,    -1,    64,    91,     9,   104,    -1,
     176,    -1,   177,    -1,    -1,   178,    -1,   179,   178,    -1,
      16,     9,   105,   173,   106,    25,   175,   179,    26,   114,
      27,    -1
};

/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
UNIV_STATIC const yytype_uint16 yyrline[] =
{
       0,   138,   138,   141,   142,   143,   144,   145,   146,   147,
     148,   149,   150,   151,   152,   153,   154,   155,   156,   157,
     158,   159,   160,   161,   162,   166,   167,   172,   173,   175,
     176,   177,   178,   179,   180,   181,   182,   183,   184,   185,
     186,   187,   188,   189,   190,   191,   192,   193,   194,   195,
     196,   197,   199,   204,   205,   206,   207,   209,   210,   211,
     212,   213,   214,   215,   218,   220,   221,   225,   230,   235,
     236,   237,   241,   245,   246,   251,   252,   253,   258,   259,
     260,   264,   265,   270,   276,   283,   284,   285,   290,   292,
     294,   298,   299,   303,   304,   309,   310,   315,   316,   317,
     321,   322,   327,   337,   342,   344,   349,   353,   354,   359,
     365,   372,   377,   382,   388,   393,   398,   403,   408,   414,
     415,   420,   421,   423,   427,   434,   440,   448,   452,   456,
     462,   468,   470,   475,   480,   481,   486,   487,   492,   493,
     499,   500,   506,   507,   513,   519,   520,   525,   526,   530,
     531,   535,   543,   548,   553,   554,   555,   556,   557,   561,
     564,   570,   571,   572,   577,   581,   583,   584,   588,   594,
     599,   600,   603,   605,   606,   610
};
#endif

#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
UNIV_STATIC const char *const yytname[] =
{
  "$end", "error", "$undefined", "PARS_INT_LIT", "PARS_FLOAT_LIT",
  "PARS_STR_LIT", "PARS_FIXBINARY_LIT", "PARS_BLOB_LIT", "PARS_NULL_LIT",
  "PARS_ID_TOKEN", "PARS_AND_TOKEN", "PARS_OR_TOKEN", "PARS_NOT_TOKEN",
  "PARS_GE_TOKEN", "PARS_LE_TOKEN", "PARS_NE_TOKEN",
  "PARS_PROCEDURE_TOKEN", "PARS_IN_TOKEN", "PARS_OUT_TOKEN",
  "PARS_BINARY_TOKEN", "PARS_BLOB_TOKEN", "PARS_INT_TOKEN",
  "PARS_INTEGER_TOKEN", "PARS_FLOAT_TOKEN", "PARS_CHAR_TOKEN",
  "PARS_IS_TOKEN", "PARS_BEGIN_TOKEN", "PARS_END_TOKEN", "PARS_IF_TOKEN",
  "PARS_THEN_TOKEN", "PARS_ELSE_TOKEN", "PARS_ELSIF_TOKEN",
  "PARS_LOOP_TOKEN", "PARS_WHILE_TOKEN", "PARS_RETURN_TOKEN",
  "PARS_SELECT_TOKEN", "PARS_SUM_TOKEN", "PARS_COUNT_TOKEN",
  "PARS_DISTINCT_TOKEN", "PARS_FROM_TOKEN", "PARS_WHERE_TOKEN",
  "PARS_FOR_TOKEN", "PARS_DDOT_TOKEN", "PARS_READ_TOKEN",
  "PARS_ORDER_TOKEN", "PARS_BY_TOKEN", "PARS_ASC_TOKEN", "PARS_DESC_TOKEN",
  "PARS_INSERT_TOKEN", "PARS_INTO_TOKEN", "PARS_VALUES_TOKEN",
  "PARS_UPDATE_TOKEN", "PARS_SET_TOKEN", "PARS_DELETE_TOKEN",
  "PARS_CURRENT_TOKEN", "PARS_OF_TOKEN", "PARS_CREATE_TOKEN",
  "PARS_TABLE_TOKEN", "PARS_INDEX_TOKEN", "PARS_UNIQUE_TOKEN",
  "PARS_CLUSTERED_TOKEN", "PARS_DOES_NOT_FIT_IN_MEM_TOKEN",
  "PARS_ON_TOKEN", "PARS_ASSIGN_TOKEN", "PARS_DECLARE_TOKEN",
  "PARS_CURSOR_TOKEN", "PARS_SQL_TOKEN", "PARS_OPEN_TOKEN",
  "PARS_FETCH_TOKEN", "PARS_CLOSE_TOKEN", "PARS_NOTFOUND_TOKEN",
  "PARS_TO_CHAR_TOKEN", "PARS_TO_NUMBER_TOKEN", "PARS_TO_BINARY_TOKEN",
  "PARS_BINARY_TO_NUMBER_TOKEN", "PARS_SUBSTR_TOKEN", "PARS_REPLSTR_TOKEN",
  "PARS_CONCAT_TOKEN", "PARS_INSTR_TOKEN", "PARS_LENGTH_TOKEN",
  "PARS_SYSDATE_TOKEN", "PARS_PRINTF_TOKEN", "PARS_ASSERT_TOKEN",
  "PARS_RND_TOKEN", "PARS_RND_STR_TOKEN", "PARS_ROW_PRINTF_TOKEN",
  "PARS_COMMIT_TOKEN", "PARS_ROLLBACK_TOKEN", "PARS_WORK_TOKEN",
  "PARS_UNSIGNED_TOKEN", "PARS_EXIT_TOKEN", "PARS_FUNCTION_TOKEN",
  "PARS_LOCK_TOKEN", "PARS_SHARE_TOKEN", "PARS_MODE_TOKEN", "'='", "'<'",
  "'>'", "'-'", "'+'", "'*'", "'/'", "NEG", "'%'", "';'", "'('", "')'",
  "'?'", "','", "'{'", "'}'", "$accept", "top_statement", "statement",
  "statement_list", "exp", "function_name", "question_mark_list",
  "stored_procedure_call", "predefined_procedure_call",
  "predefined_procedure_name", "user_function_call", "table_list",
  "variable_list", "exp_list", "select_item", "select_item_list",
  "select_list", "search_condition", "for_update_clause",
  "lock_shared_clause", "order_direction", "order_by_clause",
  "select_statement", "insert_statement_start", "insert_statement",
  "column_assignment", "column_assignment_list", "cursor_positioned",
  "update_statement_start", "update_statement_searched",
  "update_statement_positioned", "delete_statement_start",
  "delete_statement_searched", "delete_statement_positioned",
  "row_printf_statement", "assignment_statement", "elsif_element",
  "elsif_list", "else_part", "if_statement", "while_statement",
  "for_statement", "exit_statement", "return_statement",
  "open_cursor_statement", "close_cursor_statement", "fetch_statement",
  "column_def", "column_def_list", "opt_column_len", "opt_unsigned",
  "opt_not_null", "not_fit_in_memory", "create_table", "column_list",
  "unique_def", "clustered_def", "create_index", "commit_statement",
  "rollback_statement", "type_name", "parameter_declaration",
  "parameter_declaration_list", "variable_declaration",
  "variable_declaration_list", "cursor_declaration",
  "function_declaration", "declaration", "declaration_list",
  "procedure_definition", 0
};
#endif

# ifdef YYPRINT
/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
   token YYLEX-NUM.  */
UNIV_STATIC const yytype_uint16 yytoknum[] =
{
       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
     345,   346,   347,   348,   349,    61,    60,    62,    45,    43,
      42,    47,   350,    37,    59,    40,    41,    63,    44,   123,
     125
};
# endif

/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
UNIV_STATIC const yytype_uint8 yyr1[] =
{
       0,   111,   112,   113,   113,   113,   113,   113,   113,   113,
     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
     113,   113,   113,   113,   113,   114,   114,   115,   115,   115,
     115,   115,   115,   115,   115,   115,   115,   115,   115,   115,
     115,   115,   115,   115,   115,   115,   115,   115,   115,   115,
     115,   115,   115,   116,   116,   116,   116,   116,   116,   116,
     116,   116,   116,   116,   117,   117,   117,   118,   119,   120,
     120,   120,   121,   122,   122,   123,   123,   123,   124,   124,
     124,   125,   125,   125,   125,   126,   126,   126,   127,   127,
     127,   128,   128,   129,   129,   130,   130,   131,   131,   131,
     132,   132,   133,   134,   135,   135,   136,   137,   137,   138,
     139,   140,   141,   142,   143,   144,   145,   146,   147,   148,
     148,   149,   149,   149,   150,   151,   152,   153,   154,   155,
     156,   157,   157,   158,   159,   159,   160,   160,   161,   161,
     162,   162,   163,   163,   164,   165,   165,   166,   166,   167,
     167,   168,   169,   170,   171,   171,   171,   171,   171,   172,
     172,   173,   173,   173,   174,   175,   175,   175,   176,   177,
     178,   178,   179,   179,   179,   180
};

/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
UNIV_STATIC const yytype_uint8 yyr2[] =
{
       0,     2,     2,     1,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     1,     2,     1,     4,     1,
       1,     1,     1,     1,     1,     1,     3,     3,     3,     3,
       2,     3,     3,     3,     3,     3,     3,     3,     3,     3,
       2,     3,     3,     1,     1,     1,     1,     1,     1,     1,
       1,     1,     1,     1,     0,     1,     3,     6,     4,     1,
       1,     1,     3,     1,     3,     0,     1,     3,     0,     1,
       3,     1,     4,     5,     4,     0,     1,     3,     1,     3,
       1,     0,     2,     0,     2,     0,     4,     0,     1,     1,
       0,     4,     8,     3,     5,     2,     3,     1,     3,     4,
       4,     2,     2,     3,     2,     2,     2,     3,     4,     1,
       2,     0,     2,     1,     7,     6,    10,     1,     1,     2,
       2,     4,     4,     5,     1,     3,     0,     3,     0,     1,
       0,     2,     0,     1,     7,     1,     3,     0,     1,     0,
       1,    10,     2,     2,     1,     1,     1,     1,     1,     3,
       3,     0,     1,     3,     3,     0,     1,     2,     6,     4,
       1,     1,     0,     1,     2,    11
};

/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
   means the default is an error.  */
UNIV_STATIC const yytype_uint8 yydefact[] =
{
       0,     0,     0,     0,     0,     1,     2,   161,     0,   162,
       0,     0,     0,     0,     0,   157,   158,   154,   155,   156,
     159,   160,   165,   163,     0,   166,   172,     0,     0,   167,
     170,   171,   173,     0,   164,     0,     0,     0,   174,     0,
       0,     0,     0,     0,   128,    85,     0,     0,     0,     0,
     147,     0,     0,     0,    69,    70,    71,     0,     0,     0,
     127,     0,    25,     0,     3,     0,     0,     0,     0,     0,
      91,     0,     0,    91,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,   169,     0,    29,    30,    31,    32,    33,    34,    27,
       0,    35,    53,    54,    55,    56,    57,    58,    59,    60,
      61,    62,    63,     0,     0,     0,     0,     0,     0,     0,
      88,    81,    86,    90,     0,     0,     0,     0,     0,     0,
     148,   149,   129,     0,   130,   116,   152,   153,     0,   175,
      26,     4,    78,    11,     0,   105,    12,     0,   111,   112,
      16,    17,   114,   115,    14,    15,    13,    10,     8,     5,
       6,     7,     9,    18,    20,    19,    23,    24,    21,    22,
       0,   117,     0,    50,     0,    40,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
      78,     0,     0,     0,    75,     0,     0,     0,   103,     0,
     113,     0,   150,     0,    75,    64,    79,     0,    78,     0,
      92,   168,    51,    52,    41,    48,    49,    45,    46,    47,
     121,    42,    43,    44,    37,    36,    38,    39,     0,     0,
       0,     0,     0,    76,    89,    87,    73,    91,     0,     0,
     107,   110,     0,     0,    76,   132,   131,    65,     0,    68,
       0,     0,     0,     0,     0,   119,   123,     0,    28,     0,
      84,     0,    82,     0,     0,     0,    93,     0,     0,     0,
       0,   134,     0,     0,     0,     0,     0,    80,   104,   109,
     122,     0,   120,     0,   125,    83,    77,    74,     0,    95,
       0,   106,   108,   136,   142,     0,     0,    72,    67,    66,
       0,   124,    94,     0,   100,     0,     0,   138,   143,   144,
     135,     0,   118,     0,     0,   102,     0,     0,   139,   140,
       0,     0,     0,     0,   137,     0,   133,   145,     0,    96,
      97,   126,   141,   151,     0,    98,    99,   101,   146
};

/* YYDEFGOTO[NTERM-NUM].  */
UNIV_STATIC const yytype_int16 yydefgoto[] =
{
      -1,     2,    62,    63,   206,   116,   248,    64,    65,    66,
     245,   237,   234,   207,   122,   123,   124,   148,   289,   304,
     337,   315,    67,    68,    69,   240,   241,   149,    70,    71,
      72,    73,    74,    75,    76,    77,   255,   256,   257,    78,
      79,    80,    81,    82,    83,    84,    85,   271,   272,   307,
     319,   326,   309,    86,   328,   131,   203,    87,    88,    89,
      20,     9,    10,    25,    26,    30,    31,    32,    33,     3
};

/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
   STATE-NUM.  */
#define YYPACT_NINF -177
UNIV_STATIC const yytype_int16 yypact[] =
{
      28,    38,    54,   -46,   -29,  -177,  -177,    56,    50,  -177,
     -75,     8,     8,    46,    56,  -177,  -177,  -177,  -177,  -177,
    -177,  -177,    63,  -177,     8,  -177,     2,   -26,   -51,  -177,
    -177,  -177,  -177,   -13,  -177,    71,    72,   587,  -177,    57,
     -21,    26,   272,   272,  -177,    13,    91,    55,    96,    67,
     -22,    99,   100,   103,  -177,  -177,  -177,    75,    29,    35,
    -177,   116,  -177,   396,  -177,    22,    23,    27,    -9,    30,
      87,    31,    32,    87,    47,    49,    52,    58,    59,    60,
      61,    62,    65,    66,    74,    77,    78,    86,    89,   102,
      75,  -177,   272,  -177,  -177,  -177,  -177,  -177,  -177,    39,
     272,    51,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,
    -177,  -177,  -177,   272,   272,   361,    25,   489,    45,    90,
    -177,   651,  -177,   -39,    93,   142,   124,   108,   152,   170,
    -177,   131,  -177,   143,  -177,  -177,  -177,  -177,    98,  -177,
    -177,  -177,   272,  -177,   110,  -177,  -177,   256,  -177,  -177,
    -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,
    -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,
     112,   651,   137,   101,   147,   204,    88,   272,   272,   272,
     272,   272,   587,   272,   272,   272,   272,   272,   272,   272,
     272,   587,   272,   -30,   211,   168,   212,   272,  -177,   213,
    -177,   118,  -177,   167,   217,   122,   651,   -63,   272,   175,
     651,  -177,  -177,  -177,  -177,   101,   101,    21,    21,   651,
     332,    21,    21,    21,    -6,    -6,   204,   204,   -60,   460,
     198,   222,   126,  -177,   125,  -177,  -177,   -33,   584,   140,
    -177,   128,   228,   229,   139,  -177,   125,  -177,   -53,  -177,
     272,   -49,   240,   587,   272,  -177,   224,   226,  -177,   225,
    -177,   150,  -177,   258,   272,   260,   230,   272,   272,   213,
       8,  -177,   -45,   208,   166,   164,   176,   651,  -177,  -177,
     587,   631,  -177,   254,  -177,  -177,  -177,  -177,   234,   194,
     638,   651,  -177,   182,   227,   228,   280,  -177,  -177,  -177,
     587,  -177,  -177,   273,   247,   587,   289,   214,  -177,  -177,
    -177,   195,   587,   209,   261,  -177,   524,   199,  -177,   295,
     292,   215,   299,   279,  -177,   304,  -177,  -177,   -44,  -177,
      -8,  -177,  -177,  -177,   305,  -177,  -177,  -177,  -177
};

/* YYPGOTO[NTERM-NUM].  */
UNIV_STATIC const yytype_int16 yypgoto[] =
{
    -177,  -177,   -62,  -176,   -40,  -177,  -177,  -177,  -177,  -177,
    -177,  -177,   109,  -166,   120,  -177,  -177,   -69,  -177,  -177,
    -177,  -177,   -34,  -177,  -177,    48,  -177,   243,  -177,  -177,
    -177,  -177,  -177,  -177,  -177,  -177,    64,  -177,  -177,  -177,
    -177,  -177,  -177,  -177,  -177,  -177,  -177,    24,  -177,  -177,
    -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,  -177,
     -12,   307,  -177,   297,  -177,  -177,  -177,   285,  -177,  -177
};

/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
   positive, shift that token.  If negative, reduce the rule which
   number is the opposite.  If zero, do what YYDEFACT says.
   If YYTABLE_NINF, syntax error.  */
#define YYTABLE_NINF -1
UNIV_STATIC const yytype_uint16 yytable[] =
{
      21,   140,   115,   117,   152,   121,   220,   264,   231,   181,
     194,    24,    27,    37,    35,   229,    93,    94,    95,    96,
      97,    98,    99,   135,   228,   100,    45,    15,    16,    17,
      18,    13,    19,    14,   145,   129,   181,   130,   335,   336,
      36,   144,   251,   249,     1,   250,   258,     4,   250,   118,
     119,    28,   171,   275,     5,   276,   170,   278,     6,   250,
     173,   294,   333,   295,   334,     8,    28,    11,    12,   195,
     232,    22,    24,   175,   176,   265,     7,   280,    34,   101,
      39,    40,    90,    91,   102,   103,   104,   105,   106,    92,
     107,   108,   109,   110,   188,   189,   111,   112,   177,   178,
     125,   179,   180,   181,   126,   127,   128,   210,   132,   133,
      45,   113,   134,   120,   179,   180,   181,   136,   114,   186,
     187,   188,   189,   137,   312,   138,   141,   147,   142,   316,
     190,   143,   196,   198,   146,   150,   151,   215,   216,   217,
     218,   219,   172,   221,   222,   223,   224,   225,   226,   227,
     192,   154,   230,   155,   174,   121,   156,   238,   140,   197,
     199,   200,   157,   158,   159,   160,   161,   140,   266,   162,
     163,    93,    94,    95,    96,    97,    98,    99,   164,   201,
     100,   165,   166,   183,   184,   185,   186,   187,   188,   189,
     167,   202,   204,   168,   214,   193,   183,   184,   185,   186,
     187,   188,   189,   205,   118,   119,   169,   212,   177,   178,
     277,   179,   180,   181,   281,   208,   211,   213,   140,   181,
     233,   236,   239,   242,   210,   243,   244,   290,   291,   247,
     252,   261,   262,   263,   101,   268,   269,   270,   273,   102,
     103,   104,   105,   106,   274,   107,   108,   109,   110,   279,
     140,   111,   112,   283,   140,   254,   285,   284,   293,    93,
      94,    95,    96,    97,    98,    99,   113,   286,   100,   287,
     296,   288,   297,   114,   298,    93,    94,    95,    96,    97,
      98,    99,   301,   299,   100,   302,   303,   306,   308,   311,
     313,   314,   317,   183,   184,   185,   186,   187,   188,   189,
     320,   327,   321,   318,   260,   324,   322,   325,   330,   329,
     209,   331,   332,   246,   338,   235,   153,   292,    38,   310,
     282,    23,   101,    29,     0,     0,     0,   102,   103,   104,
     105,   106,     0,   107,   108,   109,   110,     0,   101,   111,
     112,    41,     0,   102,   103,   104,   105,   106,     0,   107,
     108,   109,   110,     0,   113,   111,   112,     0,     0,     0,
      42,   114,   253,   254,     0,    43,    44,    45,     0,     0,
     113,   177,   178,    46,   179,   180,   181,   114,     0,     0,
      47,     0,     0,    48,     0,    49,     0,     0,    50,     0,
     182,     0,     0,     0,     0,     0,     0,     0,     0,    51,
      52,    53,     0,     0,     0,    41,     0,     0,    54,     0,
       0,     0,     0,    55,    56,     0,     0,    57,    58,    59,
       0,     0,    60,   139,    42,     0,     0,     0,     0,    43,
      44,    45,     0,     0,     0,     0,     0,    46,     0,     0,
       0,    61,     0,     0,    47,     0,     0,    48,     0,    49,
       0,     0,    50,     0,     0,     0,   183,   184,   185,   186,
     187,   188,   189,    51,    52,    53,     0,     0,     0,    41,
       0,     0,    54,     0,     0,     0,     0,    55,    56,     0,
       0,    57,    58,    59,     0,     0,    60,   259,    42,     0,
       0,     0,     0,    43,    44,    45,     0,     0,     0,   177,
     178,    46,   179,   180,   181,    61,     0,     0,    47,     0,
       0,    48,     0,    49,     0,     0,    50,     0,     0,     0,
       0,   191,     0,     0,     0,     0,     0,    51,    52,    53,
       0,     0,     0,    41,     0,     0,    54,     0,     0,     0,
       0,    55,    56,     0,     0,    57,    58,    59,     0,     0,
      60,   323,    42,     0,     0,     0,     0,    43,    44,    45,
       0,     0,     0,     0,     0,    46,     0,     0,     0,    61,
       0,     0,    47,     0,     0,    48,     0,    49,     0,     0,
      50,     0,     0,     0,   183,   184,   185,   186,   187,   188,
     189,    51,    52,    53,   177,   178,    41,   179,   180,   181,
      54,     0,     0,     0,     0,    55,    56,     0,     0,    57,
      58,    59,     0,     0,    60,    42,     0,     0,     0,     0,
      43,    44,    45,     0,     0,     0,   267,     0,    46,     0,
       0,     0,     0,    61,     0,    47,     0,     0,    48,     0,
      49,   177,   178,    50,   179,   180,   181,     0,   177,   178,
       0,   179,   180,   181,    51,    52,    53,     0,     0,     0,
     300,   177,   178,    54,   179,   180,   181,     0,    55,    56,
     305,     0,    57,    58,    59,     0,     0,    60,     0,   183,
     184,   185,   186,   187,   188,   189,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,    61,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
       0,     0,     0,     0,     0,     0,   183,   184,   185,   186,
     187,   188,   189,   183,   184,   185,   186,   187,   188,   189,
       0,     0,     0,     0,     0,     0,   183,   184,   185,   186,
     187,   188,   189
};

UNIV_STATIC const yytype_int16 yycheck[] =
{
      12,    63,    42,    43,    73,    45,   182,    40,    38,    15,
      49,     9,    24,    26,    65,   191,     3,     4,     5,     6,
       7,     8,     9,    57,   190,    12,    35,    19,    20,    21,
      22,   106,    24,   108,    68,    57,    15,    59,    46,    47,
      91,    50,   208,   106,    16,   108,   106,     9,   108,    36,
      37,    64,    92,   106,     0,   108,    90,   106,   104,   108,
     100,   106,   106,   108,   108,     9,    64,    17,    18,   108,
     100,    25,     9,   113,   114,   108,   105,   253,   104,    66,
       9,     9,    25,   104,    71,    72,    73,    74,    75,    63,
      77,    78,    79,    80,   100,   101,    83,    84,    10,    11,
       9,    13,    14,    15,    49,     9,    39,   147,     9,     9,
      35,    98,     9,   100,    13,    14,    15,    88,   105,    98,
      99,   100,   101,    88,   300,     9,   104,    40,   105,   305,
     105,   104,    39,     9,   104,   104,   104,   177,   178,   179,
     180,   181,   103,   183,   184,   185,   186,   187,   188,   189,
     105,   104,   192,   104,   103,   195,   104,   197,   220,    17,
      52,     9,   104,   104,   104,   104,   104,   229,   237,   104,
     104,     3,     4,     5,     6,     7,     8,     9,   104,     9,
      12,   104,   104,    95,    96,    97,    98,    99,   100,   101,
     104,    60,    49,   104,   106,   105,    95,    96,    97,    98,
      99,   100,   101,   105,    36,    37,   104,    70,    10,    11,
     250,    13,    14,    15,   254,   105,   104,    70,   280,    15,
       9,     9,     9,   105,   264,    58,     9,   267,   268,   107,
      55,     9,   106,   108,    66,    95,   108,     9,     9,    71,
      72,    73,    74,    75,   105,    77,    78,    79,    80,     9,
     312,    83,    84,    27,   316,    31,   106,    32,   270,     3,
       4,     5,     6,     7,     8,     9,    98,     9,    12,     9,
      62,    41,   106,   105,   110,     3,     4,     5,     6,     7,
       8,     9,    28,   107,    12,    51,    92,   105,    61,     9,
      17,    44,     3,    95,    96,    97,    98,    99,   100,   101,
     105,     9,    93,    89,   106,   106,    45,    12,     9,    94,
      54,    32,     8,   204,     9,   195,    73,   269,    33,   295,
     256,    14,    66,    26,    -1,    -1,    -1,    71,    72,    73,
      74,    75,    -1,    77,    78,    79,    80,    -1,    66,    83,
      84,     9,    -1,    71,    72,    73,    74,    75,    -1,    77,
      78,    79,    80,    -1,    98,    83,    84,    -1,    -1,    -1,
      28,   105,    30,    31,    -1,    33,    34,    35,    -1,    -1,
      98,    10,    11,    41,    13,    14,    15,   105,    -1,    -1,
      48,    -1,    -1,    51,    -1,    53,    -1,    -1,    56,    -1,
      29,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    67,
      68,    69,    -1,    -1,    -1,     9,    -1,    -1,    76,    -1,
      -1,    -1,    -1,    81,    82,    -1,    -1,    85,    86,    87,
      -1,    -1,    90,    27,    28,    -1,    -1,    -1,    -1,    33,
      34,    35,    -1,    -1,    -1,    -1,    -1,    41,    -1,    -1,
      -1,   109,    -1,    -1,    48,    -1,    -1,    51,    -1,    53,
      -1,    -1,    56,    -1,    -1,    -1,    95,    96,    97,    98,
      99,   100,   101,    67,    68,    69,    -1,    -1,    -1,     9,
      -1,    -1,    76,    -1,    -1,    -1,    -1,    81,    82,    -1,
      -1,    85,    86,    87,    -1,    -1,    90,    27,    28,    -1,
      -1,    -1,    -1,    33,    34,    35,    -1,    -1,    -1,    10,
      11,    41,    13,    14,    15,   109,    -1,    -1,    48,    -1,
      -1,    51,    -1,    53,    -1,    -1,    56,    -1,    -1,    -1,
      -1,    32,    -1,    -1,    -1,    -1,    -1,    67,    68,    69,
      -1,    -1,    -1,     9,    -1,    -1,    76,    -1,    -1,    -1,
      -1,    81,    82,    -1,    -1,    85,    86,    87,    -1,    -1,
      90,    27,    28,    -1,    -1,    -1,    -1,    33,    34,    35,
      -1,    -1,    -1,    -1,    -1,    41,    -1,    -1,    -1,   109,
      -1,    -1,    48,    -1,    -1,    51,    -1,    53,    -1,    -1,
      56,    -1,    -1,    -1,    95,    96,    97,    98,    99,   100,
     101,    67,    68,    69,    10,    11,     9,    13,    14,    15,
      76,    -1,    -1,    -1,    -1,    81,    82,    -1,    -1,    85,
      86,    87,    -1,    -1,    90,    28,    -1,    -1,    -1,    -1,
      33,    34,    35,    -1,    -1,    -1,    42,    -1,    41,    -1,
      -1,    -1,    -1,   109,    -1,    48,    -1,    -1,    51,    -1,
      53,    10,    11,    56,    13,    14,    15,    -1,    10,    11,
      -1,    13,    14,    15,    67,    68,    69,    -1,    -1,    -1,
      29,    10,    11,    76,    13,    14,    15,    -1,    81,    82,
      32,    -1,    85,    86,    87,    -1,    -1,    90,    -1,    95,
      96,    97,    98,    99,   100,   101,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,   109,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
      -1,    -1,    -1,    -1,    -1,    -1,    95,    96,    97,    98,
      99,   100,   101,    95,    96,    97,    98,    99,   100,   101,
      -1,    -1,    -1,    -1,    -1,    -1,    95,    96,    97,    98,
      99,   100,   101
};

/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
   symbol of state STATE-NUM.  */
UNIV_STATIC const yytype_uint8 yystos[] =
{
       0,    16,   112,   180,     9,     0,   104,   105,     9,   172,
     173,    17,    18,   106,   108,    19,    20,    21,    22,    24,
     171,   171,    25,   172,     9,   174,   175,   171,    64,   174,
     176,   177,   178,   179,   104,    65,    91,    26,   178,     9,
       9,     9,    28,    33,    34,    35,    41,    48,    51,    53,
      56,    67,    68,    69,    76,    81,    82,    85,    86,    87,
      90,   109,   113,   114,   118,   119,   120,   133,   134,   135,
     139,   140,   141,   142,   143,   144,   145,   146,   150,   151,
     152,   153,   154,   155,   156,   157,   164,   168,   169,   170,
      25,   104,    63,     3,     4,     5,     6,     7,     8,     9,
      12,    66,    71,    72,    73,    74,    75,    77,    78,    79,
      80,    83,    84,    98,   105,   115,   116,   115,    36,    37,
     100,   115,   125,   126,   127,     9,    49,     9,    39,    57,
      59,   166,     9,     9,     9,   133,    88,    88,     9,    27,
     113,   104,   105,   104,    50,   133,   104,    40,   128,   138,
     104,   104,   128,   138,   104,   104,   104,   104,   104,   104,
     104,   104,   104,   104,   104,   104,   104,   104,   104,   104,
     133,   115,   103,   115,   103,   115,   115,    10,    11,    13,
      14,    15,    29,    95,    96,    97,    98,    99,   100,   101,
     105,    32,   105,   105,    49,   108,    39,    17,     9,    52,
       9,     9,    60,   167,    49,   105,   115,   124,   105,    54,
     115,   104,    70,    70,   106,   115,   115,   115,   115,   115,
     114,   115,   115,   115,   115,   115,   115,   115,   124,   114,
     115,    38,   100,     9,   123,   125,     9,   122,   115,     9,
     136,   137,   105,    58,     9,   121,   123,   107,   117,   106,
     108,   124,    55,    30,    31,   147,   148,   149,   106,    27,
     106,     9,   106,   108,    40,   108,   128,    42,    95,   108,
       9,   158,   159,     9,   105,   106,   108,   115,   106,     9,
     114,   115,   147,    27,    32,   106,     9,     9,    41,   129,
     115,   115,   136,   171,   106,   108,    62,   106,   110,   107,
      29,    28,    51,    92,   130,    32,   105,   160,    61,   163,
     158,     9,   114,    17,    44,   132,   114,     3,    89,   161,
     105,    93,    45,    27,   106,    12,   162,     9,   165,    94,
       9,    32,     8,   106,   108,    46,    47,   131,     9
};

#define yyerrok		(yyerrstatus = 0)
#define yyclearin	(yychar = YYEMPTY)
#define YYEMPTY		(-2)
#define YYEOF		0

#define YYACCEPT	goto yyacceptlab
#define YYABORT		goto yyabortlab
#define YYERROR		goto yyerrorlab


/* Like YYERROR except do call yyerror.  This remains here temporarily
   to ease the transition to the new meaning of YYERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */

#define YYFAIL		goto yyerrlab

#define YYRECOVERING()  (!!yyerrstatus)

#define YYBACKUP(Token, Value)					\
do								\
  if (yychar == YYEMPTY && yylen == 1)				\
    {								\
      yychar = (Token);						\
      yylval = (Value);						\
      yytoken = YYTRANSLATE (yychar);				\
      YYPOPSTACK (1);						\
      goto yybackup;						\
    }								\
  else								\
    {								\
      yyerror (YY_("syntax error: cannot back up")); \
      YYERROR;							\
    }								\
while (YYID (0))


#define YYTERROR	1
#define YYERRCODE	256


/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
   If N is 0, then set CURRENT to the empty location which ends
   the previous symbol: RHS[0] (always defined).  */

#define YYRHSLOC(Rhs, K) ((Rhs)[K])
#ifndef YYLLOC_DEFAULT
# define YYLLOC_DEFAULT(Current, Rhs, N)				\
    do									\
      if (YYID (N))                                                    \
	{								\
	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
	}								\
      else								\
	{								\
	  (Current).first_line   = (Current).last_line   =		\
	    YYRHSLOC (Rhs, 0).last_line;				\
	  (Current).first_column = (Current).last_column =		\
	    YYRHSLOC (Rhs, 0).last_column;				\
	}								\
    while (YYID (0))
#endif


/* YY_LOCATION_PRINT -- Print the location on the stream.
   This macro was not mandated originally: define only if we know
   we won't break user code: when these are the locations we know.  */

#ifndef YY_LOCATION_PRINT
# if YYLTYPE_IS_TRIVIAL
#  define YY_LOCATION_PRINT(File, Loc)			\
     ib_logger (File, "%d.%d-%d.%d",			\
	      (Loc).first_line, (Loc).first_column,	\
	      (Loc).last_line,  (Loc).last_column)
# else
#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
# endif
#endif


/* YYLEX -- calling `yylex' with the right arguments.  */

#ifdef YYLEX_PARAM
# define YYLEX yylex (YYLEX_PARAM)
#else
# define YYLEX yylex ()
#endif

/* Enable debugging if requested.  */
#if YYDEBUG

# ifndef YYFPRINTF
#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
#  define YYFPRINTF ib_logger
# endif

# define YYDPRINTF(Args)			\
do {						\
  if (yydebug)					\
    YYFPRINTF Args;				\
} while (YYID (0))

# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
do {									  \
  if (yydebug)								  \
    {									  \
      YYFPRINTF (ib_stream, "%s ", Title);					  \
      yy_symbol_print (ib_stream,						  \
		  Type, Value); \
      YYFPRINTF (ib_stream, "\n");						  \
    }									  \
} while (YYID (0))


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC void
yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
#else
UNIV_STATIC void
yy_symbol_value_print (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
#endif
{
  if (!yyvaluep)
    return;
# ifdef YYPRINT
  if (yytype < YYNTOKENS)
    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
# else
  YYUSE (yyoutput);
# endif
  switch (yytype)
    {
      default:
	break;
    }
}


/*--------------------------------.
| Print this symbol on YYOUTPUT.  |
`--------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC void
yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
#else
UNIV_STATIC void
yy_symbol_print (yyoutput, yytype, yyvaluep)
    FILE *yyoutput;
    int yytype;
    YYSTYPE const * const yyvaluep;
#endif
{
  if (yytype < YYNTOKENS)
    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
  else
    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);

  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
  YYFPRINTF (yyoutput, ")");
}

/*------------------------------------------------------------------.
| yy_stack_print -- Print the state stack from its BOTTOM up to its |
| TOP (included).                                                   |
`------------------------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC void
yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
#else
UNIV_STATIC void
yy_stack_print (bottom, top)
    yytype_int16 *bottom;
    yytype_int16 *top;
#endif
{
  YYFPRINTF (ib_stream, "Stack now");
  for (; bottom <= top; ++bottom)
    YYFPRINTF (ib_stream, " %d", *bottom);
  YYFPRINTF (ib_stream, "\n");
}

# define YY_STACK_PRINT(Bottom, Top)				\
do {								\
  if (yydebug)							\
    yy_stack_print ((Bottom), (Top));				\
} while (YYID (0))


/*------------------------------------------------.
| Report that the YYRULE is going to be reduced.  |
`------------------------------------------------*/

#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC void
yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
#else
UNIV_STATIC void
yy_reduce_print (yyvsp, yyrule)
    YYSTYPE *yyvsp;
    int yyrule;
#endif
{
  int yynrhs = yyr2[yyrule];
  int yyi;
  unsigned long int yylno = yyrline[yyrule];
  YYFPRINTF (ib_stream, "Reducing stack by rule %d (line %lu):\n",
	     yyrule - 1, yylno);
  /* The symbols being reduced.  */
  for (yyi = 0; yyi < yynrhs; yyi++)
    {
      ib_logger (ib_stream, "   $%d = ", yyi + 1);
      yy_symbol_print (ib_stream, yyrhs[yyprhs[yyrule] + yyi],
		       &(yyvsp[(yyi + 1) - (yynrhs)])
		       		       );
      ib_logger (ib_stream, "\n");
    }
}

# define YY_REDUCE_PRINT(Rule)		\
do {					\
  if (yydebug)				\
    yy_reduce_print (yyvsp, Rule); \
} while (YYID (0))

/* Nonzero means print parse trace.  It is left uninitialized so that
   multiple parsers can coexist.  */
int yydebug;
#else /* !YYDEBUG */
# define YYDPRINTF(Args)
# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
# define YY_STACK_PRINT(Bottom, Top)
# define YY_REDUCE_PRINT(Rule)
#endif /* !YYDEBUG */


/* YYINITDEPTH -- initial size of the parser's stacks.  */
#ifndef	YYINITDEPTH
# define YYINITDEPTH 200
#endif

/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
   if the built-in stack extension method is used).

   Do not make this value too large; the results are undefined if
   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
   evaluated with infinite-precision integer arithmetic.  */

#ifndef YYMAXDEPTH
# define YYMAXDEPTH 10000
#endif



#if YYERROR_VERBOSE

# ifndef yystrlen
#  if defined __GLIBC__ && defined _STRING_H
#   define yystrlen strlen
#  else
/* Return the length of YYSTR.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC YYSIZE_T
yystrlen (const char *yystr)
#else
UNIV_STATIC YYSIZE_T
yystrlen (yystr)
    const char *yystr;
#endif
{
  YYSIZE_T yylen;
  for (yylen = 0; yystr[yylen]; yylen++)
    continue;
  return yylen;
}
#  endif
# endif

# ifndef yystpcpy
#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
#   define yystpcpy stpcpy
#  else
/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
   YYDEST.  */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC char *
yystpcpy (char *yydest, const char *yysrc)
#else
UNIV_STATIC char *
yystpcpy (yydest, yysrc)
    char *yydest;
    const char *yysrc;
#endif
{
  char *yyd = yydest;
  const char *yys = yysrc;

  while ((*yyd++ = *yys++) != '\0')
    continue;

  return yyd - 1;
}
#  endif
# endif

# ifndef yytnamerr
/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
   quotes and backslashes, so that it's suitable for yyerror.  The
   heuristic is that double-quoting is unnecessary unless the string
   contains an apostrophe, a comma, or backslash (other than
   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
   null, do not copy; instead, return the length of what the result
   would have been.  */
UNIV_STATIC YYSIZE_T
yytnamerr (char *yyres, const char *yystr)
{
  if (*yystr == '"')
    {
      YYSIZE_T yyn = 0;
      char const *yyp = yystr;

      for (;;)
	switch (*++yyp)
	  {
	  case '\'':
	  case ',':
	    goto do_not_strip_quotes;

	  case '\\':
	    if (*++yyp != '\\')
	      goto do_not_strip_quotes;
	    /* Fall through.  */
	  default:
	    if (yyres)
	      yyres[yyn] = *yyp;
	    yyn++;
	    break;

	  case '"':
	    if (yyres)
	      yyres[yyn] = '\0';
	    return yyn;
	  }
    do_not_strip_quotes: ;
    }

  if (! yyres)
    return yystrlen (yystr);

  return yystpcpy (yyres, yystr) - yyres;
}
# endif

/* Copy into YYRESULT an error message about the unexpected token
   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
   including the terminating null byte.  If YYRESULT is null, do not
   copy anything; just return the number of bytes that would be
   copied.  As a special case, return 0 if an ordinary "syntax error"
   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
   size calculation.  */
UNIV_STATIC YYSIZE_T
yysyntax_error (char *yyresult, int yystate, int yychar)
{
  int yyn = yypact[yystate];

  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
    return 0;
  else
    {
      int yytype = YYTRANSLATE (yychar);
      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
      YYSIZE_T yysize = yysize0;
      YYSIZE_T yysize1;
      int yysize_overflow = 0;
      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
      int yyx;

# if 0
      /* This is so xgettext sees the translatable formats that are
	 constructed on the fly.  */
      YY_("syntax error, unexpected %s");
      YY_("syntax error, unexpected %s, expecting %s");
      YY_("syntax error, unexpected %s, expecting %s or %s");
      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
# endif
      char *yyfmt;
      char const *yyf;
      static char const yyunexpected[] = "syntax error, unexpected %s";
      static char const yyexpecting[] = ", expecting %s";
      static char const yyor[] = " or %s";
      char yyformat[sizeof yyunexpected
		    + sizeof yyexpecting - 1
		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
		       * (sizeof yyor - 1))];
      char const *yyprefix = yyexpecting;

      /* Start YYX at -YYN if negative to avoid negative indexes in
	 YYCHECK.  */
      int yyxbegin = yyn < 0 ? -yyn : 0;

      /* Stay within bounds of both yycheck and yytname.  */
      int yychecklim = YYLAST - yyn + 1;
      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
      int yycount = 1;

      yyarg[0] = yytname[yytype];
      yyfmt = yystpcpy (yyformat, yyunexpected);

      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
	  {
	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
	      {
		yycount = 1;
		yysize = yysize0;
		yyformat[sizeof yyunexpected - 1] = '\0';
		break;
	      }
	    yyarg[yycount++] = yytname[yyx];
	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
	    yysize_overflow |= (yysize1 < yysize);
	    yysize = yysize1;
	    yyfmt = yystpcpy (yyfmt, yyprefix);
	    yyprefix = yyor;
	  }

      yyf = YY_(yyformat);
      yysize1 = yysize + yystrlen (yyf);
      yysize_overflow |= (yysize1 < yysize);
      yysize = yysize1;

      if (yysize_overflow)
	return YYSIZE_MAXIMUM;

      if (yyresult)
	{
	  /* Avoid sprintf, as that infringes on the user's name space.
	     Don't have undefined behavior even if the translation
	     produced a string with the wrong number of "%s"s.  */
	  char *yyp = yyresult;
	  int yyi = 0;
	  while ((*yyp = *yyf) != '\0')
	    {
	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
		{
		  yyp += yytnamerr (yyp, yyarg[yyi++]);
		  yyf += 2;
		}
	      else
		{
		  yyp++;
		  yyf++;
		}
	    }
	}
      return yysize;
    }
}
#endif /* YYERROR_VERBOSE */


/*-----------------------------------------------.
| Release the memory associated to this symbol.  |
`-----------------------------------------------*/

/*ARGSUSED*/
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
UNIV_STATIC void
yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
#else
UNIV_STATIC void
yydestruct (yymsg, yytype, yyvaluep)
    const char *yymsg;
    int yytype;
    YYSTYPE *yyvaluep;
#endif
{
  YYUSE (yyvaluep);

  if (!yymsg)
    yymsg = "Deleting";
  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);

  switch (yytype)
    {

      default:
	break;
    }
}


/* Prevent warnings from -Wmissing-prototypes.  */

#ifdef YYPARSE_PARAM
#if defined __STDC__ || defined __cplusplus
UNIV_INTERN int yyparse (void *YYPARSE_PARAM);
#else
UNIV_INTERN int yyparse ();
#endif
#else /* ! YYPARSE_PARAM */
#if defined __STDC__ || defined __cplusplus
UNIV_INTERN int yyparse (void);
#else
UNIV_INTERN int yyparse ();
#endif
#endif /* ! YYPARSE_PARAM */



/* The look-ahead symbol.  */
UNIV_STATIC int yychar;

/* The semantic value of the look-ahead symbol.  */
UNIV_INTERN YYSTYPE yylval;

/* Number of syntax errors so far.  */
UNIV_STATIC int yynerrs;



/*----------.
| yyparse.  |
`----------*/

#ifdef YYPARSE_PARAM
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void *YYPARSE_PARAM)
#else
int
yyparse (YYPARSE_PARAM)
    void *YYPARSE_PARAM;
#endif
#else /* ! YYPARSE_PARAM */
#if (defined __STDC__ || defined __C99__FUNC__ \
     || defined __cplusplus || defined _MSC_VER)
int
yyparse (void)
#else
int
yyparse ()

#endif
#endif
{
  
  int yystate;
  int yyn;
  int yyresult;
  /* Number of tokens to shift before error messages enabled.  */
  int yyerrstatus;
  /* Look-ahead token as an internal (translated) token number.  */
  int yytoken = 0;
#if YYERROR_VERBOSE
  /* Buffer for error messages, and its allocated size.  */
  char yymsgbuf[128];
  char *yymsg = yymsgbuf;
  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
#endif

  /* Three stacks and their tools:
     `yyss': related to states,
     `yyvs': related to semantic values,
     `yyls': related to locations.

     Refer to the stacks thru separate pointers, to allow yyoverflow
     to reallocate them elsewhere.  */

  /* The state stack.  */
  yytype_int16 yyssa[YYINITDEPTH];
  yytype_int16 *yyss = yyssa;
  yytype_int16 *yyssp;

  /* The semantic value stack.  */
  YYSTYPE yyvsa[YYINITDEPTH];
  YYSTYPE *yyvs = yyvsa;
  YYSTYPE *yyvsp;



#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))

  YYSIZE_T yystacksize = YYINITDEPTH;

  /* The variables used to return semantic value and location from the
     action routines.  */
  YYSTYPE yyval;


  /* The number of symbols on the RHS of the reduced rule.
     Keep to zero when no symbol should be popped.  */
  int yylen = 0;

  YYDPRINTF ((ib_stream, "Starting parse\n"));

  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = YYEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  yyssp = yyss;
  yyvsp = yyvs;

  goto yysetstate;

/*------------------------------------------------------------.
| yynewstate -- Push a new state, which is found in yystate.  |
`------------------------------------------------------------*/
 yynewstate:
  /* In all cases, when you get here, the value and location stacks
     have just been pushed.  So pushing a state here evens the stacks.  */
  yyssp++;

 yysetstate:
  *yyssp = yystate;

  if (yyss + yystacksize - 1 <= yyssp)
    {
      /* Get the current used size of the three stacks, in elements.  */
      YYSIZE_T yysize = yyssp - yyss + 1;

#ifdef yyoverflow
      {
	/* Give user a chance to reallocate the stack.  Use copies of
	   these so that the &'s don't force the real ones into
	   memory.  */
	YYSTYPE *yyvs1 = yyvs;
	yytype_int16 *yyss1 = yyss;


	/* Each stack pointer address is followed by the size of the
	   data in use in that stack, in bytes.  This used to be a
	   conditional around just the two extra args, but that might
	   be undefined if yyoverflow is a macro.  */
	yyoverflow (YY_("memory exhausted"),
		    &yyss1, yysize * sizeof (*yyssp),
		    &yyvs1, yysize * sizeof (*yyvsp),

		    &yystacksize);

	yyss = yyss1;
	yyvs = yyvs1;
      }
#else /* no yyoverflow */
# ifndef YYSTACK_RELOCATE
      goto yyexhaustedlab;
# else
      /* Extend the stack our own way.  */
      if (YYMAXDEPTH <= yystacksize)
	goto yyexhaustedlab;
      yystacksize *= 2;
      if (YYMAXDEPTH < yystacksize)
	yystacksize = YYMAXDEPTH;

      {
	yytype_int16 *yyss1 = yyss;
	union yyalloc *yyptr =
	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
	if (! yyptr)
	  goto yyexhaustedlab;
	YYSTACK_RELOCATE (yyss);
	YYSTACK_RELOCATE (yyvs);

#  undef YYSTACK_RELOCATE
	if (yyss1 != yyssa)
	  YYSTACK_FREE (yyss1);
      }
# endif
#endif /* no yyoverflow */

      yyssp = yyss + yysize - 1;
      yyvsp = yyvs + yysize - 1;


      YYDPRINTF ((ib_stream, "Stack size increased to %lu\n",
		  (unsigned long int) yystacksize));

      if (yyss + yystacksize - 1 <= yyssp)
	YYABORT;
    }

  YYDPRINTF ((ib_stream, "Entering state %d\n", yystate));

  goto yybackup;

/*-----------.
| yybackup.  |
`-----------*/
yybackup:

  /* Do appropriate processing given the current state.  Read a
     look-ahead token if we need one and don't already have one.  */

  /* First try to decide what to do without reference to look-ahead token.  */
  yyn = yypact[yystate];
  if (yyn == YYPACT_NINF)
    goto yydefault;

  /* Not known => get a look-ahead token if don't already have one.  */

  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
  if (yychar == YYEMPTY)
    {
      YYDPRINTF ((ib_stream, "Reading a token: "));
      yychar = YYLEX;
    }

  if (yychar <= YYEOF)
    {
      yychar = yytoken = YYEOF;
      YYDPRINTF ((ib_stream, "Now at end of input.\n"));
    }
  else
    {
      yytoken = YYTRANSLATE (yychar);
      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
    }

  /* If the proper action on seeing token YYTOKEN is to reduce or to
     detect an error, take that action.  */
  yyn += yytoken;
  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn <= 0)
    {
      if (yyn == 0 || yyn == YYTABLE_NINF)
	goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }

  if (yyn == YYFINAL)
    YYACCEPT;

  /* Count tokens shifted since error; after three, turn off error
     status.  */
  if (yyerrstatus)
    yyerrstatus--;

  /* Shift the look-ahead token.  */
  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);

  /* Discard the shifted token unless it is eof.  */
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  yystate = yyn;
  *++yyvsp = yylval;

  goto yynewstate;


/*-----------------------------------------------------------.
| yydefault -- do the default action for the current state.  |
`-----------------------------------------------------------*/
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
  goto yyreduce;


/*-----------------------------.
| yyreduce -- Do a reduction.  |
`-----------------------------*/
yyreduce:
  /* yyn is the number of a rule to reduce with.  */
  yylen = yyr2[yyn];

  /* If YYLEN is nonzero, implement the default value of the action:
     `$$ = $1'.

     Otherwise, the following line sets YYVAL to garbage.
     This behavior is undocumented and Bison
     users should not rely upon it.  Assigning to YYVAL
     unconditionally makes the parser a bit smaller, and it avoids a
     GCC warning that YYVAL may be used uninitialized.  */
  yyval = yyvsp[1-yylen];


  YY_REDUCE_PRINT (yyn);
  switch (yyn)
    {
        case 25:
#line 166 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 26:
#line 168 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (2)]), (yyvsp[(2) - (2)])); ;}
    break;

  case 27:
#line 172 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 28:
#line 174 "pars0grm.y"
    { (yyval) = pars_func((yyvsp[(1) - (4)]), (yyvsp[(3) - (4)])); ;}
    break;

  case 29:
#line 175 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 30:
#line 176 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 31:
#line 177 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 32:
#line 178 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 33:
#line 179 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 34:
#line 180 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 35:
#line 181 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]);;}
    break;

  case 36:
#line 182 "pars0grm.y"
    { (yyval) = pars_op('+', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 37:
#line 183 "pars0grm.y"
    { (yyval) = pars_op('-', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 38:
#line 184 "pars0grm.y"
    { (yyval) = pars_op('*', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 39:
#line 185 "pars0grm.y"
    { (yyval) = pars_op('/', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 40:
#line 186 "pars0grm.y"
    { (yyval) = pars_op('-', (yyvsp[(2) - (2)]), NULL); ;}
    break;

  case 41:
#line 187 "pars0grm.y"
    { (yyval) = (yyvsp[(2) - (3)]); ;}
    break;

  case 42:
#line 188 "pars0grm.y"
    { (yyval) = pars_op('=', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 43:
#line 189 "pars0grm.y"
    { (yyval) = pars_op('<', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 44:
#line 190 "pars0grm.y"
    { (yyval) = pars_op('>', (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 45:
#line 191 "pars0grm.y"
    { (yyval) = pars_op(PARS_GE_TOKEN, (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 46:
#line 192 "pars0grm.y"
    { (yyval) = pars_op(PARS_LE_TOKEN, (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 47:
#line 193 "pars0grm.y"
    { (yyval) = pars_op(PARS_NE_TOKEN, (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 48:
#line 194 "pars0grm.y"
    { (yyval) = pars_op(PARS_AND_TOKEN, (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 49:
#line 195 "pars0grm.y"
    { (yyval) = pars_op(PARS_OR_TOKEN, (yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 50:
#line 196 "pars0grm.y"
    { (yyval) = pars_op(PARS_NOT_TOKEN, (yyvsp[(2) - (2)]), NULL); ;}
    break;

  case 51:
#line 198 "pars0grm.y"
    { (yyval) = pars_op(PARS_NOTFOUND_TOKEN, (yyvsp[(1) - (3)]), NULL); ;}
    break;

  case 52:
#line 200 "pars0grm.y"
    { (yyval) = pars_op(PARS_NOTFOUND_TOKEN, (yyvsp[(1) - (3)]), NULL); ;}
    break;

  case 53:
#line 204 "pars0grm.y"
    { (yyval) = &pars_to_char_token; ;}
    break;

  case 54:
#line 205 "pars0grm.y"
    { (yyval) = &pars_to_number_token; ;}
    break;

  case 55:
#line 206 "pars0grm.y"
    { (yyval) = &pars_to_binary_token; ;}
    break;

  case 56:
#line 208 "pars0grm.y"
    { (yyval) = &pars_binary_to_number_token; ;}
    break;

  case 57:
#line 209 "pars0grm.y"
    { (yyval) = &pars_substr_token; ;}
    break;

  case 58:
#line 210 "pars0grm.y"
    { (yyval) = &pars_concat_token; ;}
    break;

  case 59:
#line 211 "pars0grm.y"
    { (yyval) = &pars_instr_token; ;}
    break;

  case 60:
#line 212 "pars0grm.y"
    { (yyval) = &pars_length_token; ;}
    break;

  case 61:
#line 213 "pars0grm.y"
    { (yyval) = &pars_sysdate_token; ;}
    break;

  case 62:
#line 214 "pars0grm.y"
    { (yyval) = &pars_rnd_token; ;}
    break;

  case 63:
#line 215 "pars0grm.y"
    { (yyval) = &pars_rnd_str_token; ;}
    break;

  case 67:
#line 226 "pars0grm.y"
    { (yyval) = pars_stored_procedure_call((yyvsp[(2) - (6)])); ;}
    break;

  case 68:
#line 231 "pars0grm.y"
    { (yyval) = pars_procedure_call((yyvsp[(1) - (4)]), (yyvsp[(3) - (4)])); ;}
    break;

  case 69:
#line 235 "pars0grm.y"
    { (yyval) = &pars_replstr_token; ;}
    break;

  case 70:
#line 236 "pars0grm.y"
    { (yyval) = &pars_printf_token; ;}
    break;

  case 71:
#line 237 "pars0grm.y"
    { (yyval) = &pars_assert_token; ;}
    break;

  case 72:
#line 241 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (3)]); ;}
    break;

  case 73:
#line 245 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 74:
#line 247 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 75:
#line 251 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 76:
#line 252 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 77:
#line 254 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 78:
#line 258 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 79:
#line 259 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)]));;}
    break;

  case 80:
#line 260 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 81:
#line 264 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]); ;}
    break;

  case 82:
#line 266 "pars0grm.y"
    { (yyval) = pars_func(&pars_count_token,
				          que_node_list_add_last(NULL,
					    sym_tab_add_int_lit(
						pars_sym_tab_global, 1))); ;}
    break;

  case 83:
#line 271 "pars0grm.y"
    { (yyval) = pars_func(&pars_count_token,
					    que_node_list_add_last(NULL,
						pars_func(&pars_distinct_token,
						     que_node_list_add_last(
								NULL, (yyvsp[(4) - (5)]))))); ;}
    break;

  case 84:
#line 277 "pars0grm.y"
    { (yyval) = pars_func(&pars_sum_token,
						que_node_list_add_last(NULL,
									(yyvsp[(3) - (4)]))); ;}
    break;

  case 85:
#line 283 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 86:
#line 284 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 87:
#line 286 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 88:
#line 290 "pars0grm.y"
    { (yyval) = pars_select_list(&pars_star_denoter,
								NULL); ;}
    break;

  case 89:
#line 293 "pars0grm.y"
    { (yyval) = pars_select_list((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 90:
#line 294 "pars0grm.y"
    { (yyval) = pars_select_list((yyvsp[(1) - (1)]), NULL); ;}
    break;

  case 91:
#line 298 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 92:
#line 299 "pars0grm.y"
    { (yyval) = (yyvsp[(2) - (2)]); ;}
    break;

  case 93:
#line 303 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 94:
#line 305 "pars0grm.y"
    { (yyval) = &pars_update_token; ;}
    break;

  case 95:
#line 309 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 96:
#line 311 "pars0grm.y"
    { (yyval) = &pars_share_token; ;}
    break;

  case 97:
#line 315 "pars0grm.y"
    { (yyval) = &pars_asc_token; ;}
    break;

  case 98:
#line 316 "pars0grm.y"
    { (yyval) = &pars_asc_token; ;}
    break;

  case 99:
#line 317 "pars0grm.y"
    { (yyval) = &pars_desc_token; ;}
    break;

  case 100:
#line 321 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 101:
#line 323 "pars0grm.y"
    { (yyval) = pars_order_by((yyvsp[(3) - (4)]), (yyvsp[(4) - (4)])); ;}
    break;

  case 102:
#line 332 "pars0grm.y"
    { (yyval) = pars_select_statement((yyvsp[(2) - (8)]), (yyvsp[(4) - (8)]), (yyvsp[(5) - (8)]),
								(yyvsp[(6) - (8)]), (yyvsp[(7) - (8)]), (yyvsp[(8) - (8)])); ;}
    break;

  case 103:
#line 338 "pars0grm.y"
    { (yyval) = (yyvsp[(3) - (3)]); ;}
    break;

  case 104:
#line 343 "pars0grm.y"
    { (yyval) = pars_insert_statement((yyvsp[(1) - (5)]), (yyvsp[(4) - (5)]), NULL); ;}
    break;

  case 105:
#line 345 "pars0grm.y"
    { (yyval) = pars_insert_statement((yyvsp[(1) - (2)]), NULL, (yyvsp[(2) - (2)])); ;}
    break;

  case 106:
#line 349 "pars0grm.y"
    { (yyval) = pars_column_assignment((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 107:
#line 353 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 108:
#line 355 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 109:
#line 361 "pars0grm.y"
    { (yyval) = (yyvsp[(4) - (4)]); ;}
    break;

  case 110:
#line 367 "pars0grm.y"
    { (yyval) = pars_update_statement_start(FALSE,
								(yyvsp[(2) - (4)]), (yyvsp[(4) - (4)])); ;}
    break;

  case 111:
#line 373 "pars0grm.y"
    { (yyval) = pars_update_statement((yyvsp[(1) - (2)]), NULL, (yyvsp[(2) - (2)])); ;}
    break;

  case 112:
#line 378 "pars0grm.y"
    { (yyval) = pars_update_statement((yyvsp[(1) - (2)]), (yyvsp[(2) - (2)]), NULL); ;}
    break;

  case 113:
#line 383 "pars0grm.y"
    { (yyval) = pars_update_statement_start(TRUE,
								(yyvsp[(3) - (3)]), NULL); ;}
    break;

  case 114:
#line 389 "pars0grm.y"
    { (yyval) = pars_update_statement((yyvsp[(1) - (2)]), NULL, (yyvsp[(2) - (2)])); ;}
    break;

  case 115:
#line 394 "pars0grm.y"
    { (yyval) = pars_update_statement((yyvsp[(1) - (2)]), (yyvsp[(2) - (2)]), NULL); ;}
    break;

  case 116:
#line 399 "pars0grm.y"
    { (yyval) = pars_row_printf_statement((yyvsp[(2) - (2)])); ;}
    break;

  case 117:
#line 404 "pars0grm.y"
    { (yyval) = pars_assignment_statement((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 118:
#line 410 "pars0grm.y"
    { (yyval) = pars_elsif_element((yyvsp[(2) - (4)]), (yyvsp[(4) - (4)])); ;}
    break;

  case 119:
#line 414 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 120:
#line 416 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (2)]), (yyvsp[(2) - (2)])); ;}
    break;

  case 121:
#line 420 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 122:
#line 422 "pars0grm.y"
    { (yyval) = (yyvsp[(2) - (2)]); ;}
    break;

  case 123:
#line 423 "pars0grm.y"
    { (yyval) = (yyvsp[(1) - (1)]); ;}
    break;

  case 124:
#line 430 "pars0grm.y"
    { (yyval) = pars_if_statement((yyvsp[(2) - (7)]), (yyvsp[(4) - (7)]), (yyvsp[(5) - (7)])); ;}
    break;

  case 125:
#line 436 "pars0grm.y"
    { (yyval) = pars_while_statement((yyvsp[(2) - (6)]), (yyvsp[(4) - (6)])); ;}
    break;

  case 126:
#line 444 "pars0grm.y"
    { (yyval) = pars_for_statement((yyvsp[(2) - (10)]), (yyvsp[(4) - (10)]), (yyvsp[(6) - (10)]), (yyvsp[(8) - (10)])); ;}
    break;

  case 127:
#line 448 "pars0grm.y"
    { (yyval) = pars_exit_statement(); ;}
    break;

  case 128:
#line 452 "pars0grm.y"
    { (yyval) = pars_return_statement(); ;}
    break;

  case 129:
#line 457 "pars0grm.y"
    { (yyval) = pars_open_statement(
						ROW_SEL_OPEN_CURSOR, (yyvsp[(2) - (2)])); ;}
    break;

  case 130:
#line 463 "pars0grm.y"
    { (yyval) = pars_open_statement(
						ROW_SEL_CLOSE_CURSOR, (yyvsp[(2) - (2)])); ;}
    break;

  case 131:
#line 469 "pars0grm.y"
    { (yyval) = pars_fetch_statement((yyvsp[(2) - (4)]), (yyvsp[(4) - (4)]), NULL); ;}
    break;

  case 132:
#line 471 "pars0grm.y"
    { (yyval) = pars_fetch_statement((yyvsp[(2) - (4)]), NULL, (yyvsp[(4) - (4)])); ;}
    break;

  case 133:
#line 476 "pars0grm.y"
    { (yyval) = pars_column_def((yyvsp[(1) - (5)]), (yyvsp[(2) - (5)]), (yyvsp[(3) - (5)]), (yyvsp[(4) - (5)]), (yyvsp[(5) - (5)])); ;}
    break;

  case 134:
#line 480 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 135:
#line 482 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 136:
#line 486 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 137:
#line 488 "pars0grm.y"
    { (yyval) = (yyvsp[(2) - (3)]); ;}
    break;

  case 138:
#line 492 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 139:
#line 494 "pars0grm.y"
    { (yyval) = &pars_int_token;
					/* pass any non-NULL pointer */ ;}
    break;

  case 140:
#line 499 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 141:
#line 501 "pars0grm.y"
    { (yyval) = &pars_int_token;
					/* pass any non-NULL pointer */ ;}
    break;

  case 142:
#line 506 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 143:
#line 508 "pars0grm.y"
    { (yyval) = &pars_int_token;
					/* pass any non-NULL pointer */ ;}
    break;

  case 144:
#line 515 "pars0grm.y"
    { (yyval) = pars_create_table((yyvsp[(3) - (7)]), (yyvsp[(5) - (7)]), (yyvsp[(7) - (7)])); ;}
    break;

  case 145:
#line 519 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 146:
#line 521 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 147:
#line 525 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 148:
#line 526 "pars0grm.y"
    { (yyval) = &pars_unique_token; ;}
    break;

  case 149:
#line 530 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 150:
#line 531 "pars0grm.y"
    { (yyval) = &pars_clustered_token; ;}
    break;

  case 151:
#line 539 "pars0grm.y"
    { (yyval) = pars_create_index((yyvsp[(2) - (10)]), (yyvsp[(3) - (10)]), (yyvsp[(5) - (10)]), (yyvsp[(7) - (10)]), (yyvsp[(9) - (10)])); ;}
    break;

  case 152:
#line 544 "pars0grm.y"
    { (yyval) = pars_commit_statement(); ;}
    break;

  case 153:
#line 549 "pars0grm.y"
    { (yyval) = pars_rollback_statement(); ;}
    break;

  case 154:
#line 553 "pars0grm.y"
    { (yyval) = &pars_int_token; ;}
    break;

  case 155:
#line 554 "pars0grm.y"
    { (yyval) = &pars_int_token; ;}
    break;

  case 156:
#line 555 "pars0grm.y"
    { (yyval) = &pars_char_token; ;}
    break;

  case 157:
#line 556 "pars0grm.y"
    { (yyval) = &pars_binary_token; ;}
    break;

  case 158:
#line 557 "pars0grm.y"
    { (yyval) = &pars_blob_token; ;}
    break;

  case 159:
#line 562 "pars0grm.y"
    { (yyval) = pars_parameter_declaration((yyvsp[(1) - (3)]),
							PARS_INPUT, (yyvsp[(3) - (3)])); ;}
    break;

  case 160:
#line 565 "pars0grm.y"
    { (yyval) = pars_parameter_declaration((yyvsp[(1) - (3)]),
							PARS_OUTPUT, (yyvsp[(3) - (3)])); ;}
    break;

  case 161:
#line 570 "pars0grm.y"
    { (yyval) = NULL; ;}
    break;

  case 162:
#line 571 "pars0grm.y"
    { (yyval) = que_node_list_add_last(NULL, (yyvsp[(1) - (1)])); ;}
    break;

  case 163:
#line 573 "pars0grm.y"
    { (yyval) = que_node_list_add_last((yyvsp[(1) - (3)]), (yyvsp[(3) - (3)])); ;}
    break;

  case 164:
#line 578 "pars0grm.y"
    { (yyval) = pars_variable_declaration((yyvsp[(1) - (3)]), (yyvsp[(2) - (3)])); ;}
    break;

  case 168:
#line 590 "pars0grm.y"
    { (yyval) = pars_cursor_declaration((yyvsp[(3) - (6)]), (yyvsp[(5) - (6)])); ;}
    break;

  case 169:
#line 595 "pars0grm.y"
    { (yyval) = pars_function_declaration((yyvsp[(3) - (4)])); ;}
    break;

  case 175:
#line 616 "pars0grm.y"
    { (yyval) = pars_procedure_definition((yyvsp[(2) - (11)]), (yyvsp[(4) - (11)]),
								(yyvsp[(10) - (11)])); ;}
    break;


/* Line 1267 of yacc.c.  */
#line 2674 "pars0grm.c"
      default: break;
    }
  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);

  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);

  *++yyvsp = yyval;


  /* Now `shift' the result of the reduction.  Determine what state
     that goes to, based on the state we popped back to and the rule
     number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTOKENS];

  goto yynewstate;


/*------------------------------------.
| yyerrlab -- here on detecting error |
`------------------------------------*/
yyerrlab:
  /* If not already recovering from an error, report this error.  */
  if (!yyerrstatus)
    {
      ++yynerrs;
#if ! YYERROR_VERBOSE
      yyerror (YY_("syntax error"));
#else
      {
	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
	  {
	    YYSIZE_T yyalloc = 2 * yysize;
	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
	    if (yymsg != yymsgbuf)
	      YYSTACK_FREE (yymsg);
	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
	    if (yymsg)
	      yymsg_alloc = yyalloc;
	    else
	      {
		yymsg = yymsgbuf;
		yymsg_alloc = sizeof yymsgbuf;
	      }
	  }

	if (0 < yysize && yysize <= yymsg_alloc)
	  {
	    (void) yysyntax_error (yymsg, yystate, yychar);
	    yyerror (yymsg);
	  }
	else
	  {
	    yyerror (YY_("syntax error"));
	    if (yysize != 0)
	      goto yyexhaustedlab;
	  }
      }
#endif
    }



  if (yyerrstatus == 3)
    {
      /* If just tried and failed to reuse look-ahead token after an
	 error, discard it.  */

      if (yychar <= YYEOF)
	{
	  /* Return failure if at end of input.  */
	  if (yychar == YYEOF)
	    YYABORT;
	}
      else
	{
	  yydestruct ("Error: discarding",
		      yytoken, &yylval);
	  yychar = YYEMPTY;
	}
    }

  /* Else will try to reuse look-ahead token after shifting the error
     token.  */
  goto yyerrlab1;


/*---------------------------------------------------.
| yyerrorlab -- error raised explicitly by YYERROR.  |
`---------------------------------------------------*/
yyerrorlab:

  /* Pacify compilers like GCC when the user code never invokes
     YYERROR and the label yyerrorlab therefore never appears in user
     code.  */
  if (/*CONSTCOND*/ 0)
     goto yyerrorlab;

  /* Do not reclaim the symbols of the rule which action triggered
     this YYERROR.  */
  YYPOPSTACK (yylen);
  yylen = 0;
  YY_STACK_PRINT (yyss, yyssp);
  yystate = *yyssp;
  goto yyerrlab1;


/*-------------------------------------------------------------.
| yyerrlab1 -- common code for both syntax error and YYERROR.  |
`-------------------------------------------------------------*/
yyerrlab1:
  yyerrstatus = 3;	/* Each real token shifted decrements this.  */

  for (;;)
    {
      yyn = yypact[yystate];
      if (yyn != YYPACT_NINF)
	{
	  yyn += YYTERROR;
	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
	    {
	      yyn = yytable[yyn];
	      if (0 < yyn)
		break;
	    }
	}

      /* Pop the current state because it cannot handle the error token.  */
      if (yyssp == yyss)
	YYABORT;


      yydestruct ("Error: popping",
		  yystos[yystate], yyvsp);
      YYPOPSTACK (1);
      yystate = *yyssp;
      YY_STACK_PRINT (yyss, yyssp);
    }

  if (yyn == YYFINAL)
    YYACCEPT;

  *++yyvsp = yylval;


  /* Shift the error token.  */
  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);

  yystate = yyn;
  goto yynewstate;


/*-------------------------------------.
| yyacceptlab -- YYACCEPT comes here.  |
`-------------------------------------*/
yyacceptlab:
  yyresult = 0;
  goto yyreturn;

/*-----------------------------------.
| yyabortlab -- YYABORT comes here.  |
`-----------------------------------*/
yyabortlab:
  yyresult = 1;
  goto yyreturn;

#ifndef yyoverflow
/*-------------------------------------------------.
| yyexhaustedlab -- memory exhaustion comes here.  |
`-------------------------------------------------*/
yyexhaustedlab:
  yyerror (YY_("memory exhausted"));
  yyresult = 2;
  /* Fall through.  */
#endif

yyreturn:
  if (yychar != YYEOF && yychar != YYEMPTY)
     yydestruct ("Cleanup: discarding lookahead",
		 yytoken, &yylval);
  /* Do not reclaim the symbols of the rule which action triggered
     this YYABORT or YYACCEPT.  */
  YYPOPSTACK (yylen);
  YY_STACK_PRINT (yyss, yyssp);
  while (yyssp != yyss)
    {
      yydestruct ("Cleanup: popping",
		  yystos[*yyssp], yyvsp);
      YYPOPSTACK (1);
    }
#ifndef yyoverflow
  if (yyss != yyssa)
    YYSTACK_FREE (yyss);
#endif
#if YYERROR_VERBOSE
  if (yymsg != yymsgbuf)
    YYSTACK_FREE (yymsg);
#endif
  /* Make sure YYID is used.  */
  return YYID (yyresult);
}


#line 620 "pars0grm.y"

/**********************************************************************
Release any resources used by the parser. */
UNIV_INTERN
void
pars_close(void)
/*============*/
{
	pars_lexer_close();
}

/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file pars/pars0opt.c
Simple SQL optimizer

Created 12/21/1997 Heikki Tuuri
*******************************************************/

#include "pars0opt.h"

#ifdef UNIV_NONINL
#include "pars0opt.ic"
#endif

#include "row0sel.h"
#include "row0ins.h"
#include "row0upd.h"
#include "dict0dict.h"
#include "dict0mem.h"
#include "que0que.h"
#include "pars0grm.h"
#include "pars0pars.h"
#include "lock0lock.h"

#define OPT_EQUAL	1	/* comparison by = */
#define OPT_COMPARISON	2	/* comparison by <, >, <=, or >= */

#define OPT_NOT_COND	1
#define OPT_END_COND	2
#define OPT_TEST_COND	3
#define OPT_SCROLL_COND	4


/*******************************************************************//**
Inverts a comparison operator.
@return	the equivalent operator when the order of the arguments is switched */
UNIV_STATIC
int
opt_invert_cmp_op(
/*==============*/
	int	op)	/*!< in: operator */
{
	if (op == '<') {
		return('>');
	} else if (op == '>') {
		return('<');
	} else if (op == '=') {
		return('=');
	} else if (op == PARS_LE_TOKEN) {
		return(PARS_GE_TOKEN);
	} else if (op == PARS_GE_TOKEN) {
		return(PARS_LE_TOKEN);
	} else {
		ut_error;
	}

	return(0);
}

/*******************************************************************//**
Checks if the value of an expression can be calculated BEFORE the nth table
in a join is accessed. If this is the case, it can possibly be used in an
index search for the nth table.
@return	TRUE if already determined */
UNIV_STATIC
ibool
opt_check_exp_determined_before(
/*============================*/
	que_node_t*	exp,		/*!< in: expression */
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		nth_table)	/*!< in: nth table will be accessed */
{
	func_node_t*	func_node;
	sym_node_t*	sym_node;
	dict_table_t*	table;
	que_node_t*	arg;
	ulint		i;

	ut_ad(exp && sel_node);

	if (que_node_get_type(exp) == QUE_NODE_FUNC) {
		func_node = exp;

		arg = func_node->args;

		while (arg) {
			if (!opt_check_exp_determined_before(arg, sel_node,
							     nth_table)) {
				return(FALSE);
			}

			arg = que_node_get_next(arg);
		}

		return(TRUE);
	}

	ut_a(que_node_get_type(exp) == QUE_NODE_SYMBOL);

	sym_node = exp;

	if (sym_node->token_type != SYM_COLUMN) {

		return(TRUE);
	}

	for (i = 0; i < nth_table; i++) {

		table = sel_node_get_nth_plan(sel_node, i)->table;

		if (sym_node->table == table) {

			return(TRUE);
		}
	}

	return(FALSE);
}

/*******************************************************************//**
Looks in a comparison condition if a column value is already restricted by
it BEFORE the nth table is accessed.
@return	expression restricting the value of the column, or NULL if not known */
UNIV_STATIC
que_node_t*
opt_look_for_col_in_comparison_before(
/*==================================*/
	ulint		cmp_type,	/*!< in: OPT_EQUAL, OPT_COMPARISON */
	ulint		col_no,		/*!< in: column number */
	func_node_t*	search_cond,	/*!< in: comparison condition */
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		nth_table,	/*!< in: nth table in a join (a query
					from a single table is considered a
					join of 1 table) */
	ulint*		op)		/*!< out: comparison operator ('=',
					PARS_GE_TOKEN, ... ); this is inverted
					if the column appears on the right
					side */
{
	sym_node_t*	sym_node;
	dict_table_t*	table;
	que_node_t*	exp;
	que_node_t*	arg;

	ut_ad(search_cond);

	ut_a((search_cond->func == '<')
	     || (search_cond->func == '>')
	     || (search_cond->func == '=')
	     || (search_cond->func == PARS_GE_TOKEN)
	     || (search_cond->func == PARS_LE_TOKEN));

	table = sel_node_get_nth_plan(sel_node, nth_table)->table;

	if ((cmp_type == OPT_EQUAL) && (search_cond->func != '=')) {

		return(NULL);

	} else if ((cmp_type == OPT_COMPARISON)
		   && (search_cond->func != '<')
		   && (search_cond->func != '>')
		   && (search_cond->func != PARS_GE_TOKEN)
		   && (search_cond->func != PARS_LE_TOKEN)) {

		return(NULL);
	}

	arg = search_cond->args;

	if (que_node_get_type(arg) == QUE_NODE_SYMBOL) {
		sym_node = arg;

		if ((sym_node->token_type == SYM_COLUMN)
		    && (sym_node->table == table)
		    && (sym_node->col_no == col_no)) {

			/* sym_node contains the desired column id */

			/* Check if the expression on the right side of the
			operator is already determined */

			exp = que_node_get_next(arg);

			if (opt_check_exp_determined_before(exp, sel_node,
							    nth_table)) {
				*op = search_cond->func;

				return(exp);
			}
		}
	}

	exp = search_cond->args;
	arg = que_node_get_next(arg);

	if (que_node_get_type(arg) == QUE_NODE_SYMBOL) {
		sym_node = arg;

		if ((sym_node->token_type == SYM_COLUMN)
		    && (sym_node->table == table)
		    && (sym_node->col_no == col_no)) {

			if (opt_check_exp_determined_before(exp, sel_node,
							    nth_table)) {
				*op = opt_invert_cmp_op(search_cond->func);

				return(exp);
			}
		}
	}

	return(NULL);
}

/*******************************************************************//**
Looks in a search condition if a column value is already restricted by the
search condition BEFORE the nth table is accessed. Takes into account that
if we will fetch in an ascending order, we cannot utilize an upper limit for
a column value; in a descending order, respectively, a lower limit.
@return	expression restricting the value of the column, or NULL if not known */
UNIV_STATIC
que_node_t*
opt_look_for_col_in_cond_before(
/*============================*/
	ulint		cmp_type,	/*!< in: OPT_EQUAL, OPT_COMPARISON */
	ulint		col_no,		/*!< in: column number */
	func_node_t*	search_cond,	/*!< in: search condition or NULL */
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		nth_table,	/*!< in: nth table in a join (a query
					from a single table is considered a
					join of 1 table) */
	ulint*		op)		/*!< out: comparison operator ('=',
					PARS_GE_TOKEN, ... ) */
{
	func_node_t*	new_cond;
	que_node_t*	exp;

	if (search_cond == NULL) {

		return(NULL);
	}

	ut_a(que_node_get_type(search_cond) == QUE_NODE_FUNC);
	ut_a(search_cond->func != PARS_OR_TOKEN);
	ut_a(search_cond->func != PARS_NOT_TOKEN);

	if (search_cond->func == PARS_AND_TOKEN) {
		new_cond = search_cond->args;

		exp = opt_look_for_col_in_cond_before(cmp_type, col_no,
						      new_cond, sel_node,
						      nth_table, op);
		if (exp) {

			return(exp);
		}

		new_cond = que_node_get_next(new_cond);

		exp = opt_look_for_col_in_cond_before(cmp_type, col_no,
						      new_cond, sel_node,
						      nth_table, op);
		return(exp);
	}

	exp = opt_look_for_col_in_comparison_before(cmp_type, col_no,
						    search_cond, sel_node,
						    nth_table, op);
	if (exp == NULL) {

		return(NULL);
	}

	/* If we will fetch in an ascending order, we cannot utilize an upper
	limit for a column value; in a descending order, respectively, a lower
	limit */

	if (sel_node->asc && ((*op == '<') || (*op == PARS_LE_TOKEN))) {

		return(NULL);

	} else if (!sel_node->asc
		   && ((*op == '>') || (*op == PARS_GE_TOKEN))) {

		return(NULL);
	}

	return(exp);
}

/*******************************************************************//**
Calculates the goodness for an index according to a select node. The
goodness is 4 times the number of first fields in index whose values we
already know exactly in the query. If we have a comparison condition for
an additional field, 2 point are added. If the index is unique, and we know
all the unique fields for the index we add 1024 points. For a clustered index
we add 1 point.
@return	goodness */
UNIV_STATIC
ulint
opt_calc_index_goodness(
/*====================*/
	dict_index_t*	index,		/*!< in: index */
	sel_node_t*	sel_node,	/*!< in: parsed select node */
	ulint		nth_table,	/*!< in: nth table in a join */
	que_node_t**	index_plan,	/*!< in/out: comparison expressions for
					this index */
	ulint*		last_op)	/*!< out: last comparison operator, if
					goodness > 1 */
{
	que_node_t*	exp;
	ulint		goodness;
	ulint		n_fields;
	ulint		col_no;
	ulint		op;
	ulint		j;

	goodness = 0;

	/* Note that as higher level node pointers in the B-tree contain
	page addresses as the last field, we must not put more fields in
	the search tuple than dict_index_get_n_unique_in_tree(index); see
	the note in btr_cur_search_to_nth_level. */

	n_fields = dict_index_get_n_unique_in_tree(index);

	for (j = 0; j < n_fields; j++) {

		col_no = dict_index_get_nth_col_no(index, j);

		exp = opt_look_for_col_in_cond_before(
			OPT_EQUAL, col_no, sel_node->search_cond,
			sel_node, nth_table, &op);
		if (exp) {
			/* The value for this column is exactly known already
			at this stage of the join */

			index_plan[j] = exp;
			*last_op = op;
			goodness += 4;
		} else {
			/* Look for non-equality comparisons */

			exp = opt_look_for_col_in_cond_before(
				OPT_COMPARISON, col_no, sel_node->search_cond,
				sel_node, nth_table, &op);
			if (exp) {
				index_plan[j] = exp;
				*last_op = op;
				goodness += 2;
			}

			break;
		}
	}

	if (goodness >= 4 * dict_index_get_n_unique(index)) {
		goodness += 1024;

		if (dict_index_is_clust(index)) {

			goodness += 1024;
		}
	}

	/* We have to test for goodness here, as last_op may note be set */
	if (goodness && dict_index_is_clust(index)) {

		goodness++;
	}

	return(goodness);
}

/*******************************************************************//**
Calculates the number of matched fields based on an index goodness.
@return	number of excatly or partially matched fields */
UNIV_INLINE
ulint
opt_calc_n_fields_from_goodness(
/*============================*/
	ulint	goodness)	/*!< in: goodness */
{
	return(((goodness % 1024) + 2) / 4);
}

/*******************************************************************//**
Converts a comparison operator to the corresponding search mode PAGE_CUR_GE,
...
@return	search mode */
UNIV_INLINE
ulint
opt_op_to_search_mode(
/*==================*/
	ibool	asc,	/*!< in: TRUE if the rows should be fetched in an
			ascending order */
	ulint	op)	/*!< in: operator '=', PARS_GE_TOKEN, ... */
{
	if (op == '=') {
		if (asc) {
			return(PAGE_CUR_GE);
		} else {
			return(PAGE_CUR_LE);
		}
	} else if (op == '<') {
		ut_a(!asc);
		return(PAGE_CUR_L);
	} else if (op == '>') {
		ut_a(asc);
		return(PAGE_CUR_G);
	} else if (op == PARS_GE_TOKEN) {
		ut_a(asc);
		return(PAGE_CUR_GE);
	} else if (op == PARS_LE_TOKEN) {
		ut_a(!asc);
		return(PAGE_CUR_LE);
	} else {
		ut_error;
	}

	return(0);
}

/*******************************************************************//**
Determines if a node is an argument node of a function node.
@return	TRUE if is an argument */
UNIV_STATIC
ibool
opt_is_arg(
/*=======*/
	que_node_t*	arg_node,	/*!< in: possible argument node */
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg;

	arg = func_node->args;

	while (arg) {
		if (arg == arg_node) {

			return(TRUE);
		}

		arg = que_node_get_next(arg);
	}

	return(FALSE);
}

/*******************************************************************//**
Decides if the fetching of rows should be made in a descending order, and
also checks that the chosen query plan produces a result which satisfies
the order-by. */
UNIV_STATIC
void
opt_check_order_by(
/*===============*/
	sel_node_t*	sel_node)	/*!< in: select node; asserts an error
					if the plan does not agree with the
					order-by */
{
	order_node_t*	order_node;
	dict_table_t*	order_table;
	ulint		order_col_no;
	plan_t*		plan;
	ulint		i;

	if (!sel_node->order_by) {

		return;
	}

	order_node = sel_node->order_by;
	order_col_no = order_node->column->col_no;
	order_table = order_node->column->table;

	/* If there is an order-by clause, the first non-exactly matched field
	in the index used for the last table in the table list should be the
	column defined in the order-by clause, and for all the other tables
	we should get only at most a single row, otherwise we cannot presently
	calculate the order-by, as we have no sort utility */

	for (i = 0; i < sel_node->n_tables; i++) {

		plan = sel_node_get_nth_plan(sel_node, i);

		if (i < sel_node->n_tables - 1) {
			ut_a(dict_index_get_n_unique(plan->index)
			     <= plan->n_exact_match);
		} else {
			ut_a(plan->table == order_table);

			ut_a((dict_index_get_n_unique(plan->index)
			      <= plan->n_exact_match)
			     || (dict_index_get_nth_col_no(plan->index,
							   plan->n_exact_match)
				 == order_col_no));
		}
	}
}

/*******************************************************************//**
Optimizes a select. Decides which indexes to tables to use. The tables
are accessed in the order that they were written to the FROM part in the
select statement. */
UNIV_STATIC
void
opt_search_plan_for_table(
/*======================*/
	sel_node_t*	sel_node,	/*!< in: parsed select node */
	ulint		i,		/*!< in: this is the ith table */
	dict_table_t*	table)		/*!< in: table */
{
	plan_t*		plan;
	dict_index_t*	index;
	dict_index_t*	best_index;
	ulint		n_fields;
	ulint		goodness;
	ulint		last_op		= 75946965;	/* Eliminate a Purify
							warning */
	ulint		best_goodness;
	ulint		best_last_op = 0; /* remove warning */
	que_node_t*	index_plan[256];
	que_node_t*	best_index_plan[256];

	plan = sel_node_get_nth_plan(sel_node, i);

	plan->table = table;
	plan->asc = sel_node->asc;
	plan->pcur_is_open = FALSE;
	plan->cursor_at_end = FALSE;

	/* Calculate goodness for each index of the table */

	index = dict_table_get_first_index(table);
	best_index = index; /* Eliminate compiler warning */
	best_goodness = 0;

	/* should be do ... until ? comment by Jani */
	while (index) {
		goodness = opt_calc_index_goodness(index, sel_node, i,
						   index_plan, &last_op);
		if (goodness > best_goodness) {

			best_index = index;
			best_goodness = goodness;
			n_fields = opt_calc_n_fields_from_goodness(goodness);

			ut_memcpy(best_index_plan, index_plan,
				  n_fields * sizeof(void*));
			best_last_op = last_op;
		}

		index = dict_table_get_next_index(index);
	}

	plan->index = best_index;

	n_fields = opt_calc_n_fields_from_goodness(best_goodness);

	if (n_fields == 0) {
		plan->tuple = NULL;
		plan->n_exact_match = 0;
	} else {
		plan->tuple = dtuple_create(pars_sym_tab_global->heap,
					    n_fields);
		dict_index_copy_types(plan->tuple, plan->index, n_fields);

		plan->tuple_exps = mem_heap_alloc(pars_sym_tab_global->heap,
						  n_fields * sizeof(void*));

		ut_memcpy(plan->tuple_exps, best_index_plan,
			  n_fields * sizeof(void*));
		if (best_last_op == '=') {
			plan->n_exact_match = n_fields;
		} else {
			plan->n_exact_match = n_fields - 1;
		}

		plan->mode = opt_op_to_search_mode(sel_node->asc,
						   best_last_op);
	}

	if (dict_index_is_clust(best_index)
	    && (plan->n_exact_match >= dict_index_get_n_unique(best_index))) {

		plan->unique_search = TRUE;
	} else {
		plan->unique_search = FALSE;
	}

	plan->old_vers_heap = NULL;

	btr_pcur_init(&(plan->pcur));
	btr_pcur_init(&(plan->clust_pcur));
}

/*******************************************************************//**
Looks at a comparison condition and decides if it can, and need, be tested for
a table AFTER the table has been accessed.
@return OPT_NOT_COND if not for this table, else OPT_END_COND,
OPT_TEST_COND, or OPT_SCROLL_COND, where the last means that the
condition need not be tested, except when scroll cursors are used */
UNIV_STATIC
ulint
opt_classify_comparison(
/*====================*/
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		i,		/*!< in: ith table in the join */
	func_node_t*	cond)		/*!< in: comparison condition */
{
	plan_t*	plan;
	ulint	n_fields;
	ulint	op;
	ulint	j;

	ut_ad(cond && sel_node);

	plan = sel_node_get_nth_plan(sel_node, i);

	/* Check if the condition is determined after the ith table has been
	accessed, but not after the i - 1:th */

	if (!opt_check_exp_determined_before(cond, sel_node, i + 1)) {

		return(OPT_NOT_COND);
	}

	if ((i > 0) && opt_check_exp_determined_before(cond, sel_node, i)) {

		return(OPT_NOT_COND);
	}

	/* If the condition is an exact match condition used in constructing
	the search tuple, it is classified as OPT_END_COND */

	if (plan->tuple) {
		n_fields = dtuple_get_n_fields(plan->tuple);
	} else {
		n_fields = 0;
	}

	for (j = 0; j < plan->n_exact_match; j++) {

		if (opt_is_arg(plan->tuple_exps[j], cond)) {

			return(OPT_END_COND);
		}
	}

	/* If the condition is an non-exact match condition used in
	constructing the search tuple, it is classified as OPT_SCROLL_COND.
	When the cursor is positioned, and if a non-scroll cursor is used,
	there is no need to test this condition; if a scroll cursor is used
	the testing is necessary when the cursor is reversed. */

	if ((n_fields > plan->n_exact_match)
	    && opt_is_arg(plan->tuple_exps[n_fields - 1], cond)) {

		return(OPT_SCROLL_COND);
	}

	/* If the condition is a non-exact match condition on the first field
	in index for which there is no exact match, and it limits the search
	range from the opposite side of the search tuple already BEFORE we
	access the table, it is classified as OPT_END_COND */

	if ((dict_index_get_n_fields(plan->index) > plan->n_exact_match)
	    && opt_look_for_col_in_comparison_before(
		    OPT_COMPARISON,
		    dict_index_get_nth_col_no(plan->index,
					      plan->n_exact_match),
		    cond, sel_node, i, &op)) {

		if (sel_node->asc && ((op == '<') || (op == PARS_LE_TOKEN))) {

			return(OPT_END_COND);
		}

		if (!sel_node->asc && ((op == '>') || (op == PARS_GE_TOKEN))) {

			return(OPT_END_COND);
		}
	}

	/* Otherwise, cond is classified as OPT_TEST_COND */

	return(OPT_TEST_COND);
}

/*******************************************************************//**
Recursively looks for test conditions for a table in a join. */
UNIV_STATIC
void
opt_find_test_conds(
/*================*/
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		i,		/*!< in: ith table in the join */
	func_node_t*	cond)		/*!< in: conjunction of search
					conditions or NULL */
{
	func_node_t*	new_cond;
	ulint		class;
	plan_t*		plan;

	if (cond == NULL) {

		return;
	}

	if (cond->func == PARS_AND_TOKEN) {
		new_cond = cond->args;

		opt_find_test_conds(sel_node, i, new_cond);

		new_cond = que_node_get_next(new_cond);

		opt_find_test_conds(sel_node, i, new_cond);

		return;
	}

	plan = sel_node_get_nth_plan(sel_node, i);

	class = opt_classify_comparison(sel_node, i, cond);

	if (class == OPT_END_COND) {
		UT_LIST_ADD_LAST(cond_list, plan->end_conds, cond);

	} else if (class == OPT_TEST_COND) {
		UT_LIST_ADD_LAST(cond_list, plan->other_conds, cond);

	}
}

/*******************************************************************//**
Normalizes a list of comparison conditions so that a column of the table
appears on the left side of the comparison if possible. This is accomplished
by switching the arguments of the operator. */
UNIV_STATIC
void
opt_normalize_cmp_conds(
/*====================*/
	func_node_t*	cond,	/*!< in: first in a list of comparison
				conditions, or NULL */
	dict_table_t*	table)	/*!< in: table */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	sym_node_t*	sym_node;

	while (cond) {
		arg1 = cond->args;
		arg2 = que_node_get_next(arg1);

		if (que_node_get_type(arg2) == QUE_NODE_SYMBOL) {

			sym_node = arg2;

			if ((sym_node->token_type == SYM_COLUMN)
			    && (sym_node->table == table)) {

				/* Switch the order of the arguments */

				cond->args = arg2;
				que_node_list_add_last(NULL, arg2);
				que_node_list_add_last(arg2, arg1);

				/* Invert the operator */
				cond->func = opt_invert_cmp_op(cond->func);
			}
		}

		cond = UT_LIST_GET_NEXT(cond_list, cond);
	}
}

/*******************************************************************//**
Finds out the search condition conjuncts we can, and need, to test as the ith
table in a join is accessed. The search tuple can eliminate the need to test
some conjuncts. */
UNIV_STATIC
void
opt_determine_and_normalize_test_conds(
/*===================================*/
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		i)		/*!< in: ith table in the join */
{
	plan_t*	plan;

	plan = sel_node_get_nth_plan(sel_node, i);

	UT_LIST_INIT(plan->end_conds);
	UT_LIST_INIT(plan->other_conds);

	/* Recursively go through the conjuncts and classify them */

	opt_find_test_conds(sel_node, i, sel_node->search_cond);

	opt_normalize_cmp_conds(UT_LIST_GET_FIRST(plan->end_conds),
				plan->table);

	ut_a(UT_LIST_GET_LEN(plan->end_conds) >= plan->n_exact_match);
}

/*******************************************************************//**
Looks for occurrences of the columns of the table in the query subgraph and
adds them to the list of columns if an occurrence of the same column does not
already exist in the list. If the column is already in the list, puts a value
indirection to point to the occurrence in the column list, except if the
column occurrence we are looking at is in the column list, in which case
nothing is done. */
UNIV_INTERN
void
opt_find_all_cols(
/*==============*/
	ibool		copy_val,	/*!< in: if TRUE, new found columns are
					added as columns to copy */
	dict_index_t*	index,		/*!< in: index of the table to use */
	sym_node_list_t* col_list,	/*!< in: base node of a list where
					to add new found columns */
	plan_t*		plan,		/*!< in: plan or NULL */
	que_node_t*	exp)		/*!< in: expression or condition or
					NULL */
{
	func_node_t*	func_node;
	que_node_t*	arg;
	sym_node_t*	sym_node;
	sym_node_t*	col_node;
	ulint		col_pos;

	if (exp == NULL) {

		return;
	}

	if (que_node_get_type(exp) == QUE_NODE_FUNC) {
		func_node = exp;

		arg = func_node->args;

		while (arg) {
			opt_find_all_cols(copy_val, index, col_list, plan,
					  arg);
			arg = que_node_get_next(arg);
		}

		return;
	}

	ut_a(que_node_get_type(exp) == QUE_NODE_SYMBOL);

	sym_node = exp;

	if (sym_node->token_type != SYM_COLUMN) {

		return;
	}

	if (sym_node->table != index->table) {

		return;
	}

	/* Look for an occurrence of the same column in the plan column
	list */

	col_node = UT_LIST_GET_FIRST(*col_list);

	while (col_node) {
		if (col_node->col_no == sym_node->col_no) {

			if (col_node == sym_node) {
				/* sym_node was already in a list: do
				nothing */

				return;
			}

			/* Put an indirection */
			sym_node->indirection = col_node;
			sym_node->alias = col_node;

			return;
		}

		col_node = UT_LIST_GET_NEXT(col_var_list, col_node);
	}

	/* The same column did not occur in the list: add it */

	UT_LIST_ADD_LAST(col_var_list, *col_list, sym_node);

	sym_node->copy_val = copy_val;

	/* Fill in the field_no fields in sym_node */

	sym_node->field_nos[SYM_CLUST_FIELD_NO] = dict_index_get_nth_col_pos(
		dict_table_get_first_index(index->table), sym_node->col_no);
	if (!dict_index_is_clust(index)) {

		ut_a(plan);

		col_pos = dict_index_get_nth_col_pos(index, sym_node->col_no);

		if (col_pos == ULINT_UNDEFINED) {

			plan->must_get_clust = TRUE;
		}

		sym_node->field_nos[SYM_SEC_FIELD_NO] = col_pos;
	}
}

/*******************************************************************//**
Looks for occurrences of the columns of the table in conditions which are
not yet determined AFTER the join operation has fetched a row in the ith
table. The values for these column must be copied to dynamic memory for
later use. */
UNIV_STATIC
void
opt_find_copy_cols(
/*===============*/
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		i,		/*!< in: ith table in the join */
	func_node_t*	search_cond)	/*!< in: search condition or NULL */
{
	func_node_t*	new_cond;
	plan_t*		plan;

	if (search_cond == NULL) {

		return;
	}

	ut_ad(que_node_get_type(search_cond) == QUE_NODE_FUNC);

	if (search_cond->func == PARS_AND_TOKEN) {
		new_cond = search_cond->args;

		opt_find_copy_cols(sel_node, i, new_cond);

		new_cond = que_node_get_next(new_cond);

		opt_find_copy_cols(sel_node, i, new_cond);

		return;
	}

	if (!opt_check_exp_determined_before(search_cond, sel_node, i + 1)) {

		/* Any ith table columns occurring in search_cond should be
		copied, as this condition cannot be tested already on the
		fetch from the ith table */

		plan = sel_node_get_nth_plan(sel_node, i);

		opt_find_all_cols(TRUE, plan->index, &(plan->columns), plan,
				  search_cond);
	}
}

/*******************************************************************//**
Classifies the table columns according to whether we use the column only while
holding the latch on the page, or whether we have to copy the column value to
dynamic memory. Puts the first occurrence of a column to either list in the
plan node, and puts indirections to later occurrences of the column. */
UNIV_STATIC
void
opt_classify_cols(
/*==============*/
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		i)		/*!< in: ith table in the join */
{
	plan_t*		plan;
	que_node_t*	exp;

	plan = sel_node_get_nth_plan(sel_node, i);

	/* The final value of the following field will depend on the
	environment of the select statement: */

	plan->must_get_clust = FALSE;

	UT_LIST_INIT(plan->columns);

	/* All select list columns should be copied: therefore TRUE as the
	first argument */

	exp = sel_node->select_list;

	while (exp) {
		opt_find_all_cols(TRUE, plan->index, &(plan->columns), plan,
				  exp);
		exp = que_node_get_next(exp);
	}

	opt_find_copy_cols(sel_node, i, sel_node->search_cond);

	/* All remaining columns in the search condition are temporary
	columns: therefore FALSE */

	opt_find_all_cols(FALSE, plan->index, &(plan->columns), plan,
			  sel_node->search_cond);
}

/*******************************************************************//**
Fills in the info in plan which is used in accessing a clustered index
record. The columns must already be classified for the plan node. */
UNIV_STATIC
void
opt_clust_access(
/*=============*/
	sel_node_t*	sel_node,	/*!< in: select node */
	ulint		n)		/*!< in: nth table in select */
{
	plan_t*		plan;
	dict_table_t*	table;
	dict_index_t*	clust_index;
	dict_index_t*	index;
	mem_heap_t*	heap;
	ulint		n_fields;
	ulint		pos;
	ulint		i;

	plan = sel_node_get_nth_plan(sel_node, n);

	index = plan->index;

	/* The final value of the following field depends on the environment
	of the select statement: */

	plan->no_prefetch = FALSE;

	if (dict_index_is_clust(index)) {
		plan->clust_map = NULL;
		plan->clust_ref = NULL;

		return;
	}

	table = index->table;

	clust_index = dict_table_get_first_index(table);

	n_fields = dict_index_get_n_unique(clust_index);

	heap = pars_sym_tab_global->heap;

	plan->clust_ref = dtuple_create(heap, n_fields);

	dict_index_copy_types(plan->clust_ref, clust_index, n_fields);

	plan->clust_map = mem_heap_alloc(heap, n_fields * sizeof(ulint));

	for (i = 0; i < n_fields; i++) {
		pos = dict_index_get_nth_field_pos(index, clust_index, i);

		ut_a(pos != ULINT_UNDEFINED);

		/* We optimize here only queries to InnoDB's internal system
		tables, and they should not contain column prefix indexes. */

		if (dict_index_get_nth_field(index, pos)->prefix_len != 0
		    || dict_index_get_nth_field(clust_index, i)
		    ->prefix_len != 0) {
			ib_logger(ib_stream,
				"InnoDB: Error in pars0opt.c:"
				" table %s has prefix_len != 0\n",
				index->table_name);
		}

		*(plan->clust_map + i) = pos;
	}
}

/*******************************************************************//**
Optimizes a select. Decides which indexes to tables to use. The tables
are accessed in the order that they were written to the FROM part in the
select statement. */
UNIV_INTERN
void
opt_search_plan(
/*============*/
	sel_node_t*	sel_node)	/*!< in: parsed select node */
{
	sym_node_t*	table_node;
	dict_table_t*	table;
	order_node_t*	order_by;
	ulint		i;

	sel_node->plans = mem_heap_alloc(pars_sym_tab_global->heap,
					 sel_node->n_tables * sizeof(plan_t));

	/* Analyze the search condition to find out what we know at each
	join stage about the conditions that the columns of a table should
	satisfy */

	table_node = sel_node->table_list;

	if (sel_node->order_by == NULL) {
		sel_node->asc = TRUE;
	} else {
		order_by = sel_node->order_by;

		sel_node->asc = order_by->asc;
	}

	for (i = 0; i < sel_node->n_tables; i++) {

		table = table_node->table;

		/* Choose index through which to access the table */

		opt_search_plan_for_table(sel_node, i, table);

		/* Determine the search condition conjuncts we can test at
		this table; normalize the end conditions */

		opt_determine_and_normalize_test_conds(sel_node, i);

		table_node = que_node_get_next(table_node);
	}

	table_node = sel_node->table_list;

	for (i = 0; i < sel_node->n_tables; i++) {

		/* Classify the table columns into those we only need to access
		but not copy, and to those we must copy to dynamic memory */

		opt_classify_cols(sel_node, i);

		/* Calculate possible info for accessing the clustered index
		record */

		opt_clust_access(sel_node, i);

		table_node = que_node_get_next(table_node);
	}

	/* Check that the plan obeys a possible order-by clause: if not,
	an assertion error occurs */

	opt_check_order_by(sel_node);

#ifdef UNIV_SQL_DEBUG
	opt_print_query_plan(sel_node);
#endif
}

/********************************************************************//**
Prints info of a query plan. */
UNIV_INTERN
void
opt_print_query_plan(
/*=================*/
	sel_node_t*	sel_node)	/*!< in: select node */
{
	plan_t*	plan;
	ulint	n_fields;
	ulint	i;

	ib_logger(ib_stream, "QUERY PLAN FOR A SELECT NODE\n");

	ib_logger(ib_stream,
		sel_node->asc ? "Asc. search; " : "Desc. search; ");

	if (sel_node->set_x_locks) {
		ib_logger(ib_stream, "sets row x-locks; ");
		ut_a(sel_node->row_lock_mode == LOCK_X);
		ut_a(!sel_node->consistent_read);
	} else if (sel_node->consistent_read) {
		ib_logger(ib_stream, "consistent read; ");
	} else {
		ut_a(sel_node->row_lock_mode == LOCK_S);
		ib_logger(ib_stream, "sets row s-locks; ");
	}

	ib_logger(ib_stream, "\n");

	for (i = 0; i < sel_node->n_tables; i++) {
		plan = sel_node_get_nth_plan(sel_node, i);

		if (plan->tuple) {
			n_fields = dtuple_get_n_fields(plan->tuple);
		} else {
			n_fields = 0;
		}

		ib_logger(ib_stream, "Table ");
		dict_index_name_print(ib_stream, NULL, plan->index);
		ib_logger(ib_stream,"; exact m. %lu, match %lu, end conds %lu\n",
			(unsigned long) plan->n_exact_match,
			(unsigned long) n_fields,
			(unsigned long) UT_LIST_GET_LEN(plan->end_conds));
	}
}
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file pars/pars0pars.c
SQL parser

Created 11/19/1996 Heikki Tuuri
*******************************************************/

/* Historical note: Innobase executed its first SQL string (CREATE TABLE)
on 1/27/1998 */

#include "pars0pars.h"

#ifdef UNIV_NONINL
#include "pars0pars.ic"
#endif

#include "row0sel.h"
#include "row0ins.h"
#include "row0upd.h"
#include "dict0dict.h"
#include "dict0mem.h"
#include "dict0crea.h"
#include "que0que.h"
#include "pars0grm.h"
#include "pars0opt.h"
#include "data0data.h"
#include "data0type.h"
#include "trx0trx.h"
#include "trx0roll.h"
#include "lock0lock.h"
#include "eval0eval.h"

#ifdef UNIV_SQL_DEBUG
/** If the following is set TRUE, the lexer will print the SQL string
as it tokenizes it */
UNIV_INTERN ibool	pars_print_lexed	= FALSE;
#endif /* UNIV_SQL_DEBUG */

/* Global variable used while parsing a single procedure or query : the code is
NOT re-entrant */
UNIV_INTERN sym_tab_t*	pars_sym_tab_global;

/* Global variables used to denote certain reserved words, used in
constructing the parsing tree */

UNIV_INTERN pars_res_word_t	pars_to_char_token = {PARS_TO_CHAR_TOKEN};
UNIV_INTERN pars_res_word_t	pars_to_number_token = {PARS_TO_NUMBER_TOKEN};
UNIV_INTERN pars_res_word_t	pars_to_binary_token = {PARS_TO_BINARY_TOKEN};
UNIV_INTERN pars_res_word_t	pars_binary_to_number_token = {PARS_BINARY_TO_NUMBER_TOKEN};
UNIV_INTERN pars_res_word_t	pars_substr_token = {PARS_SUBSTR_TOKEN};
UNIV_INTERN pars_res_word_t	pars_replstr_token = {PARS_REPLSTR_TOKEN};
UNIV_INTERN pars_res_word_t	pars_concat_token = {PARS_CONCAT_TOKEN};
UNIV_INTERN pars_res_word_t	pars_instr_token = {PARS_INSTR_TOKEN};
UNIV_INTERN pars_res_word_t	pars_length_token = {PARS_LENGTH_TOKEN};
UNIV_INTERN pars_res_word_t	pars_sysdate_token = {PARS_SYSDATE_TOKEN};
UNIV_INTERN pars_res_word_t	pars_printf_token = {PARS_PRINTF_TOKEN};
UNIV_INTERN pars_res_word_t	pars_assert_token = {PARS_ASSERT_TOKEN};
UNIV_INTERN pars_res_word_t	pars_rnd_token = {PARS_RND_TOKEN};
UNIV_INTERN pars_res_word_t	pars_rnd_str_token = {PARS_RND_STR_TOKEN};
UNIV_INTERN pars_res_word_t	pars_count_token = {PARS_COUNT_TOKEN};
UNIV_INTERN pars_res_word_t	pars_sum_token = {PARS_SUM_TOKEN};
UNIV_INTERN pars_res_word_t	pars_distinct_token = {PARS_DISTINCT_TOKEN};
UNIV_INTERN pars_res_word_t	pars_binary_token = {PARS_BINARY_TOKEN};
UNIV_INTERN pars_res_word_t	pars_blob_token = {PARS_BLOB_TOKEN};
UNIV_INTERN pars_res_word_t	pars_int_token = {PARS_INT_TOKEN};
UNIV_INTERN pars_res_word_t	pars_char_token = {PARS_CHAR_TOKEN};
UNIV_INTERN pars_res_word_t	pars_float_token = {PARS_FLOAT_TOKEN};
UNIV_INTERN pars_res_word_t	pars_update_token = {PARS_UPDATE_TOKEN};
UNIV_INTERN pars_res_word_t	pars_asc_token = {PARS_ASC_TOKEN};
UNIV_INTERN pars_res_word_t	pars_desc_token = {PARS_DESC_TOKEN};
UNIV_INTERN pars_res_word_t	pars_open_token = {PARS_OPEN_TOKEN};
UNIV_INTERN pars_res_word_t	pars_close_token = {PARS_CLOSE_TOKEN};
UNIV_INTERN pars_res_word_t	pars_share_token = {PARS_SHARE_TOKEN};
UNIV_INTERN pars_res_word_t	pars_unique_token = {PARS_UNIQUE_TOKEN};
UNIV_INTERN pars_res_word_t	pars_clustered_token = {PARS_CLUSTERED_TOKEN};

/** Global variable used to denote the '*' in SELECT * FROM.. */
#define PARS_STAR_DENOTER       12345678
UNIV_INTERN ulint	pars_star_denoter	= PARS_STAR_DENOTER;

/***********************************************************************//**
Reset and check parser variables. */
UNIV_INTERN
void
pars_var_init(void)
/*===============*/
{
#ifdef UNIV_SQL_DEBUG
        pars_print_lexed = FALSE;
#endif /* UNIV_SQL_DEBUG */

	pars_lexer_var_init();

        pars_sym_tab_global = NULL;

	/* These should really be const, so we simply check that they
	are set to the correct value. */
        ut_a(pars_to_char_token.code == PARS_TO_CHAR_TOKEN);
        ut_a(pars_to_number_token.code == PARS_TO_NUMBER_TOKEN);
        ut_a(pars_to_binary_token.code == PARS_TO_BINARY_TOKEN);
        ut_a(pars_binary_to_number_token.code == PARS_BINARY_TO_NUMBER_TOKEN);
        ut_a(pars_substr_token.code == PARS_SUBSTR_TOKEN);
        ut_a(pars_replstr_token.code == PARS_REPLSTR_TOKEN);
        ut_a(pars_concat_token.code == PARS_CONCAT_TOKEN);
        ut_a(pars_instr_token.code == PARS_INSTR_TOKEN);
        ut_a(pars_length_token.code == PARS_LENGTH_TOKEN);
        ut_a(pars_sysdate_token.code == PARS_SYSDATE_TOKEN);
        ut_a(pars_printf_token.code == PARS_PRINTF_TOKEN);
        ut_a(pars_assert_token.code == PARS_ASSERT_TOKEN);
        ut_a(pars_rnd_token.code == PARS_RND_TOKEN);
        ut_a(pars_rnd_str_token.code == PARS_RND_STR_TOKEN);
        ut_a(pars_count_token.code == PARS_COUNT_TOKEN);
        ut_a(pars_sum_token.code == PARS_SUM_TOKEN);
        ut_a(pars_distinct_token.code == PARS_DISTINCT_TOKEN);
        ut_a(pars_binary_token.code == PARS_BINARY_TOKEN);
        ut_a(pars_blob_token.code == PARS_BLOB_TOKEN);
        ut_a(pars_int_token.code == PARS_INT_TOKEN);
        ut_a(pars_char_token.code == PARS_CHAR_TOKEN);
        ut_a(pars_float_token.code == PARS_FLOAT_TOKEN);
        ut_a(pars_update_token.code == PARS_UPDATE_TOKEN);
        ut_a(pars_asc_token.code == PARS_ASC_TOKEN);
        ut_a(pars_desc_token.code == PARS_DESC_TOKEN);
        ut_a(pars_open_token.code == PARS_OPEN_TOKEN);
        ut_a(pars_close_token.code == PARS_CLOSE_TOKEN);
        ut_a(pars_share_token.code == PARS_SHARE_TOKEN);
        ut_a(pars_unique_token.code == PARS_UNIQUE_TOKEN);
        ut_a(pars_clustered_token.code == PARS_CLUSTERED_TOKEN);

	pars_star_denoter = PARS_STAR_DENOTER;
}

/*********************************************************************//**
Determines the class of a function code.
@return	function class: PARS_FUNC_ARITH, ... */
UNIV_STATIC
ulint
pars_func_get_class(
/*================*/
	int	func)	/*!< in: function code: '=', PARS_GE_TOKEN, ... */
{
	switch (func) {
	case '+': case '-': case '*': case '/':
		return(PARS_FUNC_ARITH);

	case '=': case '<': case '>':
	case PARS_GE_TOKEN: case PARS_LE_TOKEN: case PARS_NE_TOKEN:
		return(PARS_FUNC_CMP);

	case PARS_AND_TOKEN: case PARS_OR_TOKEN: case PARS_NOT_TOKEN:
		return(PARS_FUNC_LOGICAL);

	case PARS_COUNT_TOKEN: case PARS_SUM_TOKEN:
		return(PARS_FUNC_AGGREGATE);

	case PARS_TO_CHAR_TOKEN:
	case PARS_TO_NUMBER_TOKEN:
	case PARS_TO_BINARY_TOKEN:
	case PARS_BINARY_TO_NUMBER_TOKEN:
	case PARS_SUBSTR_TOKEN:
	case PARS_CONCAT_TOKEN:
	case PARS_LENGTH_TOKEN:
	case PARS_INSTR_TOKEN:
	case PARS_SYSDATE_TOKEN:
	case PARS_NOTFOUND_TOKEN:
	case PARS_PRINTF_TOKEN:
	case PARS_ASSERT_TOKEN:
	case PARS_RND_TOKEN:
	case PARS_RND_STR_TOKEN:
	case PARS_REPLSTR_TOKEN:
		return(PARS_FUNC_PREDEFINED);

	default:
		return(PARS_FUNC_OTHER);
	}
}

/*********************************************************************//**
Parses an operator or predefined function expression.
@return	own: function node in a query tree */
UNIV_STATIC
func_node_t*
pars_func_low(
/*==========*/
	int		func,	/*!< in: function token code */
	que_node_t*	arg)	/*!< in: first argument in the argument list */
{
	func_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(func_node_t));

	node->common.type = QUE_NODE_FUNC;
	dfield_set_data(&(node->common.val), NULL, 0);
	node->common.val_buf_size = 0;

	node->func = func;

	node->class = pars_func_get_class(func);

	node->args = arg;

	UT_LIST_ADD_LAST(func_node_list, pars_sym_tab_global->func_node_list,
			 node);
	return(node);
}

/*********************************************************************//**
Parses a function expression.
@return	own: function node in a query tree */
UNIV_INTERN
func_node_t*
pars_func(
/*======*/
	que_node_t*	res_word,/*!< in: function name reserved word */
	que_node_t*	arg)	/*!< in: first argument in the argument list */
{
	return(pars_func_low(((pars_res_word_t*)res_word)->code, arg));
}

/*********************************************************************//**
Parses an operator expression.
@return	own: function node in a query tree */
UNIV_INTERN
func_node_t*
pars_op(
/*====*/
	int		func,	/*!< in: operator token code */
	que_node_t*	arg1,	/*!< in: first argument */
	que_node_t*	arg2)	/*!< in: second argument or NULL for an unary
				operator */
{
	que_node_list_add_last(NULL, arg1);

	if (arg2) {
		que_node_list_add_last(arg1, arg2);
	}

	return(pars_func_low(func, arg1));
}

/*********************************************************************//**
Parses an ORDER BY clause. Order by a single column only is supported.
@return	own: order-by node in a query tree */
UNIV_INTERN
order_node_t*
pars_order_by(
/*==========*/
	sym_node_t*	column,	/*!< in: column name */
	pars_res_word_t* asc)	/*!< in: &pars_asc_token or pars_desc_token */
{
	order_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(order_node_t));

	node->common.type = QUE_NODE_ORDER;

	node->column = column;

	if (asc == &pars_asc_token) {
		node->asc = TRUE;
	} else {
		ut_a(asc == &pars_desc_token);
		node->asc = FALSE;
	}

	return(node);
}

/*********************************************************************//**
Determine if a data type is a built-in string data type of the InnoDB
SQL parser.
@return	TRUE if string data type */
UNIV_STATIC
ibool
pars_is_string_type(
/*================*/
	ulint	mtype)	/*!< in: main data type */
{
	switch (mtype) {
	case DATA_VARCHAR: case DATA_CHAR:
	case DATA_FIXBINARY: case DATA_BINARY:
		return(TRUE);
	}

	return(FALSE);
}

/*********************************************************************//**
Resolves the data type of a function in an expression. The argument data
types must already be resolved. */
UNIV_STATIC
void
pars_resolve_func_data_type(
/*========================*/
	func_node_t*	node)	/*!< in: function node */
{
	que_node_t*	arg;

	ut_a(que_node_get_type(node) == QUE_NODE_FUNC);

	arg = node->args;

	switch (node->func) {
	case PARS_SUM_TOKEN:
	case '+': case '-': case '*': case '/':
		/* Inherit the data type from the first argument (which must
		not be the SQL null literal whose type is DATA_ERROR) */

		dtype_copy(que_node_get_data_type(node),
			   que_node_get_data_type(arg));

		ut_a(dtype_get_mtype(que_node_get_data_type(node))
		     == DATA_INT);
		break;

	case PARS_COUNT_TOKEN:
		ut_a(arg);
		dtype_set(que_node_get_data_type(node), DATA_INT, 0, 4);
		break;

	case PARS_TO_CHAR_TOKEN:
	case PARS_RND_STR_TOKEN:
		ut_a(dtype_get_mtype(que_node_get_data_type(arg)) == DATA_INT);
		dtype_set(que_node_get_data_type(node), DATA_VARCHAR,
			  DATA_ENGLISH, 0);
		break;

	case PARS_TO_BINARY_TOKEN:
		if (dtype_get_mtype(que_node_get_data_type(arg)) == DATA_INT) {
			dtype_set(que_node_get_data_type(node), DATA_VARCHAR,
				  DATA_ENGLISH, 0);
		} else {
			dtype_set(que_node_get_data_type(node), DATA_BINARY,
				  0, 0);
		}
		break;

	case PARS_TO_NUMBER_TOKEN:
	case PARS_BINARY_TO_NUMBER_TOKEN:
	case PARS_LENGTH_TOKEN:
	case PARS_INSTR_TOKEN:
		ut_a(pars_is_string_type(que_node_get_data_type(arg)->mtype));
		dtype_set(que_node_get_data_type(node), DATA_INT, 0, 4);
		break;

	case PARS_SYSDATE_TOKEN:
		ut_a(arg == NULL);
		dtype_set(que_node_get_data_type(node), DATA_INT, 0, 4);
		break;

	case PARS_SUBSTR_TOKEN:
	case PARS_CONCAT_TOKEN:
		ut_a(pars_is_string_type(que_node_get_data_type(arg)->mtype));
		dtype_set(que_node_get_data_type(node), DATA_VARCHAR,
			  DATA_ENGLISH, 0);
		break;

	case '>': case '<': case '=':
	case PARS_GE_TOKEN:
	case PARS_LE_TOKEN:
	case PARS_NE_TOKEN:
	case PARS_AND_TOKEN:
	case PARS_OR_TOKEN:
	case PARS_NOT_TOKEN:
	case PARS_NOTFOUND_TOKEN:

		/* We currently have no iboolean type: use integer type */
		dtype_set(que_node_get_data_type(node), DATA_INT, 0, 4);
		break;

	case PARS_RND_TOKEN:
		ut_a(dtype_get_mtype(que_node_get_data_type(arg)) == DATA_INT);
		dtype_set(que_node_get_data_type(node), DATA_INT, 0, 4);
		break;

	default:
		ut_error;
	}
}

/*********************************************************************//**
Resolves the meaning of variables in an expression and the data types of
functions. It is an error if some identifier cannot be resolved here. */
UNIV_STATIC
void
pars_resolve_exp_variables_and_types(
/*=================================*/
	sel_node_t*	select_node,	/*!< in: select node or NULL; if
					this is not NULL then the variable
					sym nodes are added to the
					copy_variables list of select_node */
	que_node_t*	exp_node)	/*!< in: expression */
{
	func_node_t*	func_node;
	que_node_t*	arg;
	sym_node_t*	sym_node;
	sym_node_t*	node;

	ut_a(exp_node);

	if (que_node_get_type(exp_node) == QUE_NODE_FUNC) {
		func_node = exp_node;

		arg = func_node->args;

		while (arg) {
			pars_resolve_exp_variables_and_types(select_node, arg);

			arg = que_node_get_next(arg);
		}

		pars_resolve_func_data_type(func_node);

		return;
	}

	ut_a(que_node_get_type(exp_node) == QUE_NODE_SYMBOL);

	sym_node = exp_node;

	if (sym_node->resolved) {

		return;
	}

	/* Not resolved yet: look in the symbol table for a variable
	or a cursor or a function with the same name */

	node = UT_LIST_GET_FIRST(pars_sym_tab_global->sym_list);

	while (node) {
		if (node->resolved
		    && ((node->token_type == SYM_VAR)
			|| (node->token_type == SYM_CURSOR)
			|| (node->token_type == SYM_FUNCTION))
		    && node->name
		    && (sym_node->name_len == node->name_len)
		    && (ut_memcmp(sym_node->name, node->name,
				  node->name_len) == 0)) {

			/* Found a variable or a cursor declared with
			the same name */

			break;
		}

		node = UT_LIST_GET_NEXT(sym_list, node);
	}

	if (!node) {
		ib_logger(ib_stream, "PARSER ERROR: Unresolved identifier %s\n",
			sym_node->name);
	}

	ut_a(node);

	sym_node->resolved = TRUE;
	sym_node->token_type = SYM_IMPLICIT_VAR;
	sym_node->alias = node;
	sym_node->indirection = node;

	if (select_node) {
		UT_LIST_ADD_LAST(col_var_list, select_node->copy_variables,
				 sym_node);
	}

	dfield_set_type(que_node_get_val(sym_node),
			que_node_get_data_type(node));
}

/*********************************************************************//**
Resolves the meaning of variables in an expression list. It is an error if
some identifier cannot be resolved here. Resolves also the data types of
functions. */
UNIV_STATIC
void
pars_resolve_exp_list_variables_and_types(
/*======================================*/
	sel_node_t*	select_node,	/*!< in: select node or NULL */
	que_node_t*	exp_node)	/*!< in: expression list first node, or
					NULL */
{
	while (exp_node) {
		pars_resolve_exp_variables_and_types(select_node, exp_node);

		exp_node = que_node_get_next(exp_node);
	}
}

/*********************************************************************//**
Resolves the columns in an expression. */
UNIV_STATIC
void
pars_resolve_exp_columns(
/*=====================*/
	sym_node_t*	table_node,	/*!< in: first node in a table list */
	que_node_t*	exp_node)	/*!< in: expression */
{
	func_node_t*	func_node;
	que_node_t*	arg;
	sym_node_t*	sym_node;
	dict_table_t*	table;
	sym_node_t*	t_node;
	ulint		n_cols;
	ulint		i;

	ut_a(exp_node);

	if (que_node_get_type(exp_node) == QUE_NODE_FUNC) {
		func_node = exp_node;

		arg = func_node->args;

		while (arg) {
			pars_resolve_exp_columns(table_node, arg);

			arg = que_node_get_next(arg);
		}

		return;
	}

	ut_a(que_node_get_type(exp_node) == QUE_NODE_SYMBOL);

	sym_node = exp_node;

	if (sym_node->resolved) {

		return;
	}

	/* Not resolved yet: look in the table list for a column with the
	same name */

	t_node = table_node;

	while (t_node) {
		table = t_node->table;

		n_cols = dict_table_get_n_cols(table);

		for (i = 0; i < n_cols; i++) {
			const dict_col_t*	col
				= dict_table_get_nth_col(table, i);
			const char*		col_name
				= dict_table_get_col_name(table, i);

			if ((sym_node->name_len == ut_strlen(col_name))
			    && (0 == ut_memcmp(sym_node->name, col_name,
					       sym_node->name_len))) {
				/* Found */
				sym_node->resolved = TRUE;
				sym_node->token_type = SYM_COLUMN;
				sym_node->table = table;
				sym_node->col_no = i;
				sym_node->prefetch_buf = NULL;

				dict_col_copy_type(
					col,
					dfield_get_type(&sym_node
							->common.val));

				return;
			}
		}

		t_node = que_node_get_next(t_node);
	}
}

/*********************************************************************//**
Resolves the meaning of columns in an expression list. */
UNIV_STATIC
void
pars_resolve_exp_list_columns(
/*==========================*/
	sym_node_t*	table_node,	/*!< in: first node in a table list */
	que_node_t*	exp_node)	/*!< in: expression list first node, or
					NULL */
{
	while (exp_node) {
		pars_resolve_exp_columns(table_node, exp_node);

		exp_node = que_node_get_next(exp_node);
	}
}

/*********************************************************************//**
Retrieves the table definition for a table name id. */
UNIV_STATIC
void
pars_retrieve_table_def(
/*====================*/
	sym_node_t*	sym_node)	/*!< in: table node */
{
	const char*	table_name;

	ut_a(sym_node);
	ut_a(que_node_get_type(sym_node) == QUE_NODE_SYMBOL);

	sym_node->resolved = TRUE;
	sym_node->token_type = SYM_TABLE;

	table_name = (const char*) sym_node->name;

	sym_node->table = dict_table_get_low(table_name);

	ut_a(sym_node->table);
}

/*********************************************************************//**
Retrieves the table definitions for a list of table name ids.
@return	number of tables */
UNIV_STATIC
ulint
pars_retrieve_table_list_defs(
/*==========================*/
	sym_node_t*	sym_node)	/*!< in: first table node in list */
{
	ulint		count		= 0;

	if (sym_node == NULL) {

		return(count);
	}

	while (sym_node) {
		pars_retrieve_table_def(sym_node);

		count++;

		sym_node = que_node_get_next(sym_node);
	}

	return(count);
}

/*********************************************************************//**
Adds all columns to the select list if the query is SELECT * FROM ... */
UNIV_STATIC
void
pars_select_all_columns(
/*====================*/
	sel_node_t*	select_node)	/*!< in: select node already containing
					the table list */
{
	sym_node_t*	col_node;
	sym_node_t*	table_node;
	dict_table_t*	table;
	ulint		i;

	select_node->select_list = NULL;

	table_node = select_node->table_list;

	while (table_node) {
		table = table_node->table;

		for (i = 0; i < dict_table_get_n_user_cols(table); i++) {
			const char*	col_name = dict_table_get_col_name(
				table, i);

			col_node = sym_tab_add_id(pars_sym_tab_global,
						  (byte*)col_name,
						  ut_strlen(col_name));

			select_node->select_list = que_node_list_add_last(
				select_node->select_list, col_node);
		}

		table_node = que_node_get_next(table_node);
	}
}

/*********************************************************************//**
Parses a select list; creates a query graph node for the whole SELECT
statement.
@return	own: select node in a query tree */
UNIV_INTERN
sel_node_t*
pars_select_list(
/*=============*/
	que_node_t*	select_list,	/*!< in: select list */
	sym_node_t*	into_list)	/*!< in: variables list or NULL */
{
	sel_node_t*	node;

	node = sel_node_create(pars_sym_tab_global->heap);

	node->select_list = select_list;
	node->into_list = into_list;

	pars_resolve_exp_list_variables_and_types(NULL, into_list);

	return(node);
}

/*********************************************************************//**
Checks if the query is an aggregate query, in which case the selct list must
contain only aggregate function items. */
UNIV_STATIC
void
pars_check_aggregate(
/*=================*/
	sel_node_t*	select_node)	/*!< in: select node already containing
					the select list */
{
	que_node_t*	exp_node;
	func_node_t*	func_node;
	ulint		n_nodes			= 0;
	ulint		n_aggregate_nodes	= 0;

	exp_node = select_node->select_list;

	while (exp_node) {

		n_nodes++;

		if (que_node_get_type(exp_node) == QUE_NODE_FUNC) {

			func_node = exp_node;

			if (func_node->class == PARS_FUNC_AGGREGATE) {

				n_aggregate_nodes++;
			}
		}

		exp_node = que_node_get_next(exp_node);
	}

	if (n_aggregate_nodes > 0) {
		ut_a(n_nodes == n_aggregate_nodes);

		select_node->is_aggregate = TRUE;
	} else {
		select_node->is_aggregate = FALSE;
	}
}

/*********************************************************************//**
Parses a select statement.
@return	own: select node in a query tree */
UNIV_INTERN
sel_node_t*
pars_select_statement(
/*==================*/
	sel_node_t*	select_node,	/*!< in: select node already containing
					the select list */
	sym_node_t*	table_list,	/*!< in: table list */
	que_node_t*	search_cond,	/*!< in: search condition or NULL */
	pars_res_word_t* for_update,	/*!< in: NULL or &pars_update_token */
	pars_res_word_t* lock_shared,	/*!< in: NULL or &pars_share_token */
	order_node_t*	order_by)	/*!< in: NULL or an order-by node */
{
	select_node->state = SEL_NODE_OPEN;

	select_node->table_list = table_list;
	select_node->n_tables = pars_retrieve_table_list_defs(table_list);

	if (select_node->select_list == &pars_star_denoter) {

		/* SELECT * FROM ... */
		pars_select_all_columns(select_node);
	}

	if (select_node->into_list) {
		ut_a(que_node_list_get_len(select_node->into_list)
		     == que_node_list_get_len(select_node->select_list));
	}

	UT_LIST_INIT(select_node->copy_variables);

	pars_resolve_exp_list_columns(table_list, select_node->select_list);
	pars_resolve_exp_list_variables_and_types(select_node,
						  select_node->select_list);
	pars_check_aggregate(select_node);

	select_node->search_cond = search_cond;

	if (search_cond) {
		pars_resolve_exp_columns(table_list, search_cond);
		pars_resolve_exp_variables_and_types(select_node, search_cond);
	}

	if (for_update) {
		ut_a(!lock_shared);

		select_node->set_x_locks = TRUE;
		select_node->row_lock_mode = LOCK_X;

		select_node->consistent_read = FALSE;
		select_node->read_view = NULL;
	} else if (lock_shared){
		select_node->set_x_locks = FALSE;
		select_node->row_lock_mode = LOCK_S;

		select_node->consistent_read = FALSE;
		select_node->read_view = NULL;
	} else {
		select_node->set_x_locks = FALSE;
		select_node->row_lock_mode = LOCK_S;

		select_node->consistent_read = TRUE;
	}

	select_node->order_by = order_by;

	if (order_by) {
		pars_resolve_exp_columns(table_list, order_by->column);
	}

	/* The final value of the following fields depend on the environment
	where the select statement appears: */

	select_node->can_get_updated = FALSE;
	select_node->explicit_cursor = NULL;

	opt_search_plan(select_node);

	return(select_node);
}

/*********************************************************************//**
Parses a cursor declaration.
@return	sym_node */
UNIV_INTERN
que_node_t*
pars_cursor_declaration(
/*====================*/
	sym_node_t*	sym_node,	/*!< in: cursor id node in the symbol
					table */
	sel_node_t*	select_node)	/*!< in: select node */
{
	sym_node->resolved = TRUE;
	sym_node->token_type = SYM_CURSOR;
	sym_node->cursor_def = select_node;

	select_node->state = SEL_NODE_CLOSED;
	select_node->explicit_cursor = sym_node;

	return(sym_node);
}

/*********************************************************************//**
Parses a function declaration.
@return	sym_node */
UNIV_INTERN
que_node_t*
pars_function_declaration(
/*======================*/
	sym_node_t*	sym_node)	/*!< in: function id node in the symbol
					table */
{
	sym_node->resolved = TRUE;
	sym_node->token_type = SYM_FUNCTION;

	/* Check that the function exists. */
	ut_a(pars_info_get_user_func(pars_sym_tab_global->info,
				     sym_node->name));

	return(sym_node);
}

/*********************************************************************//**
Parses a delete or update statement start.
@return	own: update node in a query tree */
UNIV_INTERN
upd_node_t*
pars_update_statement_start(
/*========================*/
	ibool		is_delete,	/*!< in: TRUE if delete */
	sym_node_t*	table_sym,	/*!< in: table name node */
	col_assign_node_t* col_assign_list)/*!< in: column assignment list, NULL
					if delete */
{
	upd_node_t*	node;

	node = upd_node_create(pars_sym_tab_global->heap);

	node->is_delete = is_delete;

	node->table_sym = table_sym;
	node->col_assign_list = col_assign_list;

	return(node);
}

/*********************************************************************//**
Parses a column assignment in an update.
@return	column assignment node */
UNIV_INTERN
col_assign_node_t*
pars_column_assignment(
/*===================*/
	sym_node_t*	column,	/*!< in: column to assign */
	que_node_t*	exp)	/*!< in: value to assign */
{
	col_assign_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap,
			      sizeof(col_assign_node_t));
	node->common.type = QUE_NODE_COL_ASSIGNMENT;

	node->col = column;
	node->val = exp;

	return(node);
}

/*********************************************************************//**
Processes an update node assignment list. */
UNIV_STATIC
void
pars_process_assign_list(
/*=====================*/
	upd_node_t*	node)	/*!< in: update node */
{
	col_assign_node_t*	col_assign_list;
	sym_node_t*		table_sym;
	col_assign_node_t*	assign_node;
	upd_field_t*		upd_field;
	dict_index_t*		clust_index;
	sym_node_t*		col_sym;
	ulint			changes_ord_field;
	ulint			changes_field_size;
	ulint			n_assigns;
	ulint			i;

	table_sym = node->table_sym;
	col_assign_list = node->col_assign_list;
	clust_index = dict_table_get_first_index(node->table);

	assign_node = col_assign_list;
	n_assigns = 0;

	while (assign_node) {
		pars_resolve_exp_columns(table_sym, assign_node->col);
		pars_resolve_exp_columns(table_sym, assign_node->val);
		pars_resolve_exp_variables_and_types(NULL, assign_node->val);
#if 0
		ut_a(dtype_get_mtype(
			     dfield_get_type(que_node_get_val(
						     assign_node->col)))
		     == dtype_get_mtype(
			     dfield_get_type(que_node_get_val(
						     assign_node->val))));
#endif

		/* Add to the update node all the columns found in assignment
		values as columns to copy: therefore, TRUE */

		opt_find_all_cols(TRUE, clust_index, &(node->columns), NULL,
				  assign_node->val);
		n_assigns++;

		assign_node = que_node_get_next(assign_node);
	}

	node->update = upd_create(n_assigns, pars_sym_tab_global->heap);

	assign_node = col_assign_list;

	changes_field_size = UPD_NODE_NO_SIZE_CHANGE;

	for (i = 0; i < n_assigns; i++) {
		upd_field = upd_get_nth_field(node->update, i);

		col_sym = assign_node->col;

		upd_field_set_field_no(upd_field, dict_index_get_nth_col_pos(
					       clust_index, col_sym->col_no),
				       clust_index, NULL);
		upd_field->exp = assign_node->val;

		if (!dict_col_get_fixed_size(
			    dict_index_get_nth_col(clust_index,
						   upd_field->field_no),
			    dict_table_is_comp(node->table))) {
			changes_field_size = 0;
		}

		assign_node = que_node_get_next(assign_node);
	}

	/* Find out if the update can modify an ordering field in any index */

	changes_ord_field = UPD_NODE_NO_ORD_CHANGE;

	if (row_upd_changes_some_index_ord_field_binary(node->table,
							node->update)) {
		changes_ord_field = 0;
	}

	node->cmpl_info = changes_ord_field | changes_field_size;
}

/*********************************************************************//**
Parses an update or delete statement.
@return	own: update node in a query tree */
UNIV_INTERN
upd_node_t*
pars_update_statement(
/*==================*/
	upd_node_t*	node,		/*!< in: update node */
	sym_node_t*	cursor_sym,	/*!< in: pointer to a cursor entry in
					the symbol table or NULL */
	que_node_t*	search_cond)	/*!< in: search condition or NULL */
{
	sym_node_t*	table_sym;
	sel_node_t*	sel_node;
	plan_t*		plan;

	table_sym = node->table_sym;

	pars_retrieve_table_def(table_sym);
	node->table = table_sym->table;

	UT_LIST_INIT(node->columns);

	/* Make the single table node into a list of table nodes of length 1 */

	que_node_list_add_last(NULL, table_sym);

	if (cursor_sym) {
		pars_resolve_exp_variables_and_types(NULL, cursor_sym);

		sel_node = cursor_sym->alias->cursor_def;

		node->searched_update = FALSE;
	} else {
		sel_node = pars_select_list(NULL, NULL);

		pars_select_statement(sel_node, table_sym, search_cond, NULL,
				      &pars_share_token, NULL);
		node->searched_update = TRUE;
		sel_node->common.parent = node;
	}

	node->select = sel_node;

	ut_a(!node->is_delete || (node->col_assign_list == NULL));
	ut_a(node->is_delete || (node->col_assign_list != NULL));

	if (node->is_delete) {
		node->cmpl_info = 0;
	} else {
		pars_process_assign_list(node);
	}

	if (node->searched_update) {
		node->has_clust_rec_x_lock = TRUE;
		sel_node->set_x_locks = TRUE;
		sel_node->row_lock_mode = LOCK_X;
	} else {
		node->has_clust_rec_x_lock = sel_node->set_x_locks;
	}

	ut_a(sel_node->n_tables == 1);
	ut_a(sel_node->consistent_read == FALSE);
	ut_a(sel_node->order_by == NULL);
	ut_a(sel_node->is_aggregate == FALSE);

	sel_node->can_get_updated = TRUE;

	node->state = UPD_NODE_UPDATE_CLUSTERED;

	plan = sel_node_get_nth_plan(sel_node, 0);

	plan->no_prefetch = TRUE;

	if (!dict_index_is_clust(plan->index)) {

		plan->must_get_clust = TRUE;

		node->pcur = &(plan->clust_pcur);
	} else {
		node->pcur = &(plan->pcur);
	}

	return(node);
}

/*********************************************************************//**
Parses an insert statement.
@return	own: update node in a query tree */
UNIV_INTERN
ins_node_t*
pars_insert_statement(
/*==================*/
	sym_node_t*	table_sym,	/*!< in: table name node */
	que_node_t*	values_list,	/*!< in: value expression list or NULL */
	sel_node_t*	select)		/*!< in: select condition or NULL */
{
	ins_node_t*	node;
	dtuple_t*	row;
	ulint		ins_type;

	ut_a(values_list || select);
	ut_a(!values_list || !select);

	if (values_list) {
		ins_type = INS_VALUES;
	} else {
		ins_type = INS_SEARCHED;
	}

	pars_retrieve_table_def(table_sym);

	node = row_ins_node_create(ins_type, table_sym->table,
			       pars_sym_tab_global->heap);

	row = dtuple_create(pars_sym_tab_global->heap,
			    dict_table_get_n_cols(node->table));

	dict_table_copy_types(row, table_sym->table);

	row_ins_node_set_new_row(node, row);

	node->select = select;

	if (select) {
		select->common.parent = node;

		ut_a(que_node_list_get_len(select->select_list)
		     == dict_table_get_n_user_cols(table_sym->table));
	}

	node->values_list = values_list;

	if (node->values_list) {
		pars_resolve_exp_list_variables_and_types(NULL, values_list);

		ut_a(que_node_list_get_len(values_list)
		     == dict_table_get_n_user_cols(table_sym->table));
	}

	return(node);
}

/*********************************************************************//**
Set the type of a dfield. */
UNIV_STATIC
void
pars_set_dfield_type(
/*=================*/
	dfield_t*		dfield,		/*!< in: dfield */
	pars_res_word_t*	type,		/*!< in: pointer to a type
						token */
	ulint			len,		/*!< in: length, or 0 */
	ibool			is_unsigned,	/*!< in: if TRUE, column is
						UNSIGNED. */
	ibool			is_not_null)	/*!< in: if TRUE, column is
						NOT NULL. */
{
	ulint flags = 0;

	if (is_not_null) {
		flags |= DATA_NOT_NULL;
	}

	if (is_unsigned) {
		flags |= DATA_UNSIGNED;
	}

	if (type == &pars_int_token) {
		ut_a(len == 0);

		dtype_set(dfield_get_type(dfield), DATA_INT, flags, 4);

	} else if (type == &pars_char_token) {
		ut_a(len == 0);

		dtype_set(dfield_get_type(dfield), DATA_VARCHAR,
			  DATA_ENGLISH | flags, 0);
	} else if (type == &pars_binary_token) {
		ut_a(len != 0);

		dtype_set(dfield_get_type(dfield), DATA_FIXBINARY,
			  DATA_BINARY_TYPE | flags, len);
	} else if (type == &pars_blob_token) {
		ut_a(len == 0);

		dtype_set(dfield_get_type(dfield), DATA_BLOB,
			  DATA_BINARY_TYPE | flags, 0);
	} else {
		ut_error;
	}
}

/*********************************************************************//**
Parses a variable declaration.
@return	own: symbol table node of type SYM_VAR */
UNIV_INTERN
sym_node_t*
pars_variable_declaration(
/*======================*/
	sym_node_t*	node,	/*!< in: symbol table node allocated for the
				id of the variable */
	pars_res_word_t* type)	/*!< in: pointer to a type token */
{
	node->resolved = TRUE;
	node->token_type = SYM_VAR;

	node->param_type = PARS_NOT_PARAM;

	pars_set_dfield_type(que_node_get_val(node), type, 0, FALSE, FALSE);

	return(node);
}

/*********************************************************************//**
Parses a procedure parameter declaration.
@return	own: symbol table node of type SYM_VAR */
UNIV_INTERN
sym_node_t*
pars_parameter_declaration(
/*=======================*/
	sym_node_t*	node,	/*!< in: symbol table node allocated for the
				id of the parameter */
	ulint		param_type,
				/*!< in: PARS_INPUT or PARS_OUTPUT */
	pars_res_word_t* type)	/*!< in: pointer to a type token */
{
	ut_a((param_type == PARS_INPUT) || (param_type == PARS_OUTPUT));

	pars_variable_declaration(node, type);

	node->param_type = param_type;

	return(node);
}

/*********************************************************************//**
Sets the parent field in a query node list. */
UNIV_STATIC
void
pars_set_parent_in_list(
/*====================*/
	que_node_t*	node_list,	/*!< in: first node in a list */
	que_node_t*	parent)		/*!< in: parent value to set in all
					nodes of the list */
{
	que_common_t*	common;

	common = node_list;

	while (common) {
		common->parent = parent;

		common = que_node_get_next(common);
	}
}

/*********************************************************************//**
Parses an elsif element.
@return	elsif node */
UNIV_INTERN
elsif_node_t*
pars_elsif_element(
/*===============*/
	que_node_t*	cond,		/*!< in: if-condition */
	que_node_t*	stat_list)	/*!< in: statement list */
{
	elsif_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(elsif_node_t));

	node->common.type = QUE_NODE_ELSIF;

	node->cond = cond;

	pars_resolve_exp_variables_and_types(NULL, cond);

	node->stat_list = stat_list;

	return(node);
}

/*********************************************************************//**
Parses an if-statement.
@return	if-statement node */
UNIV_INTERN
if_node_t*
pars_if_statement(
/*==============*/
	que_node_t*	cond,		/*!< in: if-condition */
	que_node_t*	stat_list,	/*!< in: statement list */
	que_node_t*	else_part)	/*!< in: else-part statement list
					or elsif element list */
{
	if_node_t*	node;
	elsif_node_t*	elsif_node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(if_node_t));

	node->common.type = QUE_NODE_IF;

	node->cond = cond;

	pars_resolve_exp_variables_and_types(NULL, cond);

	node->stat_list = stat_list;

	if (else_part && (que_node_get_type(else_part) == QUE_NODE_ELSIF)) {

		/* There is a list of elsif conditions */

		node->else_part = NULL;
		node->elsif_list = else_part;

		elsif_node = else_part;

		while (elsif_node) {
			pars_set_parent_in_list(elsif_node->stat_list, node);

			elsif_node = que_node_get_next(elsif_node);
		}
	} else {
		node->else_part = else_part;
		node->elsif_list = NULL;

		pars_set_parent_in_list(else_part, node);
	}

	pars_set_parent_in_list(stat_list, node);

	return(node);
}

/*********************************************************************//**
Parses a while-statement.
@return	while-statement node */
UNIV_INTERN
while_node_t*
pars_while_statement(
/*=================*/
	que_node_t*	cond,		/*!< in: while-condition */
	que_node_t*	stat_list)	/*!< in: statement list */
{
	while_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(while_node_t));

	node->common.type = QUE_NODE_WHILE;

	node->cond = cond;

	pars_resolve_exp_variables_and_types(NULL, cond);

	node->stat_list = stat_list;

	pars_set_parent_in_list(stat_list, node);

	return(node);
}

/*********************************************************************//**
Parses a for-loop-statement.
@return	for-statement node */
UNIV_INTERN
for_node_t*
pars_for_statement(
/*===============*/
	sym_node_t*	loop_var,	/*!< in: loop variable */
	que_node_t*	loop_start_limit,/*!< in: loop start expression */
	que_node_t*	loop_end_limit,	/*!< in: loop end expression */
	que_node_t*	stat_list)	/*!< in: statement list */
{
	for_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(for_node_t));

	node->common.type = QUE_NODE_FOR;

	pars_resolve_exp_variables_and_types(NULL, loop_var);
	pars_resolve_exp_variables_and_types(NULL, loop_start_limit);
	pars_resolve_exp_variables_and_types(NULL, loop_end_limit);

	node->loop_var = loop_var->indirection;

	ut_a(loop_var->indirection);

	node->loop_start_limit = loop_start_limit;
	node->loop_end_limit = loop_end_limit;

	node->stat_list = stat_list;

	pars_set_parent_in_list(stat_list, node);

	return(node);
}

/*********************************************************************//**
Parses an exit statement.
@return	exit statement node */
UNIV_INTERN
exit_node_t*
pars_exit_statement(void)
/*=====================*/
{
	exit_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(exit_node_t));
	node->common.type = QUE_NODE_EXIT;

	return(node);
}

/*********************************************************************//**
Parses a return-statement.
@return	return-statement node */
UNIV_INTERN
return_node_t*
pars_return_statement(void)
/*=======================*/
{
	return_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap,
			      sizeof(return_node_t));
	node->common.type = QUE_NODE_RETURN;

	return(node);
}

/*********************************************************************//**
Parses an assignment statement.
@return	assignment statement node */
UNIV_INTERN
assign_node_t*
pars_assignment_statement(
/*======================*/
	sym_node_t*	var,	/*!< in: variable to assign */
	que_node_t*	val)	/*!< in: value to assign */
{
	assign_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap,
			      sizeof(assign_node_t));
	node->common.type = QUE_NODE_ASSIGNMENT;

	node->var = var;
	node->val = val;

	pars_resolve_exp_variables_and_types(NULL, var);
	pars_resolve_exp_variables_and_types(NULL, val);

	ut_a(dtype_get_mtype(dfield_get_type(que_node_get_val(var)))
	     == dtype_get_mtype(dfield_get_type(que_node_get_val(val))));

	return(node);
}

/*********************************************************************//**
Parses a procedure call.
@return	function node */
UNIV_INTERN
func_node_t*
pars_procedure_call(
/*================*/
	que_node_t*	res_word,/*!< in: procedure name reserved word */
	que_node_t*	args)	/*!< in: argument list */
{
	func_node_t*	node;

	node = pars_func(res_word, args);

	pars_resolve_exp_list_variables_and_types(NULL, args);

	return(node);
}

/*********************************************************************//**
Parses a fetch statement. into_list or user_func (but not both) must be
non-NULL.
@return	fetch statement node */
UNIV_INTERN
fetch_node_t*
pars_fetch_statement(
/*=================*/
	sym_node_t*	cursor,		/*!< in: cursor node */
	sym_node_t*	into_list,	/*!< in: variables to set, or NULL */
	sym_node_t*	user_func)	/*!< in: user function name, or NULL */
{
	sym_node_t*	cursor_decl;
	fetch_node_t*	node;

	/* Logical XOR. */
	ut_a(!into_list != !user_func);

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(fetch_node_t));

	node->common.type = QUE_NODE_FETCH;

	pars_resolve_exp_variables_and_types(NULL, cursor);

	if (into_list) {
		pars_resolve_exp_list_variables_and_types(NULL, into_list);
		node->into_list = into_list;
		node->func = NULL;
	} else {
		pars_resolve_exp_variables_and_types(NULL, user_func);

		node->func = pars_info_get_user_func(pars_sym_tab_global->info,
						     user_func->name);
		ut_a(node->func);

		node->into_list = NULL;
	}

	cursor_decl = cursor->alias;

	ut_a(cursor_decl->token_type == SYM_CURSOR);

	node->cursor_def = cursor_decl->cursor_def;

	if (into_list) {
		ut_a(que_node_list_get_len(into_list)
		     == que_node_list_get_len(node->cursor_def->select_list));
	}

	return(node);
}

/*********************************************************************//**
Parses an open or close cursor statement.
@return	fetch statement node */
UNIV_INTERN
open_node_t*
pars_open_statement(
/*================*/
	ulint		type,	/*!< in: ROW_SEL_OPEN_CURSOR
				or ROW_SEL_CLOSE_CURSOR */
	sym_node_t*	cursor)	/*!< in: cursor node */
{
	sym_node_t*	cursor_decl;
	open_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap, sizeof(open_node_t));

	node->common.type = QUE_NODE_OPEN;

	pars_resolve_exp_variables_and_types(NULL, cursor);

	cursor_decl = cursor->alias;

	ut_a(cursor_decl->token_type == SYM_CURSOR);

	node->op_type = type;
	node->cursor_def = cursor_decl->cursor_def;

	return(node);
}

/*********************************************************************//**
Parses a row_printf-statement.
@return	row_printf-statement node */
UNIV_INTERN
row_printf_node_t*
pars_row_printf_statement(
/*======================*/
	sel_node_t*	sel_node)	/*!< in: select node */
{
	row_printf_node_t*	node;

	node = mem_heap_alloc(pars_sym_tab_global->heap,
			      sizeof(row_printf_node_t));
	node->common.type = QUE_NODE_ROW_PRINTF;

	node->sel_node = sel_node;

	sel_node->common.parent = node;

	return(node);
}

/*********************************************************************//**
Parses a commit statement.
@return	own: commit node struct */
UNIV_INTERN
commit_node_t*
pars_commit_statement(void)
/*=======================*/
{
	return(commit_node_create(pars_sym_tab_global->heap));
}

/*********************************************************************//**
Parses a rollback statement.
@return	own: rollback node struct */
UNIV_INTERN
roll_node_t*
pars_rollback_statement(void)
/*=========================*/
{
	return(roll_node_create(pars_sym_tab_global->heap));
}

/*********************************************************************//**
Parses a column definition at a table creation.
@return	column sym table node */
UNIV_INTERN
sym_node_t*
pars_column_def(
/*============*/
	sym_node_t*		sym_node,	/*!< in: column node in the
						symbol table */
	pars_res_word_t*	type,		/*!< in: data type */
	sym_node_t*		len,		/*!< in: length of column, or
						NULL */
	void*			is_unsigned,	/*!< in: if not NULL, column
						is of type UNSIGNED. */
	void*			is_not_null)	/*!< in: if not NULL, column
						is of type NOT NULL. */
{
	ulint len2;

	if (len) {
		len2 = eval_node_get_int_val(len);
	} else {
		len2 = 0;
	}

	pars_set_dfield_type(que_node_get_val(sym_node), type, len2,
			     is_unsigned != NULL, is_not_null != NULL);

	return(sym_node);
}

/*********************************************************************//**
Parses a table creation operation.
@return	table create subgraph */
UNIV_INTERN
tab_node_t*
pars_create_table(
/*==============*/
	sym_node_t*	table_sym,	/*!< in: table name node in the symbol
					table */
	sym_node_t*	column_defs,	/*!< in: list of column names */
	void*		not_fit_in_memory __attribute__((unused)))
					/*!< in: a non-NULL pointer means that
					this is a table which in simulations
					should be simulated as not fitting
					in memory; thread is put to sleep
					to simulate disk accesses; NOTE that
					this flag is not stored to the data
					dictionary on disk, and the database
					will forget about non-NULL value if
					it has to reload the table definition
					from disk */
{
	dict_table_t*	table;
	sym_node_t*	column;
	tab_node_t*	node;
	const dtype_t*	dtype;
	ulint		n_cols;

	n_cols = que_node_list_get_len(column_defs);

	/* As the InnoDB SQL parser is for internal use only,
	for creating some system tables, this function will only
	create tables in the old (not compact) record format. */
	table = dict_mem_table_create(table_sym->name, 0, n_cols, 0);

#ifdef UNIV_DEBUG
	if (not_fit_in_memory != NULL) {
		table->does_not_fit_in_memory = TRUE;
	}
#endif /* UNIV_DEBUG */
	column = column_defs;

	while (column) {
		dtype = dfield_get_type(que_node_get_val(column));

		dict_mem_table_add_col(table, table->heap,
				       column->name, dtype->mtype,
				       dtype->prtype, dtype->len);
		column->resolved = TRUE;
		column->token_type = SYM_COLUMN;

		column = que_node_get_next(column);
	}

	node = tab_create_graph_create(table, pars_sym_tab_global->heap, TRUE);

	table_sym->resolved = TRUE;
	table_sym->token_type = SYM_TABLE;

	return(node);
}

/*********************************************************************//**
Parses an index creation operation.
@return	index create subgraph */
UNIV_INTERN
ind_node_t*
pars_create_index(
/*==============*/
	pars_res_word_t* unique_def,	/*!< in: not NULL if a unique index */
	pars_res_word_t* clustered_def,	/*!< in: not NULL if a clustered index */
	sym_node_t*	index_sym,	/*!< in: index name node in the symbol
					table */
	sym_node_t*	table_sym,	/*!< in: table name node in the symbol
					table */
	sym_node_t*	column_list)	/*!< in: list of column names */
{
	dict_index_t*	index;
	sym_node_t*	column;
	ind_node_t*	node;
	ulint		n_fields;
	ulint		ind_type;

	n_fields = que_node_list_get_len(column_list);

	ind_type = 0;

	if (unique_def) {
		ind_type = ind_type | DICT_UNIQUE;
	}

	if (clustered_def) {
		ind_type = ind_type | DICT_CLUSTERED;
	}

	index = dict_mem_index_create(table_sym->name, index_sym->name, 0,
				      ind_type, n_fields);
	column = column_list;

	while (column) {
		dict_mem_index_add_field(index, column->name, 0);

		column->resolved = TRUE;
		column->token_type = SYM_COLUMN;

		column = que_node_get_next(column);
	}

	node = ind_create_graph_create(index, pars_sym_tab_global->heap, TRUE);

	table_sym->resolved = TRUE;
	table_sym->token_type = SYM_TABLE;

	index_sym->resolved = TRUE;
	index_sym->token_type = SYM_TABLE;

	return(node);
}

/*********************************************************************//**
Parses a procedure definition.
@return	query fork node */
UNIV_INTERN
que_fork_t*
pars_procedure_definition(
/*======================*/
	sym_node_t*	sym_node,	/*!< in: procedure id node in the symbol
					table */
	sym_node_t*	param_list,	/*!< in: parameter declaration list */
	que_node_t*	stat_list)	/*!< in: statement list */
{
	proc_node_t*	node;
	que_fork_t*	fork;
	que_thr_t*	thr;
	mem_heap_t*	heap;

	heap = pars_sym_tab_global->heap;

	fork = que_fork_create(NULL, NULL, QUE_FORK_PROCEDURE, heap);
	fork->trx = NULL;

	thr = que_thr_create(fork, heap);

	node = mem_heap_alloc(heap, sizeof(proc_node_t));

	node->common.type = QUE_NODE_PROC;
	node->common.parent = thr;

	sym_node->token_type = SYM_PROCEDURE_NAME;
	sym_node->resolved = TRUE;

	node->proc_id = sym_node;
	node->param_list = param_list;
	node->stat_list = stat_list;

	pars_set_parent_in_list(stat_list, node);

	node->sym_tab = pars_sym_tab_global;

	thr->child = node;

	pars_sym_tab_global->query_graph = fork;

	return(fork);
}

/*************************************************************//**
Parses a stored procedure call, when this is not within another stored
procedure, that is, the client issues a procedure call directly.
In InnoDB, stored InnoDB procedures are invoked via the
parsed procedure tree, not via InnoDB SQL, so this function is not used.
@return	query graph */
UNIV_INTERN
que_fork_t*
pars_stored_procedure_call(
/*=======================*/
	sym_node_t*	sym_node __attribute__((unused)))
					/*!< in: stored procedure name */
{
	ut_error;
	return(NULL);
}

/*************************************************************//**
Retrieves characters to the lexical analyzer. */
UNIV_INTERN
void
pars_get_lex_chars(
/*===============*/
	char*	buf,		/*!< in/out: buffer where to copy */
	int*	result,		/*!< out: number of characters copied or EOF */
	int	max_size)	/*!< in: maximum number of characters which fit
				in the buffer */
{
	int	len;

	len = pars_sym_tab_global->string_len
		- pars_sym_tab_global->next_char_pos;
	if (len == 0) {
#ifdef YYDEBUG
		/* ib_logger(ib_stream, "SQL string ends\n"); */
#endif
		*result = 0;

		return;
	}

	if (len > max_size) {
		len = max_size;
	}

#ifdef UNIV_SQL_DEBUG
	if (pars_print_lexed) {

		if (len >= 5) {
			len = 5;
		}

		fwrite(pars_sym_tab_global->sql_string
		       + pars_sym_tab_global->next_char_pos,
		       1, len, ib_stream);
	}
#endif /* UNIV_SQL_DEBUG */

	ut_memcpy(buf, pars_sym_tab_global->sql_string
		  + pars_sym_tab_global->next_char_pos, len);
	*result = len;

	pars_sym_tab_global->next_char_pos += len;
}

/*************************************************************//**
Called by yyparse on error. */
UNIV_INTERN
void
yyerror(
/*====*/
	const char*	s __attribute__((unused)))
				/*!< in: error message string */
{
	ut_ad(s);

	ib_logger(ib_stream, "PARSER ERROR: Syntax error in SQL string\n");

	ut_error;
}

/*************************************************************//**
Parses an SQL string returning the query graph.
@return	own: the query graph */
UNIV_INTERN
que_t*
pars_sql(
/*=====*/
	pars_info_t*	info,	/*!< in: extra information, or NULL */
	const char*	str)	/*!< in: SQL string */
{
	sym_node_t*	sym_node;
	mem_heap_t*	heap;
	que_t*		graph;

	ut_ad(str);

	heap = mem_heap_create(256);

	/* Currently, the parser is not reentrant: */
	ut_ad(mutex_own(&(dict_sys->mutex)));

	pars_sym_tab_global = sym_tab_create(heap);

	pars_sym_tab_global->string_len = strlen(str);
	pars_sym_tab_global->sql_string = mem_heap_dup(
		heap, str, pars_sym_tab_global->string_len + 1);
	pars_sym_tab_global->next_char_pos = 0;
	pars_sym_tab_global->info = info;

	yyparse();

	sym_node = UT_LIST_GET_FIRST(pars_sym_tab_global->sym_list);

	while (sym_node) {
		ut_a(sym_node->resolved);

		sym_node = UT_LIST_GET_NEXT(sym_list, sym_node);
	}

	graph = pars_sym_tab_global->query_graph;

	graph->sym_tab = pars_sym_tab_global;
	graph->info = info;

	/* ib_logger(ib_stream,
	  	 "SQL graph size %lu\n", mem_heap_get_size(heap)); */

	return(graph);
}

/******************************************************************//**
Completes a query graph by adding query thread and fork nodes
above it and prepares the graph for running. The fork created is of
type QUE_FORK_USER_INTERFACE.
@return	query thread node to run */
UNIV_INTERN
que_thr_t*
pars_complete_graph_for_exec(
/*=========================*/
	que_node_t*	node,	/*!< in: root node for an incomplete
				query graph */
	trx_t*		trx,	/*!< in: transaction handle */
	mem_heap_t*	heap)	/*!< in: memory heap from which allocated */
{
	que_fork_t*	fork;
	que_thr_t*	thr;

	fork = que_fork_create(NULL, NULL, QUE_FORK_USER_INTERFACE, heap);
	fork->trx = trx;

	thr = que_thr_create(fork, heap);

	thr->child = node;

	que_node_set_parent(node, thr);

	trx->graph = NULL;

	return(thr);
}

/****************************************************************//**
Create parser info struct.
@return	own: info struct */
UNIV_INTERN
pars_info_t*
pars_info_create(void)
/*==================*/
{
	pars_info_t*	info;
	mem_heap_t*	heap;

	heap = mem_heap_create(512);

	info = mem_heap_alloc(heap, sizeof(*info));

	info->heap = heap;
	info->funcs = NULL;
	info->bound_lits = NULL;
	info->bound_ids = NULL;
	info->graph_owns_us = TRUE;

	return(info);
}

/****************************************************************//**
Free info struct and everything it contains. */
UNIV_INTERN
void
pars_info_free(
/*===========*/
	pars_info_t*	info)	/*!< in, own: info struct */
{
	mem_heap_free(info->heap);
}

/****************************************************************//**
Add bound literal. */
UNIV_INTERN
void
pars_info_add_literal(
/*==================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	const void*	address,	/*!< in: address */
	ulint		length,		/*!< in: length of data */
	ulint		type,		/*!< in: type, e.g. DATA_FIXBINARY */
	ulint		prtype)		/*!< in: precise type, e.g.
					DATA_UNSIGNED */
{
	pars_bound_lit_t*	pbl;

	ut_ad(!pars_info_get_bound_lit(info, name));

	pbl = mem_heap_alloc(info->heap, sizeof(*pbl));

	pbl->name = name;
	pbl->address = address;
	pbl->length = length;
	pbl->type = type;
	pbl->prtype = prtype;

	if (!info->bound_lits) {
		info->bound_lits = ib_vector_create(info->heap, 8);
	}

	ib_vector_push(info->bound_lits, pbl);
}

/****************************************************************//**
Equivalent to pars_info_add_literal(info, name, str, strlen(str),
DATA_VARCHAR, DATA_ENGLISH). */
UNIV_INTERN
void
pars_info_add_str_literal(
/*======================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	const char*	str)		/*!< in: string */
{
	pars_info_add_literal(info, name, str, strlen(str),
			      DATA_VARCHAR, DATA_ENGLISH);
}

/****************************************************************//**
Equivalent to:

char buf[4];
mach_write_to_4(buf, val);
pars_info_add_literal(info, name, buf, 4, DATA_INT, 0);

except that the buffer is dynamically allocated from the info struct's
heap. */
UNIV_INTERN
void
pars_info_add_int4_literal(
/*=======================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	lint		val)		/*!< in: value */
{
	byte*	buf = mem_heap_alloc(info->heap, 4);

	mach_write_to_4(buf, val);
	pars_info_add_literal(info, name, buf, 4, DATA_INT, 0);
}

/****************************************************************//**
Equivalent to:

char buf[8];
mach_write_ull(buf, val);
pars_info_add_literal(info, name, buf, 8, DATA_INT, 0);

except that the buffer is dynamically allocated from the info struct's
heap. */
UNIV_INTERN
void
pars_info_add_int8_literal(
/*=======================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	ib_uint64_t	val)		/*!< in: value */
{
	byte*	buf = mem_heap_alloc(info->heap, sizeof(val));

	mach_write_ull(buf, val);
	pars_info_add_literal(info, name, buf, sizeof(val), DATA_INT, 0);
}

/********************************************************************
Equivalent to:

char buf[8];
mach_write_to_8(buf, val);
pars_info_add_literal(info, name, buf, 8, DATA_FIXBINARY, 0);

except that the buffer is dynamically allocated from the info struct's
heap. */
UNIV_INTERN
void
pars_info_add_dulint_literal(
/*=========================*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	dulint		val)		/*!< in: value */
{
	byte*	buf = mem_heap_alloc(info->heap, 8);

	mach_write_to_8(buf, val);

	pars_info_add_literal(info, name, buf, 8, DATA_FIXBINARY, 0);
}

/****************************************************************//**
Add user function. */
UNIV_INTERN
void
pars_info_add_function(
/*===================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name,	/*!< in: function name */
	pars_user_func_cb_t	func,	/*!< in: function address */
	void*			arg)	/*!< in: user-supplied argument */
{
	pars_user_func_t*	puf;

	ut_ad(!pars_info_get_user_func(info, name));

	puf = mem_heap_alloc(info->heap, sizeof(*puf));

	puf->name = name;
	puf->func = func;
	puf->arg = arg;

	if (!info->funcs) {
		info->funcs = ib_vector_create(info->heap, 8);
	}

	ib_vector_push(info->funcs, puf);
}

/****************************************************************//**
Add bound id. */
UNIV_INTERN
void
pars_info_add_id(
/*=============*/
	pars_info_t*	info,		/*!< in: info struct */
	const char*	name,		/*!< in: name */
	const char*	id)		/*!< in: id */
{
	pars_bound_id_t*	bid;

	ut_ad(!pars_info_get_bound_id(info, name));

	bid = mem_heap_alloc(info->heap, sizeof(*bid));

	bid->name = name;
	bid->id = id;

	if (!info->bound_ids) {
		info->bound_ids = ib_vector_create(info->heap, 8);
	}

	ib_vector_push(info->bound_ids, bid);
}

/****************************************************************//**
Get user function with the given name.
@return	user func, or NULL if not found */
UNIV_INTERN
pars_user_func_t*
pars_info_get_user_func(
/*====================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name)	/*!< in: function name to find*/
{
	ulint		i;
	ib_vector_t*	vec;

	if (!info || !info->funcs) {
		return(NULL);
	}

	vec = info->funcs;

	for (i = 0; i < ib_vector_size(vec); i++) {
		pars_user_func_t*	puf = ib_vector_get(vec, i);

		if (strcmp(puf->name, name) == 0) {
			return(puf);
		}
	}

	return(NULL);
}

/****************************************************************//**
Get bound literal with the given name.
@return	bound literal, or NULL if not found */
UNIV_INTERN
pars_bound_lit_t*
pars_info_get_bound_lit(
/*====================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name)	/*!< in: bound literal name to find */
{
	ulint		i;
	ib_vector_t*	vec;

	if (!info || !info->bound_lits) {
		return(NULL);
	}

	vec = info->bound_lits;

	for (i = 0; i < ib_vector_size(vec); i++) {
		pars_bound_lit_t*	pbl = ib_vector_get(vec, i);

		if (strcmp(pbl->name, name) == 0) {
			return(pbl);
		}
	}

	return(NULL);
}

/****************************************************************//**
Get bound id with the given name.
@return	bound id, or NULL if not found */
UNIV_INTERN
pars_bound_id_t*
pars_info_get_bound_id(
/*===================*/
	pars_info_t*		info,	/*!< in: info struct */
	const char*		name)	/*!< in: bound id name to find */
{
	ulint		i;
	ib_vector_t*	vec;

	if (!info || !info->bound_ids) {
		return(NULL);
	}

	vec = info->bound_ids;

	for (i = 0; i < ib_vector_size(vec); i++) {
		pars_bound_id_t*	bid = ib_vector_get(vec, i);

		if (strcmp(bid->name, name) == 0) {
			return(bid);
		}
	}

	return(NULL);
}
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file pars/pars0sym.c
SQL parser symbol table

Created 12/15/1997 Heikki Tuuri
*******************************************************/

#include "pars0sym.h"

#ifdef UNIV_NONINL
#include "pars0sym.ic"
#endif

#include "mem0mem.h"
#include "data0type.h"
#include "data0data.h"
#include "pars0grm.h"
#include "pars0pars.h"
#include "que0que.h"
#include "eval0eval.h"
#include "row0sel.h"

/******************************************************************//**
Creates a symbol table for a single stored procedure or query.
@return	own: symbol table */
UNIV_INTERN
sym_tab_t*
sym_tab_create(
/*===========*/
	mem_heap_t*	heap)	/*!< in: memory heap where to create */
{
	sym_tab_t*	sym_tab;

	sym_tab = mem_heap_alloc(heap, sizeof(sym_tab_t));

	UT_LIST_INIT(sym_tab->sym_list);
	UT_LIST_INIT(sym_tab->func_node_list);

	sym_tab->heap = heap;

	return(sym_tab);
}

/******************************************************************//**
Frees the memory allocated dynamically AFTER parsing phase for variables
etc. in the symbol table. Does not free the mem heap where the table was
originally created. Frees also SQL explicit cursor definitions. */
UNIV_INTERN
void
sym_tab_free_private(
/*=================*/
	sym_tab_t*	sym_tab)	/*!< in, own: symbol table */
{
	sym_node_t*	sym;
	func_node_t*	func;

	sym = UT_LIST_GET_FIRST(sym_tab->sym_list);

	while (sym) {
		eval_node_free_val_buf(sym);

		if (sym->prefetch_buf) {
			sel_col_prefetch_buf_free(sym->prefetch_buf);
		}

		if (sym->cursor_def) {
			que_graph_free_recursive(sym->cursor_def);
		}

		sym = UT_LIST_GET_NEXT(sym_list, sym);
	}

	func = UT_LIST_GET_FIRST(sym_tab->func_node_list);

	while (func) {
		eval_node_free_val_buf(func);

		func = UT_LIST_GET_NEXT(func_node_list, func);
	}
}

/******************************************************************//**
Adds an integer literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_int_lit(
/*================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	ulint		val)		/*!< in: integer value */
{
	sym_node_t*	node;
	byte*		data;

	node = mem_heap_alloc(sym_tab->heap, sizeof(sym_node_t));

	node->common.type = QUE_NODE_SYMBOL;

	node->resolved = TRUE;
	node->token_type = SYM_LIT;

	node->indirection = NULL;

	dtype_set(dfield_get_type(&node->common.val), DATA_INT, 0, 4);

	data = mem_heap_alloc(sym_tab->heap, 4);
	mach_write_to_4(data, val);

	dfield_set_data(&(node->common.val), data, 4);

	node->common.val_buf_size = 0;
	node->prefetch_buf = NULL;
	node->cursor_def = NULL;

	UT_LIST_ADD_LAST(sym_list, sym_tab->sym_list, node);

	node->sym_table = sym_tab;

	return(node);
}

/******************************************************************//**
Adds a string literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_str_lit(
/*================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	byte*		str,		/*!< in: string with no quotes around
					it */
	ulint		len)		/*!< in: string length */
{
	sym_node_t*	node;
	byte*		data;

	node = mem_heap_alloc(sym_tab->heap, sizeof(sym_node_t));

	node->common.type = QUE_NODE_SYMBOL;

	node->resolved = TRUE;
	node->token_type = SYM_LIT;

	node->indirection = NULL;

	dtype_set(dfield_get_type(&node->common.val),
		  DATA_VARCHAR, DATA_ENGLISH, 0);

	if (len) {
		data = mem_heap_alloc(sym_tab->heap, len + 1);
		ut_memcpy(data, str, len);
	} else {
		data = NULL;
	}

	dfield_set_data(&(node->common.val), data, len);

	node->common.val_buf_size = 0;
	node->prefetch_buf = NULL;
	node->cursor_def = NULL;

	UT_LIST_ADD_LAST(sym_list, sym_tab->sym_list, node);

	node->sym_table = sym_tab;

	return(node);
}

/******************************************************************//**
Add a bound literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_bound_lit(
/*==================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	const char*	name,		/*!< in: name of bound literal */
	ulint*		lit_type)	/*!< out: type of literal (PARS_*_LIT) */
{
	sym_node_t*		node;
	pars_bound_lit_t*	blit;
	ulint			len = 0;

	blit = pars_info_get_bound_lit(sym_tab->info, name);
	ut_a(blit);

	node = mem_heap_alloc(sym_tab->heap, sizeof(sym_node_t));

	node->common.type = QUE_NODE_SYMBOL;

	node->resolved = TRUE;
	node->token_type = SYM_LIT;

	node->indirection = NULL;

	switch (blit->type) {
	case DATA_FIXBINARY:
		len = blit->length;
		*lit_type = PARS_FIXBINARY_LIT;
		break;

	case DATA_BLOB:
		*lit_type = PARS_BLOB_LIT;
		break;

	case DATA_VARCHAR:
		*lit_type = PARS_STR_LIT;
		break;

	case DATA_CHAR:
		ut_a(blit->length > 0);

		len = blit->length;
		*lit_type = PARS_STR_LIT;
		break;

	case DATA_INT:
		ut_a(blit->length > 0);
		ut_a(blit->length <= 8);

		len = blit->length;
		*lit_type = PARS_INT_LIT;
		break;

	default:
		ut_error;
	}

	dtype_set(dfield_get_type(&node->common.val),
		  blit->type, blit->prtype, len);

	dfield_set_data(&(node->common.val), blit->address, blit->length);

	node->common.val_buf_size = 0;
	node->prefetch_buf = NULL;
	node->cursor_def = NULL;

	UT_LIST_ADD_LAST(sym_list, sym_tab->sym_list, node);

	node->sym_table = sym_tab;

	return(node);
}

/******************************************************************//**
Adds an SQL null literal to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_null_lit(
/*=================*/
	sym_tab_t*	sym_tab)	/*!< in: symbol table */
{
	sym_node_t*	node;

	node = mem_heap_alloc(sym_tab->heap, sizeof(sym_node_t));

	node->common.type = QUE_NODE_SYMBOL;

	node->resolved = TRUE;
	node->token_type = SYM_LIT;

	node->indirection = NULL;

	dfield_get_type(&node->common.val)->mtype = DATA_ERROR;

	dfield_set_null(&node->common.val);

	node->common.val_buf_size = 0;
	node->prefetch_buf = NULL;
	node->cursor_def = NULL;

	UT_LIST_ADD_LAST(sym_list, sym_tab->sym_list, node);

	node->sym_table = sym_tab;

	return(node);
}

/******************************************************************//**
Adds an identifier to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_id(
/*===========*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	byte*		name,		/*!< in: identifier name */
	ulint		len)		/*!< in: identifier length */
{
	sym_node_t*	node;

	node = mem_heap_alloc(sym_tab->heap, sizeof(sym_node_t));

	node->common.type = QUE_NODE_SYMBOL;

	node->resolved = FALSE;
	node->indirection = NULL;

	node->name = mem_heap_strdupl(sym_tab->heap, (char*) name, len);
	node->name_len = len;

	UT_LIST_ADD_LAST(sym_list, sym_tab->sym_list, node);

	dfield_set_null(&node->common.val);

	node->common.val_buf_size = 0;
	node->prefetch_buf = NULL;
	node->cursor_def = NULL;

	node->sym_table = sym_tab;

	return(node);
}

/******************************************************************//**
Add a bound identifier to a symbol table.
@return	symbol table node */
UNIV_INTERN
sym_node_t*
sym_tab_add_bound_id(
/*=================*/
	sym_tab_t*	sym_tab,	/*!< in: symbol table */
	const char*	name)		/*!< in: name of bound id */
{
	sym_node_t*		node;
	pars_bound_id_t*	bid;

	bid = pars_info_get_bound_id(sym_tab->info, name);
	ut_a(bid);

	node = mem_heap_alloc(sym_tab->heap, sizeof(sym_node_t));

	node->common.type = QUE_NODE_SYMBOL;

	node->resolved = FALSE;
	node->indirection = NULL;

	node->name = mem_heap_strdup(sym_tab->heap, bid->id);
	node->name_len = strlen(node->name);

	UT_LIST_ADD_LAST(sym_list, sym_tab->sym_list, node);

	dfield_set_null(&node->common.val);

	node->common.val_buf_size = 0;
	node->prefetch_buf = NULL;
	node->cursor_def = NULL;

	node->sym_table = sym_tab;

	return(node);
}
/*****************************************************************************

Copyright (c) 1996, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file que/que0que.c
Query graph

Created 5/27/1996 Heikki Tuuri
*******************************************************/

#include "que0que.h"

#ifdef UNIV_NONINL
#include "que0que.ic"
#endif

#include "srv0que.h"
#include "usr0sess.h"
#include "trx0trx.h"
#include "trx0roll.h"
#include "row0undo.h"
#include "row0ins.h"
#include "row0upd.h"
#include "row0sel.h"
#include "row0purge.h"
#include "dict0crea.h"
#include "log0log.h"
#include "eval0proc.h"
#include "eval0eval.h"
#include "pars0types.h"

#define QUE_PARALLELIZE_LIMIT	(64 * 256 * 256 * 256)
#define QUE_ROUND_ROBIN_LIMIT	(64 * 256 * 256 * 256)
#define QUE_MAX_LOOPS_WITHOUT_CHECK	16

#ifdef UNIV_DEBUG
/* If the following flag is set TRUE, the module will print trace info
of SQL execution in the UNIV_SQL_DEBUG version */
UNIV_INTERN ibool	que_trace_on		= FALSE;
#endif /* UNIV_DEBUG */

/* Short introduction to query graphs
   ==================================

A query graph consists of nodes linked to each other in various ways. The
execution starts at que_run_threads() which takes a que_thr_t parameter.
que_thr_t contains two fields that control query graph execution: run_node
and prev_node. run_node is the next node to execute and prev_node is the
last node executed.

Each node has a pointer to a 'next' statement, i.e., its brother, and a
pointer to its parent node. The next pointer is NULL in the last statement
of a block.

Loop nodes contain a link to the first statement of the enclosed statement
list. While the loop runs, que_thr_step() checks if execution to the loop
node came from its parent or from one of the statement nodes in the loop. If
it came from the parent of the loop node it starts executing the first
statement node in the loop. If it came from one of the statement nodes in
the loop, then it checks if the statement node has another statement node
following it, and runs it if so.

To signify loop ending, the loop statements (see e.g. while_step()) set
que_thr_t->run_node to the loop node's parent node. This is noticed on the
next call of que_thr_step() and execution proceeds to the node pointed to by
the loop node's 'next' pointer.

For example, the code:

X := 1;
WHILE X < 5 LOOP
 X := X + 1;
 X := X + 1;
X := 5

will result in the following node hierarchy, with the X-axis indicating
'next' links and the Y-axis indicating parent/child links:

A - W - A
    |
    |
    A - A

A = assign_node_t, W = while_node_t. */

/* How a stored procedure containing COMMIT or ROLLBACK commands
is executed?

The commit or rollback can be seen as a subprocedure call.
The problem is that if there are several query threads
currently running within the transaction, their action could
mess the commit or rollback operation. Or, at the least, the
operation would be difficult to visualize and keep in control.

Therefore the query thread requesting a commit or a rollback
sends to the transaction a signal, which moves the transaction
to TRX_QUE_SIGNALED state. All running query threads of the
transaction will eventually notice that the transaction is now in
this state and voluntarily suspend themselves. Only the last
query thread which suspends itself will trigger handling of
the signal.

When the transaction starts to handle a rollback or commit
signal, it builds a query graph which, when executed, will
roll back or commit the incomplete transaction. The transaction
is moved to the TRX_QUE_ROLLING_BACK or TRX_QUE_COMMITTING state.
If specified, the SQL cursors opened by the transaction are closed.
When the execution of the graph completes, it is like returning
from a subprocedure: the query thread which requested the operation
starts running again. */

/*************************************************************************//**
Reset the variables. */
UNIV_INTERN
void
que_var_init(void)
/*=============*/
{
#ifdef UNIV_DEBUG
	que_trace_on = FALSE;
#endif /* UNIV_DEBUG */
}

/***********************************************************************//**
Adds a query graph to the session's list of graphs. */
UNIV_INTERN
void
que_graph_publish(
/*==============*/
	que_t*	graph,	/*!< in: graph */
	sess_t*	sess)	/*!< in: session */
{
	ut_ad(mutex_own(&kernel_mutex));

	UT_LIST_ADD_LAST(graphs, sess->graphs, graph);
}

/***********************************************************************//**
Creates a query graph fork node.
@return	own: fork node */
UNIV_INTERN
que_fork_t*
que_fork_create(
/*============*/
	que_t*		graph,		/*!< in: graph, if NULL then this
					fork node is assumed to be the
					graph root */
	que_node_t*	parent,		/*!< in: parent node */
	ulint		fork_type,	/*!< in: fork type */
	mem_heap_t*	heap)		/*!< in: memory heap where created */
{
	que_fork_t*	fork;

	ut_ad(heap);

	fork = mem_heap_alloc(heap, sizeof(que_fork_t));

	fork->common.type = QUE_NODE_FORK;
	fork->n_active_thrs = 0;

	fork->state = QUE_FORK_COMMAND_WAIT;

	if (graph != NULL) {
		fork->graph = graph;
	} else {
		fork->graph = fork;
	}

	fork->common.parent = parent;
	fork->fork_type = fork_type;

	fork->caller = NULL;

	UT_LIST_INIT(fork->thrs);

	fork->sym_tab = NULL;
	fork->info = NULL;

	fork->heap = heap;

	return(fork);
}

/***********************************************************************//**
Creates a query graph thread node.
@return	own: query thread node */
UNIV_INTERN
que_thr_t*
que_thr_create(
/*===========*/
	que_fork_t*	parent,	/*!< in: parent node, i.e., a fork node */
	mem_heap_t*	heap)	/*!< in: memory heap where created */
{
	que_thr_t*	thr;

	ut_ad(parent && heap);

	thr = mem_heap_alloc(heap, sizeof(que_thr_t));

	thr->common.type = QUE_NODE_THR;
	thr->common.parent = parent;

	thr->magic_n = QUE_THR_MAGIC_N;

	thr->graph = parent->graph;

	thr->state = QUE_THR_COMMAND_WAIT;

	thr->is_active = FALSE;

	thr->run_node = NULL;
	thr->resource = 0;
	thr->lock_state = QUE_THR_LOCK_NOLOCK;

	UT_LIST_ADD_LAST(thrs, parent->thrs, thr);

	return(thr);
}

/**********************************************************************//**
Moves a suspended query thread to the QUE_THR_RUNNING state and may release
a single worker thread to execute it. This function should be used to end
the wait state of a query thread waiting for a lock or a stored procedure
completion. */
UNIV_INTERN
void
que_thr_end_wait(
/*=============*/
	que_thr_t*	thr,		/*!< in: query thread in the
					QUE_THR_LOCK_WAIT,
					or QUE_THR_PROCEDURE_WAIT, or
					QUE_THR_SIG_REPLY_WAIT state */
	que_thr_t**	next_thr)	/*!< in/out: next query thread to run;
					if the value which is passed in is
					a pointer to a NULL pointer, then the
					calling function can start running
					a new query thread; if NULL is passed
					as the parameter, it is ignored */
{
	ibool	was_active;

	ut_ad(mutex_own(&kernel_mutex));
	ut_ad(thr);
	ut_ad((thr->state == QUE_THR_LOCK_WAIT)
	      || (thr->state == QUE_THR_PROCEDURE_WAIT)
	      || (thr->state == QUE_THR_SIG_REPLY_WAIT));
	ut_ad(thr->run_node);

	thr->prev_node = thr->run_node;

	was_active = thr->is_active;

	que_thr_move_to_run_state(thr);

	if (was_active) {

		return;
	}

	if (next_thr && *next_thr == NULL) {
		*next_thr = thr;
	} else {
		ut_a(0);
		srv_que_task_enqueue_low(thr);
	}
}

/**********************************************************************//**
Same as que_thr_end_wait, but no parameter next_thr available. */
UNIV_INTERN
void
que_thr_end_wait_no_next_thr(
/*=========================*/
	que_thr_t*	thr)	/*!< in: query thread in the QUE_THR_LOCK_WAIT,
				or QUE_THR_PROCEDURE_WAIT, or
				QUE_THR_SIG_REPLY_WAIT state */
{
	ibool	was_active;

	ut_a(thr->state == QUE_THR_LOCK_WAIT);
	ut_ad(mutex_own(&kernel_mutex));
	ut_ad(thr);
	ut_ad((thr->state == QUE_THR_LOCK_WAIT)
	      || (thr->state == QUE_THR_PROCEDURE_WAIT)
	      || (thr->state == QUE_THR_SIG_REPLY_WAIT));

	was_active = thr->is_active;

	que_thr_move_to_run_state(thr);

	if (was_active) {

		return;
	}

	/* We let the OS thread (not just the query thread) to wait
	for the lock to be released: */

	srv_release_user_thread_if_suspended(thr);

	/* srv_que_task_enqueue_low(thr); */
}

/**********************************************************************//**
Inits a query thread for a command. */
UNIV_INLINE
void
que_thr_init_command(
/*=================*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	thr->run_node = thr;
	thr->prev_node = thr->common.parent;

	que_thr_move_to_run_state(thr);
}

/**********************************************************************//**
Starts execution of a command in a query fork. Picks a query thread which
is not in the QUE_THR_RUNNING state and moves it to that state. If none
can be chosen, a situation which may arise in parallelized fetches, NULL
is returned.
@return a query thread of the graph moved to QUE_THR_RUNNING state, or
NULL; the query thread should be executed by que_run_threads by the
caller */
UNIV_INTERN
que_thr_t*
que_fork_start_command(
/*===================*/
	que_fork_t*	fork)	/*!< in: a query fork */
{
	que_thr_t*	thr;
	que_thr_t*	suspended_thr = NULL;
	que_thr_t*	completed_thr = NULL;

	fork->state = QUE_FORK_ACTIVE;

	fork->last_sel_node = NULL;

	suspended_thr = NULL;
	completed_thr = NULL;

	/* Choose the query thread to run: usually there is just one thread,
	but in a parallelized select, which necessarily is non-scrollable,
	there may be several to choose from */

	/* First we try to find a query thread in the QUE_THR_COMMAND_WAIT
	state. Then we try to find a query thread in the QUE_THR_SUSPENDED
	state, finally we try to find a query thread in the QUE_THR_COMPLETED
	state */

	thr = UT_LIST_GET_FIRST(fork->thrs);

	/* We make a single pass over the thr list within which we note which
	threads are ready to run. */
	while (thr) {
		switch (thr->state) {
		case QUE_THR_COMMAND_WAIT:

			/* We have to send the initial message to query thread
			to start it */

			que_thr_init_command(thr);

			return(thr);

		case QUE_THR_SUSPENDED:
			/* In this case the execution of the thread was
			suspended: no initial message is needed because
			execution can continue from where it was left */
			if (!suspended_thr) {
				suspended_thr = thr;
			}

			break;

		case QUE_THR_COMPLETED:
			if (!completed_thr) {
				completed_thr = thr;
			}

			break;

		case QUE_THR_LOCK_WAIT:
			ut_error;

		}

		thr = UT_LIST_GET_NEXT(thrs, thr);
	}

	if (suspended_thr) {

		thr = suspended_thr;
		que_thr_move_to_run_state(thr);

	} else if (completed_thr) {

		thr = completed_thr;
		que_thr_init_command(thr);
	}

	return(thr);
}

/**********************************************************************//**
After signal handling is finished, returns control to a query graph error
handling routine. (Currently, just returns the control to the root of the
graph so that the graph can communicate an error message to the client.) */
UNIV_INTERN
void
que_fork_error_handle(
/*==================*/
	trx_t*	trx __attribute__((unused)),	/*!< in: trx */
	que_t*	fork)	/*!< in: query graph which was run before signal
			handling started, NULL not allowed */
{
	que_thr_t*	thr;

	ut_ad(mutex_own(&kernel_mutex));
	ut_ad(trx->sess->state == SESS_ERROR);
	ut_ad(UT_LIST_GET_LEN(trx->reply_signals) == 0);
	ut_ad(UT_LIST_GET_LEN(trx->wait_thrs) == 0);

	thr = UT_LIST_GET_FIRST(fork->thrs);

	while (thr != NULL) {
		ut_ad(!thr->is_active);
		ut_ad(thr->state != QUE_THR_SIG_REPLY_WAIT);
		ut_ad(thr->state != QUE_THR_LOCK_WAIT);

		thr->run_node = thr;
		thr->prev_node = thr->child;
		thr->state = QUE_THR_COMPLETED;

		thr = UT_LIST_GET_NEXT(thrs, thr);
	}

	thr = UT_LIST_GET_FIRST(fork->thrs);

	que_thr_move_to_run_state(thr);

	ut_a(0);
	srv_que_task_enqueue_low(thr);
}

/****************************************************************//**
Tests if all the query threads in the same fork have a given state.
@return TRUE if all the query threads in the same fork were in the
given state */
UNIV_INLINE
ibool
que_fork_all_thrs_in_state(
/*=======================*/
	que_fork_t*	fork,	/*!< in: query fork */
	ulint		state)	/*!< in: state */
{
	que_thr_t*	thr_node;

	thr_node = UT_LIST_GET_FIRST(fork->thrs);

	while (thr_node != NULL) {
		if (thr_node->state != state) {

			return(FALSE);
		}

		thr_node = UT_LIST_GET_NEXT(thrs, thr_node);
	}

	return(TRUE);
}

/**********************************************************************//**
Calls que_graph_free_recursive for statements in a statement list. */
UNIV_STATIC
void
que_graph_free_stat_list(
/*=====================*/
	que_node_t*	node)	/*!< in: first query graph node in the list */
{
	while (node) {
		que_graph_free_recursive(node);

		node = que_node_get_next(node);
	}
}

/**********************************************************************//**
Frees a query graph, but not the heap where it was created. Does not free
explicit cursor declarations, they are freed in que_graph_free. */
UNIV_INTERN
void
que_graph_free_recursive(
/*=====================*/
	que_node_t*	node)	/*!< in: query graph node */
{
	que_fork_t*	fork;
	que_thr_t*	thr;
	undo_node_t*	undo;
	sel_node_t*	sel;
	ins_node_t*	ins;
	upd_node_t*	upd;
	tab_node_t*	cre_tab;
	ind_node_t*	cre_ind;
	purge_node_t*	purge;

	if (node == NULL) {

		return;
	}

	switch (que_node_get_type(node)) {

	case QUE_NODE_FORK:
		fork = node;

		thr = UT_LIST_GET_FIRST(fork->thrs);

		while (thr) {
			que_graph_free_recursive(thr);

			thr = UT_LIST_GET_NEXT(thrs, thr);
		}

		break;
	case QUE_NODE_THR:

		thr = node;

		if (thr->magic_n != QUE_THR_MAGIC_N) {
			ib_logger(ib_stream,
				"que_thr struct appears corrupt;"
				" magic n %lu\n",
				(unsigned long) thr->magic_n);
			ut_error;
		}

		thr->magic_n = QUE_THR_MAGIC_FREED;

		que_graph_free_recursive(thr->child);

		break;
	case QUE_NODE_UNDO:

		undo = node;

		mem_heap_free(undo->heap);

		break;
	case QUE_NODE_SELECT:

		sel = node;

		sel_node_free_private(sel);

		break;
	case QUE_NODE_INSERT:

		ins = node;

		que_graph_free_recursive(ins->select);

		mem_heap_free(ins->entry_sys_heap);

		break;
	case QUE_NODE_PURGE:
		purge = node;

		mem_heap_free(purge->heap);

		break;

	case QUE_NODE_UPDATE:

		upd = node;

		if (upd->in_client_interface) {

			btr_pcur_free(upd->pcur);
		}

		que_graph_free_recursive(upd->cascade_node);

		if (upd->cascade_heap) {
			mem_heap_free(upd->cascade_heap);
		}

		que_graph_free_recursive(upd->select);

		mem_heap_free(upd->heap);

		break;
	case QUE_NODE_CREATE_TABLE:
		cre_tab = node;

		que_graph_free_recursive(cre_tab->tab_def);
		que_graph_free_recursive(cre_tab->col_def);
		que_graph_free_recursive(cre_tab->commit_node);

		mem_heap_free(cre_tab->heap);

		break;
	case QUE_NODE_CREATE_INDEX:
		cre_ind = node;

		que_graph_free_recursive(cre_ind->ind_def);
		que_graph_free_recursive(cre_ind->field_def);
		que_graph_free_recursive(cre_ind->commit_node);

		mem_heap_free(cre_ind->heap);

		break;
	case QUE_NODE_PROC:
		que_graph_free_stat_list(((proc_node_t*)node)->stat_list);

		break;
	case QUE_NODE_IF:
		que_graph_free_stat_list(((if_node_t*)node)->stat_list);
		que_graph_free_stat_list(((if_node_t*)node)->else_part);
		que_graph_free_stat_list(((if_node_t*)node)->elsif_list);

		break;
	case QUE_NODE_ELSIF:
		que_graph_free_stat_list(((elsif_node_t*)node)->stat_list);

		break;
	case QUE_NODE_WHILE:
		que_graph_free_stat_list(((while_node_t*)node)->stat_list);

		break;
	case QUE_NODE_FOR:
		que_graph_free_stat_list(((for_node_t*)node)->stat_list);

		break;

	case QUE_NODE_ASSIGNMENT:
	case QUE_NODE_EXIT:
	case QUE_NODE_RETURN:
	case QUE_NODE_COMMIT:
	case QUE_NODE_ROLLBACK:
	case QUE_NODE_LOCK:
	case QUE_NODE_FUNC:
	case QUE_NODE_ORDER:
	case QUE_NODE_ROW_PRINTF:
	case QUE_NODE_OPEN:
	case QUE_NODE_FETCH:
		/* No need to do anything */

		break;
	default:
		ib_logger(ib_stream,
			"que_node struct appears corrupt; type %lu\n",
			(unsigned long) que_node_get_type(node));
		ut_error;
	}
}

/**********************************************************************//**
Frees a query graph. */
UNIV_INTERN
void
que_graph_free(
/*===========*/
	que_t*	graph)	/*!< in: query graph; we assume that the memory
			heap where this graph was created is private
			to this graph: if not, then use
			que_graph_free_recursive and free the heap
			afterwards! */
{
	ut_ad(graph);

	if (graph->sym_tab) {
		/* The following call frees dynamic memory allocated
		for variables etc. during execution. Frees also explicit
		cursor definitions. */

		sym_tab_free_private(graph->sym_tab);
	}

	if (graph->info && graph->info->graph_owns_us) {
		pars_info_free(graph->info);
	}

	que_graph_free_recursive(graph);

	mem_heap_free(graph->heap);
}

/****************************************************************//**
Performs an execution step on a thr node.
@return	query thread to run next, or NULL if none */
UNIV_STATIC
que_thr_t*
que_thr_node_step(
/*==============*/
	que_thr_t*	thr)	/*!< in: query thread where run_node must
				be the thread node itself */
{
	ut_ad(thr->run_node == thr);

	if (thr->prev_node == thr->common.parent) {
		/* If control to the node came from above, it is just passed
		on */

		thr->run_node = thr->child;

		return(thr);
	}

	mutex_enter(&kernel_mutex);

	if (que_thr_peek_stop(thr)) {

		mutex_exit(&kernel_mutex);

		return(thr);
	}

	/* Thread execution completed */

	thr->state = QUE_THR_COMPLETED;

	mutex_exit(&kernel_mutex);

	return(NULL);
}

/**********************************************************************//**
Moves a thread from another state to the QUE_THR_RUNNING state. Increments
the n_active_thrs counters of the query graph and transaction if thr was
not active.
***NOTE***: This is the only functions in which such a transition is
allowed to happen! */
UNIV_INTERN
void
que_thr_move_to_run_state(
/*======================*/
	que_thr_t*	thr)	/*!< in: an query thread */
{
	trx_t*	trx;

	ut_ad(thr->state != QUE_THR_RUNNING);

	trx = thr_get_trx(thr);

	if (!thr->is_active) {

		(thr->graph)->n_active_thrs++;

		trx->n_active_thrs++;

		thr->is_active = TRUE;

		ut_ad((thr->graph)->n_active_thrs == 1);
		ut_ad(trx->n_active_thrs == 1);
	}

	thr->state = QUE_THR_RUNNING;
}

/**********************************************************************//**
Decrements the query thread reference counts in the query graph and the
transaction. May start signal handling, e.g., a rollback.
*** NOTE ***:
This and que_thr_stop_client are the only functions where the reference
count can be decremented and this function may only be called from inside
que_run_threads or que_thr_check_if_switch! These restrictions exist to make
the rollback code easier to maintain. */
UNIV_STATIC
void
que_thr_dec_refer_count(
/*====================*/
	que_thr_t*	thr,		/*!< in: query thread */
	que_thr_t**	next_thr)	/*!< in/out: next query thread to run;
					if the value which is passed in is
					a pointer to a NULL pointer, then the
					calling function can start running
					a new query thread */
{
	que_fork_t*	fork;
	trx_t*		trx;
	ulint		fork_type;
	ibool		stopped;

	fork = thr->common.parent;
	trx = thr_get_trx(thr);

	mutex_enter(&kernel_mutex);

	ut_a(thr->is_active);

	if (thr->state == QUE_THR_RUNNING) {

		stopped = que_thr_stop(thr);

		if (!stopped) {
			/* The reason for the thr suspension or wait was
			already canceled before we came here: continue
			running the thread */

			/* ib_logger(ib_stream,
			   	"!!!!!!!! Wait already ended: continue thr\n");
			*/

			if (next_thr && *next_thr == NULL) {
				/* Normally srv_suspend_user_thread resets
				the state to DB_SUCCESS before waiting, but
				in this case we have to do it here,
				otherwise nobody does it. */
				trx->error_state = DB_SUCCESS;

				*next_thr = thr;
			} else {
				ut_error;
				srv_que_task_enqueue_low(thr);
			}

			mutex_exit(&kernel_mutex);

			return;
		}
	}

	ut_ad(fork->n_active_thrs == 1);
	ut_ad(trx->n_active_thrs == 1);

	fork->n_active_thrs--;
	trx->n_active_thrs--;

	thr->is_active = FALSE;

	if (trx->n_active_thrs > 0) {

		mutex_exit(&kernel_mutex);

		return;
	}

	fork_type = fork->fork_type;

	/* Check if all query threads in the same fork are completed */

	if (que_fork_all_thrs_in_state(fork, QUE_THR_COMPLETED)) {

		switch (fork_type) {
		case QUE_FORK_ROLLBACK:
			/* This is really the undo graph used in rollback,
			no roll_node in this graph */

			ut_ad(UT_LIST_GET_LEN(trx->signals) > 0);
			ut_ad(trx->handling_signals == TRUE);

			trx_finish_rollback_off_kernel(fork, trx, next_thr);
			break;

		case QUE_FORK_PURGE:
		case QUE_FORK_RECOVERY:
		case QUE_FORK_USER_INTERFACE:

			/* Do nothing */
			break;

		default:
			ut_error;	/* not used */
		}
	}

	if (UT_LIST_GET_LEN(trx->signals) > 0 && trx->n_active_thrs == 0) {

		/* If the trx is signaled and its query thread count drops to
		zero, then we start processing a signal; from it we may get
		a new query thread to run */

		trx_sig_start_handle(trx, next_thr);
	}

	if (trx->handling_signals && UT_LIST_GET_LEN(trx->signals) == 0) {

		trx_end_signal_handling(trx);
	}

	mutex_exit(&kernel_mutex);
}

/**********************************************************************//**
Stops a query thread if graph or trx is in a state requiring it. The
conditions are tested in the order (1) graph, (2) trx. The kernel mutex has
to be reserved.
@return	TRUE if stopped */
UNIV_INTERN
ibool
que_thr_stop(
/*=========*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	trx_t*	trx;
	que_t*	graph;
	ibool	ret	= TRUE;

	ut_ad(mutex_own(&kernel_mutex));

	graph = thr->graph;
	trx = graph->trx;

	if (graph->state == QUE_FORK_COMMAND_WAIT) {
		thr->state = QUE_THR_SUSPENDED;

	} else if (trx->que_state == TRX_QUE_LOCK_WAIT) {

		UT_LIST_ADD_FIRST(trx_thrs, trx->wait_thrs, thr);
		thr->state = QUE_THR_LOCK_WAIT;

	} else if (trx->error_state != DB_SUCCESS
		   && trx->error_state != DB_LOCK_WAIT) {

		thr->state = QUE_THR_COMPLETED;

	} else if (UT_LIST_GET_LEN(trx->signals) > 0
		   && graph->fork_type != QUE_FORK_ROLLBACK) {

		thr->state = QUE_THR_SUSPENDED;
	} else {
		ut_ad(graph->state == QUE_FORK_ACTIVE);

		ret = FALSE;
	}

	return(ret);
}

/**********************************************************************//**
A patch for a client used to 'stop' a dummy query thread used in client
select, when there is no error or lock wait.

TODO: Currently only called from row0merge, needs to be removed. */
UNIV_INTERN
void
que_thr_stop_for_client_no_error(
/*=============================*/
	que_thr_t*	thr,	/*!< in: query thread */
	trx_t*		trx)	/*!< in: transaction */
{
	ut_ad(thr->state == QUE_THR_RUNNING);
	ut_ad(thr->is_active == TRUE);
	ut_ad(trx->n_active_thrs == 1);
	ut_ad(thr->graph->n_active_thrs == 1);

	if (thr->magic_n != QUE_THR_MAGIC_N) {
		ib_logger(ib_stream,
			"que_thr struct appears corrupt; magic n %lu\n",
			(unsigned long) thr->magic_n);

		ut_error;
	}

	thr->state = QUE_THR_COMPLETED;

	thr->is_active = FALSE;
	(thr->graph)->n_active_thrs--;

	trx->n_active_thrs--;
}

/**********************************************************************//**
Moves a thread from another state to the QUE_THR_RUNNING state. Increments
the n_active_thrs counters of the query graph and transaction if thr was
not active. */
UNIV_INTERN
void
que_thr_move_to_run_state_for_client(
/*=================================*/
	que_thr_t*	thr,	/*!< in: an query thread */
	trx_t*		trx)	/*!< in: transaction */
{
	if (thr->magic_n != QUE_THR_MAGIC_N) {
		ib_logger(ib_stream,
			"que_thr struct appears corrupt; magic n %lu\n",
			(unsigned long) thr->magic_n);

		ut_error;
	} else if (!thr->is_active) {

		thr->graph->n_active_thrs++;

		trx->n_active_thrs++;

		thr->is_active = TRUE;
	}

	thr->state = QUE_THR_RUNNING;
}

/**********************************************************************//**
The query thread is stopped and made inactive, except in the case where
it was put to the lock wait state in lock0lock.c, but the lock has already
been granted or the transaction chosen as a victim in deadlock resolution. */
UNIV_INTERN
void
que_thr_stop_client(
/*================*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	trx_t*	trx;

	trx = thr_get_trx(thr);

	mutex_enter(&kernel_mutex);

	if (thr->state == QUE_THR_RUNNING) {

		if (trx->error_state != DB_SUCCESS
		    && trx->error_state != DB_LOCK_WAIT) {

			thr->state = QUE_THR_COMPLETED;
		} else {
			/* It must have been a lock wait but the lock was
			already released, or this transaction was chosen
			as a victim in selective deadlock resolution */

			mutex_exit(&kernel_mutex);

			return;
		}
	}

	ut_ad(thr->is_active == TRUE);
	ut_ad(trx->n_active_thrs == 1);
	ut_ad(thr->graph->n_active_thrs == 1);

	thr->is_active = FALSE;
	(thr->graph)->n_active_thrs--;

	trx->n_active_thrs--;

	mutex_exit(&kernel_mutex);
}

/****************************************************************//**
Get the first containing loop node (e.g. while_node_t or for_node_t) for the
given node, or NULL if the node is not within a loop.
@return	containing loop node, or NULL. */
UNIV_INTERN
que_node_t*
que_node_get_containing_loop_node(
/*==============================*/
	que_node_t*	node)	/*!< in: node */
{
	ut_ad(node);

	for (;;) {
		ulint	type;

		node = que_node_get_parent(node);

		if (!node) {
			break;
		}

		type = que_node_get_type(node);

		if ((type == QUE_NODE_FOR) || (type == QUE_NODE_WHILE)) {
			break;
		}
	}

	return(node);
}

/**********************************************************************//**
Prints info of an SQL query graph node. */
UNIV_INTERN
void
que_node_print_info(
/*================*/
	que_node_t*	node)	/*!< in: query graph node */
{
	ulint		type;
	const char*	str;

	type = que_node_get_type(node);

	if (type == QUE_NODE_SELECT) {
		str = "SELECT";
	} else if (type == QUE_NODE_INSERT) {
		str = "INSERT";
	} else if (type == QUE_NODE_UPDATE) {
		str = "UPDATE";
	} else if (type == QUE_NODE_WHILE) {
		str = "WHILE";
	} else if (type == QUE_NODE_ASSIGNMENT) {
		str = "ASSIGNMENT";
	} else if (type == QUE_NODE_IF) {
		str = "IF";
	} else if (type == QUE_NODE_FETCH) {
		str = "FETCH";
	} else if (type == QUE_NODE_OPEN) {
		str = "OPEN";
	} else if (type == QUE_NODE_PROC) {
		str = "STORED PROCEDURE";
	} else if (type == QUE_NODE_FUNC) {
		str = "FUNCTION";
	} else if (type == QUE_NODE_LOCK) {
		str = "LOCK";
	} else if (type == QUE_NODE_THR) {
		str = "QUERY THREAD";
	} else if (type == QUE_NODE_COMMIT) {
		str = "COMMIT";
	} else if (type == QUE_NODE_UNDO) {
		str = "UNDO ROW";
	} else if (type == QUE_NODE_PURGE) {
		str = "PURGE ROW";
	} else if (type == QUE_NODE_ROLLBACK) {
		str = "ROLLBACK";
	} else if (type == QUE_NODE_CREATE_TABLE) {
		str = "CREATE TABLE";
	} else if (type == QUE_NODE_CREATE_INDEX) {
		str = "CREATE INDEX";
	} else if (type == QUE_NODE_FOR) {
		str = "FOR LOOP";
	} else if (type == QUE_NODE_RETURN) {
		str = "RETURN";
	} else if (type == QUE_NODE_EXIT) {
		str = "EXIT";
	} else {
		str = "UNKNOWN NODE TYPE";
	}

	ib_logger(ib_stream, "Node type %lu: %s, address %p\n",
		(ulong) type, str, (void*) node);
}

/**********************************************************************//**
Performs an execution step on a query thread.
@return query thread to run next: it may differ from the input
parameter if, e.g., a subprocedure call is made */
UNIV_INLINE
que_thr_t*
que_thr_step(
/*=========*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	que_node_t*	node;
	que_thr_t*	old_thr;
	trx_t*		trx;
	ulint		type;

	trx = thr_get_trx(thr);

	ut_ad(thr->state == QUE_THR_RUNNING);
	ut_a(trx->error_state == DB_SUCCESS);

	thr->resource++;

	node = thr->run_node;
	type = que_node_get_type(node);

	old_thr = thr;

#ifdef UNIV_DEBUG
	if (que_trace_on) {
		ib_logger(ib_stream, "To execute: ");
		que_node_print_info(node);
	}
#endif
	if (type & QUE_NODE_CONTROL_STAT) {
		if ((thr->prev_node != que_node_get_parent(node))
		    && que_node_get_next(thr->prev_node)) {

			/* The control statements, like WHILE, always pass the
			control to the next child statement if there is any
			child left */

			thr->run_node = que_node_get_next(thr->prev_node);

		} else if (type == QUE_NODE_IF) {
			if_step(thr);
		} else if (type == QUE_NODE_FOR) {
			for_step(thr);
		} else if (type == QUE_NODE_PROC) {

			/* We can access trx->undo_no without reserving
			trx->undo_mutex, because there cannot be active query
			threads doing updating or inserting at the moment! */

			if (thr->prev_node == que_node_get_parent(node)) {
				trx->last_sql_stat_start.least_undo_no
					= trx->undo_no;
			}

			proc_step(thr);
		} else if (type == QUE_NODE_WHILE) {
			while_step(thr);
		} else {
			ut_error;
		}
	} else if (type == QUE_NODE_ASSIGNMENT) {
		assign_step(thr);
	} else if (type == QUE_NODE_SELECT) {
		thr = row_sel_step(thr);
	} else if (type == QUE_NODE_INSERT) {
		thr = row_ins_step(thr);
	} else if (type == QUE_NODE_UPDATE) {
		thr = row_upd_step(thr);
	} else if (type == QUE_NODE_FETCH) {
		thr = fetch_step(thr);
	} else if (type == QUE_NODE_OPEN) {
		thr = open_step(thr);
	} else if (type == QUE_NODE_FUNC) {
		proc_eval_step(thr);

	} else if (type == QUE_NODE_LOCK) {

		ut_error;
		/*
		thr = que_lock_step(thr);
		*/
	} else if (type == QUE_NODE_THR) {
		thr = que_thr_node_step(thr);
	} else if (type == QUE_NODE_COMMIT) {
		thr = trx_commit_step(thr);
	} else if (type == QUE_NODE_UNDO) {
		thr = row_undo_step(thr);
	} else if (type == QUE_NODE_PURGE) {
		thr = row_purge_step(thr);
	} else if (type == QUE_NODE_RETURN) {
		thr = return_step(thr);
	} else if (type == QUE_NODE_EXIT) {
		thr = exit_step(thr);
	} else if (type == QUE_NODE_ROLLBACK) {
		thr = trx_rollback_step(thr);
	} else if (type == QUE_NODE_CREATE_TABLE) {
		thr = dict_create_table_step(thr);
	} else if (type == QUE_NODE_CREATE_INDEX) {
		thr = dict_create_index_step(thr);
	} else if (type == QUE_NODE_ROW_PRINTF) {
		thr = row_printf_step(thr);
	} else {
		ut_error;
	}

	if (type == QUE_NODE_EXIT) {
		old_thr->prev_node = que_node_get_containing_loop_node(node);
	} else {
		old_thr->prev_node = node;
	}

	if (thr) {
		ut_a(thr_get_trx(thr)->error_state == DB_SUCCESS);
	}

	return(thr);
}

/**********************************************************************//**
Run a query thread until it finishes or encounters e.g. a lock wait. */
UNIV_STATIC
void
que_run_threads_low(
/*================*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	que_thr_t*	next_thr;
	ulint		cumul_resource;
	ulint		loop_count;

	ut_ad(thr->state == QUE_THR_RUNNING);
	ut_a(thr_get_trx(thr)->error_state == DB_SUCCESS);
	ut_ad(!mutex_own(&kernel_mutex));

	/* cumul_resource counts how much resources the OS thread (NOT the
	query thread) has spent in this function */

	loop_count = QUE_MAX_LOOPS_WITHOUT_CHECK;
	cumul_resource = 0;
loop:
	/* Check that there is enough space in the log to accommodate
	possible log entries by this query step; if the operation can touch
	more than about 4 pages, checks must be made also within the query
	step! */

	log_free_check();

	/* Perform the actual query step: note that the query thread
	may change if, e.g., a subprocedure call is made */

	/*-------------------------*/
	next_thr = que_thr_step(thr);
	/*-------------------------*/

	ut_a(!next_thr || (thr_get_trx(next_thr)->error_state == DB_SUCCESS));

	loop_count++;

	if (next_thr != thr) {
		ut_a(next_thr == NULL);

		/* This can change next_thr to a non-NULL value if there was
		a lock wait that already completed. */
		que_thr_dec_refer_count(thr, &next_thr);

		if (next_thr == NULL) {

			return;
		}

		loop_count = QUE_MAX_LOOPS_WITHOUT_CHECK;

		thr = next_thr;
	}

	goto loop;
}

/**********************************************************************//**
Run a query thread. Handles lock waits. */
UNIV_INTERN
void
que_run_threads(
/*============*/
	que_thr_t*	thr)	/*!< in: query thread */
{
loop:
	ut_a(thr_get_trx(thr)->error_state == DB_SUCCESS);
	que_run_threads_low(thr);

	mutex_enter(&kernel_mutex);

	switch (thr->state) {

	case QUE_THR_RUNNING:
		/* There probably was a lock wait, but it already ended
		before we came here: continue running thr */

		mutex_exit(&kernel_mutex);

		goto loop;

	case QUE_THR_LOCK_WAIT:
		mutex_exit(&kernel_mutex);

		/* The ..._user_... function works also for InnoDB's
		internal threads. Let us wait that the lock wait ends. */

		srv_suspend_user_thread(thr);

		if (thr_get_trx(thr)->error_state != DB_SUCCESS) {
			/* thr was chosen as a deadlock victim or there was
			a lock wait timeout */

			que_thr_dec_refer_count(thr, NULL);

			return;
		}

		goto loop;

	case QUE_THR_COMPLETED:
	case QUE_THR_COMMAND_WAIT:
		/* Do nothing */
		break;

	default:
		ut_error;
	}

	mutex_exit(&kernel_mutex);
}

/*********************************************************************//**
Evaluate the given SQL.
@return	error code or DB_SUCCESS */
UNIV_INTERN
ulint
que_eval_sql(
/*=========*/
	pars_info_t*	info,	/*!< in: info struct, or NULL */
	const char*	sql,	/*!< in: SQL string */
	ibool		reserve_dict_mutex,
				/*!< in: if TRUE, acquire/release
				dict_sys->mutex around call to pars_sql. */
	trx_t*		trx)	/*!< in: trx */
{
	que_thr_t*	thr;
	que_t*		graph;

	ut_a(trx->error_state == DB_SUCCESS);

	if (reserve_dict_mutex) {
		mutex_enter(&dict_sys->mutex);
	}

	graph = pars_sql(info, sql);

	if (reserve_dict_mutex) {
		mutex_exit(&dict_sys->mutex);
	}

	ut_a(graph);

	graph->trx = trx;
	trx->graph = NULL;

	graph->fork_type = QUE_FORK_USER_INTERFACE;

	ut_a(thr = que_fork_start_command(graph));

	que_run_threads(thr);

	que_graph_free(graph);

	return(trx->error_state);
}
/*****************************************************************************

Copyright (c) 1997, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file eval/eval0eval.c
SQL evaluator: evaluates simple data structures, like expressions, in
a query graph

Created 12/29/1997 Heikki Tuuri
*******************************************************/

#include "eval0eval.h"

#ifdef UNIV_NONINL
#include "eval0eval.ic"
#endif

#include "data0data.h"
#include "row0sel.h"

/** The RND function seed */
UNIV_STATIC ulint	eval_rnd	= 128367121;

/** Dummy adress used when we should allocate a buffer of size 0 in
eval_node_alloc_val_buf */

UNIV_STATIC byte	eval_dummy;

/*****************************************************************//**
Allocate a buffer from global dynamic memory for a value of a que_node.
NOTE that this memory must be explicitly freed when the query graph is
freed. If the node already has an allocated buffer, that buffer is freed
here. NOTE that this is the only function where dynamic memory should be
allocated for a query node val field.
@return	pointer to allocated buffer */
UNIV_INTERN
byte*
eval_node_alloc_val_buf(
/*====================*/
	que_node_t*	node,	/*!< in: query graph node; sets the val field
				data field to point to the new buffer, and
				len field equal to size */
	ulint		size)	/*!< in: buffer size */
{
	dfield_t*	dfield;
	byte*		data;

	ut_ad(que_node_get_type(node) == QUE_NODE_SYMBOL
	      || que_node_get_type(node) == QUE_NODE_FUNC);

	dfield = que_node_get_val(node);

	data = dfield_get_data(dfield);

	if (data && data != &eval_dummy) {
		mem_free(data);
	}

	if (size == 0) {
		data = &eval_dummy;
	} else {
		data = mem_alloc(size);
	}

	que_node_set_val_buf_size(node, size);

	dfield_set_data(dfield, data, size);

	return(data);
}

/*****************************************************************//**
Free the buffer from global dynamic memory for a value of a que_node,
if it has been allocated in the above function. The freeing for pushed
column values is done in sel_col_prefetch_buf_free. */
UNIV_INTERN
void
eval_node_free_val_buf(
/*===================*/
	que_node_t*	node)	/*!< in: query graph node */
{
	dfield_t*	dfield;
	byte*		data;

	ut_ad(que_node_get_type(node) == QUE_NODE_SYMBOL
	      || que_node_get_type(node) == QUE_NODE_FUNC);

	dfield = que_node_get_val(node);

	data = dfield_get_data(dfield);

	if (que_node_get_val_buf_size(node) > 0) {
		ut_a(data);

		mem_free(data);
	}
}

/*****************************************************************//**
Evaluates a comparison node.
@return	the result of the comparison */
UNIV_INTERN
ibool
eval_cmp(
/*=====*/
	func_node_t*	cmp_node)	/*!< in: comparison node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	int		res;
	ibool		val;
	int		func;

	ut_ad(que_node_get_type(cmp_node) == QUE_NODE_FUNC);

	arg1 = cmp_node->args;
	arg2 = que_node_get_next(arg1);

	res = cmp_dfield_dfield(
		NULL, que_node_get_val(arg1), que_node_get_val(arg2));

	val = TRUE;

	func = cmp_node->func;

	if (func == '=') {
		if (res != 0) {
			val = FALSE;
		}
	} else if (func == '<') {
		if (res != -1) {
			val = FALSE;
		}
	} else if (func == PARS_LE_TOKEN) {
		if (res == 1) {
			val = FALSE;
		}
	} else if (func == PARS_NE_TOKEN) {
		if (res == 0) {
			val = FALSE;
		}
	} else if (func == PARS_GE_TOKEN) {
		if (res == -1) {
			val = FALSE;
		}
	} else {
		ut_ad(func == '>');

		if (res != 1) {
			val = FALSE;
		}
	}

	eval_node_set_ibool_val(cmp_node, val);

	return(val);
}

/*****************************************************************//**
Evaluates a logical operation node. */
UNIV_INLINE
void
eval_logical(
/*=========*/
	func_node_t*	logical_node)	/*!< in: logical operation node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	ibool		val1;
	ibool		val2 = 0; /* remove warning */
	ibool		val = 0;  /* remove warning */
	int		func;

	ut_ad(que_node_get_type(logical_node) == QUE_NODE_FUNC);

	arg1 = logical_node->args;
	arg2 = que_node_get_next(arg1); /* arg2 is NULL if func is 'NOT' */

	val1 = eval_node_get_ibool_val(arg1);

	if (arg2) {
		val2 = eval_node_get_ibool_val(arg2);
	}

	func = logical_node->func;

	if (func == PARS_AND_TOKEN) {
		val = val1 & val2;
	} else if (func == PARS_OR_TOKEN) {
		val = val1 | val2;
	} else if (func == PARS_NOT_TOKEN) {
		val = TRUE - val1;
	} else {
		ut_error;
	}

	eval_node_set_ibool_val(logical_node, val);
}

/*****************************************************************//**
Evaluates an arithmetic operation node. */
UNIV_INLINE
void
eval_arith(
/*=======*/
	func_node_t*	arith_node)	/*!< in: arithmetic operation node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	lint		val1;
	lint		val2 = 0; /* remove warning */
	lint		val;
	int		func;

	ut_ad(que_node_get_type(arith_node) == QUE_NODE_FUNC);

	arg1 = arith_node->args;
	arg2 = que_node_get_next(arg1); /* arg2 is NULL if func is unary '-' */

	val1 = eval_node_get_int_val(arg1);

	if (arg2) {
		val2 = eval_node_get_int_val(arg2);
	}

	func = arith_node->func;

	if (func == '+') {
		val = val1 + val2;
	} else if ((func == '-') && arg2) {
		val = val1 - val2;
	} else if (func == '-') {
		val = -val1;
	} else if (func == '*') {
		val = val1 * val2;
	} else {
		ut_ad(func == '/');
		val = val1 / val2;
	}

	eval_node_set_int_val(arith_node, val);
}

/*****************************************************************//**
Evaluates an aggregate operation node. */
UNIV_INLINE
void
eval_aggregate(
/*===========*/
	func_node_t*	node)	/*!< in: aggregate operation node */
{
	que_node_t*	arg;
	lint		val;
	lint		arg_val;
	int		func;

	ut_ad(que_node_get_type(node) == QUE_NODE_FUNC);

	val = eval_node_get_int_val(node);

	func = node->func;

	if (func == PARS_COUNT_TOKEN) {

		val = val + 1;
	} else {
		ut_ad(func == PARS_SUM_TOKEN);

		arg = node->args;
		arg_val = eval_node_get_int_val(arg);

		val = val + arg_val;
	}

	eval_node_set_int_val(node, val);
}

/*****************************************************************//**
Evaluates a predefined function node where the function is not relevant
in benchmarks. */
UNIV_STATIC
void
eval_predefined_2(
/*==============*/
	func_node_t*	func_node)	/*!< in: predefined function node */
{
	que_node_t*	arg;
	que_node_t*	arg1;
	que_node_t*	arg2 = 0; /* remove warning (??? bug ???) */
	lint		int_val;
	byte*		data;
	ulint		len1;
	ulint		len2;
	int		func;
	ulint		i;

	ut_ad(que_node_get_type(func_node) == QUE_NODE_FUNC);

	arg1 = func_node->args;

	if (arg1) {
		arg2 = que_node_get_next(arg1);
	}

	func = func_node->func;

	if (func == PARS_PRINTF_TOKEN) {

		arg = arg1;

		while (arg) {
			dfield_print(que_node_get_val(arg));

			arg = que_node_get_next(arg);
		}

		ib_logger(ib_stream, "\n");

	} else if (func == PARS_ASSERT_TOKEN) {

		if (!eval_node_get_ibool_val(arg1)) {
			ib_logger(ib_stream,
				"SQL assertion fails in a stored procedure!\n");
		}

		ut_a(eval_node_get_ibool_val(arg1));

		/* This function, or more precisely, a debug procedure,
		returns no value */

	} else if (func == PARS_RND_TOKEN) {

		len1 = (ulint)eval_node_get_int_val(arg1);
		len2 = (ulint)eval_node_get_int_val(arg2);

		ut_ad(len2 >= len1);

		if (len2 > len1) {
			int_val = (lint) (len1
					  + (eval_rnd % (len2 - len1 + 1)));
		} else {
			int_val = (lint) len1;
		}

		eval_rnd = ut_rnd_gen_next_ulint(eval_rnd);

		eval_node_set_int_val(func_node, int_val);

	} else if (func == PARS_RND_STR_TOKEN) {

		len1 = (ulint)eval_node_get_int_val(arg1);

		data = eval_node_ensure_val_buf(func_node, len1);

		for (i = 0; i < len1; i++) {
			data[i] = (byte)(97 + (eval_rnd % 3));

			eval_rnd = ut_rnd_gen_next_ulint(eval_rnd);
		}
	} else {
		ut_error;
	}
}

/*****************************************************************//**
Evaluates a notfound-function node. */
UNIV_INLINE
void
eval_notfound(
/*==========*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	sym_node_t*	cursor;
	sel_node_t*	sel_node;
	ibool		ibool_val;

	arg1 = func_node->args;
	arg2 = que_node_get_next(arg1);

	ut_ad(func_node->func == PARS_NOTFOUND_TOKEN);

	cursor = arg1;

	ut_ad(que_node_get_type(cursor) == QUE_NODE_SYMBOL);

	if (cursor->token_type == SYM_LIT) {

		ut_ad(ut_memcmp(dfield_get_data(que_node_get_val(cursor)),
				"SQL", 3) == 0);

		sel_node = cursor->sym_table->query_graph->last_sel_node;
	} else {
		sel_node = cursor->alias->cursor_def;
	}

	if (sel_node->state == SEL_NODE_NO_MORE_ROWS) {
		ibool_val = TRUE;
	} else {
		ibool_val = FALSE;
	}

	eval_node_set_ibool_val(func_node, ibool_val);
}

/*****************************************************************//**
Evaluates a substr-function node. */
UNIV_INLINE
void
eval_substr(
/*========*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	que_node_t*	arg3;
	dfield_t*	dfield;
	byte*		str1;
	ulint		len1;
	ulint		len2;

	arg1 = func_node->args;
	arg2 = que_node_get_next(arg1);

	ut_ad(func_node->func == PARS_SUBSTR_TOKEN);

	arg3 = que_node_get_next(arg2);

	str1 = dfield_get_data(que_node_get_val(arg1));

	len1 = (ulint)eval_node_get_int_val(arg2);
	len2 = (ulint)eval_node_get_int_val(arg3);

	dfield = que_node_get_val(func_node);

	dfield_set_data(dfield, str1 + len1, len2);
}

/*****************************************************************//**
Evaluates a replstr-procedure node. */
UNIV_STATIC
void
eval_replstr(
/*=========*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	que_node_t*	arg3;
	que_node_t*	arg4;
	byte*		str1;
	byte*		str2;
	ulint		len1;
	ulint		len2;

	arg1 = func_node->args;
	arg2 = que_node_get_next(arg1);

	ut_ad(que_node_get_type(arg1) == QUE_NODE_SYMBOL);

	arg3 = que_node_get_next(arg2);
	arg4 = que_node_get_next(arg3);

	str1 = dfield_get_data(que_node_get_val(arg1));
	str2 = dfield_get_data(que_node_get_val(arg2));

	len1 = (ulint)eval_node_get_int_val(arg3);
	len2 = (ulint)eval_node_get_int_val(arg4);

	if ((dfield_get_len(que_node_get_val(arg1)) < len1 + len2)
	    || (dfield_get_len(que_node_get_val(arg2)) < len2)) {

		ut_error;
	}

	ut_memcpy(str1 + len1, str2, len2);
}

/*****************************************************************//**
Evaluates an instr-function node. */
UNIV_STATIC
void
eval_instr(
/*=======*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	dfield_t*	dfield1;
	dfield_t*	dfield2;
	lint		int_val;
	byte*		str1;
	byte*		str2;
	byte		match_char;
	ulint		len1;
	ulint		len2;
	ulint		i;
	ulint		j;

	arg1 = func_node->args;
	arg2 = que_node_get_next(arg1);

	dfield1 = que_node_get_val(arg1);
	dfield2 = que_node_get_val(arg2);

	str1 = dfield_get_data(dfield1);
	str2 = dfield_get_data(dfield2);

	len1 = dfield_get_len(dfield1);
	len2 = dfield_get_len(dfield2);

	if (len2 == 0) {
		ut_error;
	}

	match_char = str2[0];

	for (i = 0; i < len1; i++) {
		/* In this outer loop, the number of matched characters is 0 */

		if (str1[i] == match_char) {

			if (i + len2 > len1) {

				break;
			}

			for (j = 1;; j++) {
				/* We have already matched j characters */

				if (j == len2) {
					int_val = i + 1;

					goto match_found;
				}

				if (str1[i + j] != str2[j]) {

					break;
				}
			}
		}
	}

	int_val = 0;

match_found:
	eval_node_set_int_val(func_node, int_val);
}

/*****************************************************************//**
Evaluates a predefined function node. */
UNIV_INLINE
void
eval_binary_to_number(
/*==================*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	dfield_t*	dfield;
	byte*		str1;
	byte*		str2;
	ulint		len1;
	ulint		int_val;

	arg1 = func_node->args;

	dfield = que_node_get_val(arg1);

	str1 = dfield_get_data(dfield);
	len1 = dfield_get_len(dfield);

	if (len1 > 4) {
		ut_error;
	}

	if (len1 == 4) {
		str2 = str1;
	} else {
		int_val = 0;
		str2 = (byte*)&int_val;

		ut_memcpy(str2 + (4 - len1), str1, len1);
	}

	eval_node_copy_and_alloc_val(func_node, str2, 4);
}

/*****************************************************************//**
Evaluates a predefined function node. */
UNIV_STATIC
void
eval_concat(
/*========*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg;
	dfield_t*	dfield;
	byte*		data;
	ulint		len;
	ulint		len1;

	arg = func_node->args;
	len = 0;

	while (arg) {
		len1 = dfield_get_len(que_node_get_val(arg));

		len += len1;

		arg = que_node_get_next(arg);
	}

	data = eval_node_ensure_val_buf(func_node, len);

	arg = func_node->args;
	len = 0;

	while (arg) {
		dfield = que_node_get_val(arg);
		len1 = dfield_get_len(dfield);

		ut_memcpy(data + len, dfield_get_data(dfield), len1);

		len += len1;

		arg = que_node_get_next(arg);
	}
}

/*****************************************************************//**
Evaluates a predefined function node. If the first argument is an integer,
this function looks at the second argument which is the integer length in
bytes, and converts the integer to a VARCHAR.
If the first argument is of some other type, this function converts it to
BINARY. */
UNIV_INLINE
void
eval_to_binary(
/*===========*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	que_node_t*	arg2;
	dfield_t*	dfield;
	byte*		str1;
	ulint		len;
	ulint		len1;

	arg1 = func_node->args;

	str1 = dfield_get_data(que_node_get_val(arg1));

	if (dtype_get_mtype(que_node_get_data_type(arg1)) != DATA_INT) {

		len = dfield_get_len(que_node_get_val(arg1));

		dfield = que_node_get_val(func_node);

		dfield_set_data(dfield, str1, len);

		return;
	}

	arg2 = que_node_get_next(arg1);

	len1 = (ulint)eval_node_get_int_val(arg2);

	if (len1 > 4) {

		ut_error;
	}

	dfield = que_node_get_val(func_node);

	dfield_set_data(dfield, str1 + (4 - len1), len1);
}

/*****************************************************************//**
Evaluates a predefined function node. */
UNIV_INLINE
void
eval_predefined(
/*============*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg1;
	lint		int_val;
	byte*		data;
	int		func;

	func = func_node->func;

	arg1 = func_node->args;

	if (func == PARS_LENGTH_TOKEN) {

		int_val = (lint)dfield_get_len(que_node_get_val(arg1));

	} else if (func == PARS_TO_CHAR_TOKEN) {

		/* Convert number to character string as a
		signed decimal integer. */

		ulint	uint_val;
		int	int_len;

		int_val = eval_node_get_int_val(arg1);

		/* Determine the length of the string. */

		if (int_val == 0) {
			int_len = 1; /* the number 0 occupies 1 byte */
		} else {
			int_len = 0;
			if (int_val < 0) {
				uint_val = ((ulint) -int_val - 1) + 1;
				int_len++; /* reserve space for minus sign */
			} else {
				uint_val = (ulint) int_val;
			}
			for (; uint_val > 0; int_len++) {
				uint_val /= 10;
			}
		}

		/* allocate the string */
		data = eval_node_ensure_val_buf(func_node, int_len + 1);

		/* add terminating NUL character */
		data[int_len] = 0;

		/* convert the number */

		if (int_val == 0) {
			data[0] = '0';
		} else {
			int tmp;
			if (int_val < 0) {
				data[0] = '-'; /* preceding minus sign */
				uint_val = ((ulint) -int_val - 1) + 1;
			} else {
				uint_val = (ulint) int_val;
			}
			for (tmp = int_len; uint_val > 0; uint_val /= 10) {
				data[--tmp] = (byte)
					('0' + (byte)(uint_val % 10));
			}
		}

		dfield_set_len(que_node_get_val(func_node), int_len);

		return;

	} else if (func == PARS_TO_NUMBER_TOKEN) {

		int_val = atoi((char*)
			       dfield_get_data(que_node_get_val(arg1)));

	} else if (func == PARS_SYSDATE_TOKEN) {
		int_val = (lint)ut_time();
	} else {
		eval_predefined_2(func_node);

		return;
	}

	eval_node_set_int_val(func_node, int_val);
}

/*****************************************************************//**
Evaluates a function node. */
UNIV_INTERN
void
eval_func(
/*======*/
	func_node_t*	func_node)	/*!< in: function node */
{
	que_node_t*	arg;
	ulint		class;
	ulint		func;

	ut_ad(que_node_get_type(func_node) == QUE_NODE_FUNC);

	class = func_node->class;
	func = func_node->func;

	arg = func_node->args;

	/* Evaluate first the argument list */
	while (arg) {
		eval_exp(arg);

		/* The functions are not defined for SQL null argument
		values, except for eval_cmp and notfound */

		if (dfield_is_null(que_node_get_val(arg))
		    && (class != PARS_FUNC_CMP)
		    && (func != PARS_NOTFOUND_TOKEN)
		    && (func != PARS_PRINTF_TOKEN)) {
			ut_error;
		}

		arg = que_node_get_next(arg);
	}

	if (class == PARS_FUNC_CMP) {
		eval_cmp(func_node);
	} else if (class == PARS_FUNC_ARITH) {
		eval_arith(func_node);
	} else if (class == PARS_FUNC_AGGREGATE) {
		eval_aggregate(func_node);
	} else if (class == PARS_FUNC_PREDEFINED) {

		if (func == PARS_NOTFOUND_TOKEN) {
			eval_notfound(func_node);
		} else if (func == PARS_SUBSTR_TOKEN) {
			eval_substr(func_node);
		} else if (func == PARS_REPLSTR_TOKEN) {
			eval_replstr(func_node);
		} else if (func == PARS_INSTR_TOKEN) {
			eval_instr(func_node);
		} else if (func == PARS_BINARY_TO_NUMBER_TOKEN) {
			eval_binary_to_number(func_node);
		} else if (func == PARS_CONCAT_TOKEN) {
			eval_concat(func_node);
		} else if (func == PARS_TO_BINARY_TOKEN) {
			eval_to_binary(func_node);
		} else {
			eval_predefined(func_node);
		}
	} else {
		ut_ad(class == PARS_FUNC_LOGICAL);

		eval_logical(func_node);
	}
}
/*****************************************************************************

Copyright (c) 1998, 2009, Innobase Oy. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA 02111-1307 USA

*****************************************************************************/

/**************************************************//**
@file eval/eval0proc.c
Executes SQL stored procedures and their control structures

Created 1/20/1998 Heikki Tuuri
*******************************************************/

#include "eval0proc.h"

#ifdef UNIV_NONINL
#include "eval0proc.ic"
#endif

/**********************************************************************//**
Performs an execution step of an if-statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
if_step(
/*====*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	if_node_t*	node;
	elsif_node_t*	elsif_node;

	ut_ad(thr);

	node = thr->run_node;
	ut_ad(que_node_get_type(node) == QUE_NODE_IF);

	if (thr->prev_node == que_node_get_parent(node)) {

		/* Evaluate the condition */

		eval_exp(node->cond);

		if (eval_node_get_ibool_val(node->cond)) {

			/* The condition evaluated to TRUE: start execution
			from the first statement in the statement list */

			thr->run_node = node->stat_list;

		} else if (node->else_part) {
			thr->run_node = node->else_part;

		} else if (node->elsif_list) {
			elsif_node = node->elsif_list;

			for (;;) {
				eval_exp(elsif_node->cond);

				if (eval_node_get_ibool_val(
					    elsif_node->cond)) {

					/* The condition evaluated to TRUE:
					start execution from the first
					statement in the statement list */

					thr->run_node = elsif_node->stat_list;

					break;
				}

				elsif_node = que_node_get_next(elsif_node);

				if (elsif_node == NULL) {
					thr->run_node = NULL;

					break;
				}
			}
		} else {
			thr->run_node = NULL;
		}
	} else {
		/* Move to the next statement */
		ut_ad(que_node_get_next(thr->prev_node) == NULL);

		thr->run_node = NULL;
	}

	if (thr->run_node == NULL) {
		thr->run_node = que_node_get_parent(node);
	}

	return(thr);
}

/**********************************************************************//**
Performs an execution step of a while-statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
while_step(
/*=======*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	while_node_t*	node;

	ut_ad(thr);

	node = thr->run_node;
	ut_ad(que_node_get_type(node) == QUE_NODE_WHILE);

	ut_ad((thr->prev_node == que_node_get_parent(node))
	      || (que_node_get_next(thr->prev_node) == NULL));

	/* Evaluate the condition */

	eval_exp(node->cond);

	if (eval_node_get_ibool_val(node->cond)) {

		/* The condition evaluated to TRUE: start execution
		from the first statement in the statement list */

		thr->run_node = node->stat_list;
	} else {
		thr->run_node = que_node_get_parent(node);
	}

	return(thr);
}

/**********************************************************************//**
Performs an execution step of an assignment statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
assign_step(
/*========*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	assign_node_t*	node;

	ut_ad(thr);

	node = thr->run_node;
	ut_ad(que_node_get_type(node) == QUE_NODE_ASSIGNMENT);

	/* Evaluate the value to assign */

	eval_exp(node->val);

	eval_node_copy_val(node->var->alias, node->val);

	thr->run_node = que_node_get_parent(node);

	return(thr);
}

/**********************************************************************//**
Performs an execution step of a for-loop node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
for_step(
/*=====*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	for_node_t*	node;
	que_node_t*	parent;
	lint		loop_var_value;

	ut_ad(thr);

	node = thr->run_node;

	ut_ad(que_node_get_type(node) == QUE_NODE_FOR);

	parent = que_node_get_parent(node);

	if (thr->prev_node != parent) {

		/* Move to the next statement */
		thr->run_node = que_node_get_next(thr->prev_node);

		if (thr->run_node != NULL) {

			return(thr);
		}

		/* Increment the value of loop_var */

		loop_var_value = 1 + eval_node_get_int_val(node->loop_var);
	} else {
		/* Initialize the loop */

		eval_exp(node->loop_start_limit);
		eval_exp(node->loop_end_limit);

		loop_var_value = eval_node_get_int_val(node->loop_start_limit);

		node->loop_end_value
                  = (int) eval_node_get_int_val(node->loop_end_limit);
	}

	/* Check if we should do another loop */

	if (loop_var_value > node->loop_end_value) {

		/* Enough loops done */

		thr->run_node = parent;
	} else {
		eval_node_set_int_val(node->loop_var, loop_var_value);

		thr->run_node = node->stat_list;
	}

	return(thr);
}

/**********************************************************************//**
Performs an execution step of an exit statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
exit_step(
/*======*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	exit_node_t*	node;
	que_node_t*	loop_node;

	ut_ad(thr);

	node = thr->run_node;

	ut_ad(que_node_get_type(node) == QUE_NODE_EXIT);

	/* Loops exit by setting thr->run_node as the loop node's parent, so
	find our containing loop node and get its parent. */

	loop_node = que_node_get_containing_loop_node(node);

	/* If someone uses an EXIT statement outside of a loop, this will
	trigger. */
	ut_a(loop_node);

	thr->run_node = que_node_get_parent(loop_node);

	return(thr);
}

/**********************************************************************//**
Performs an execution step of a return-statement node.
@return	query thread to run next or NULL */
UNIV_INTERN
que_thr_t*
return_step(
/*========*/
	que_thr_t*	thr)	/*!< in: query thread */
{
	return_node_t*	node;
	que_node_t*	parent;

	ut_ad(thr);

	node = thr->run_node;

	ut_ad(que_node_get_type(node) == QUE_NODE_RETURN);

	parent = node;

	while (que_node_get_type(parent) != QUE_NODE_PROC) {

		parent = que_node_get_parent(parent);
	}

	ut_a(parent);

	thr->run_node = que_node_get_parent(parent);

	return(thr);
}
